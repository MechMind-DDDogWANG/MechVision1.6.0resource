{
    "2D Rectangle Matching": {
        "systemType": true
    },
    "2D Rectangle Matching (with Deep Learning)": {
        "systemType": true
    },
    "3D Matching": {
        "systemType": true
    },
    "Apply Masks to Color Image": {
        "systemType": true
    },
    "Binary Classification Based on Elements Number": {
        "systemType": true
    },
    "Calc Color Image for Highest Layer": {
        "systemType": true
    },
    "Calc Mask for Highest Layer": {
        "systemType": true
    },
    "Calc and Adjust Poses from Planar Point Clouds": {
        "systemType": true
    },
    "Filter Out Point Clouds that Exceed the Size Limit": {
        "systemType": true
    },
    "Filter Out Poses Outside ROI": {
        "systemType": true
    },
    "Filter Out Poses that Exceed the Angle Limit": {
        "systemType": true
    },
    "Instance Segmentation (Color & Depth)": {
        "systemType": true
    },
    "Instance Segmentation (Color)": {
        "systemType": true
    },
    "Measure Circle to Circle": {
        "subgroup": "Measure"
    },
    "Passive Stereo Camera": {
        "deprecatedType": true,
        "systemType": true
    },
    "Point Cloud Preprocessing": {
        "systemType": true
    },
    "QObject": {
        "properties": {
            "objectName": {
                "name": "Step Name"
            }
        }
    },
    "Save Images and Step Properties": {
        "systemType": true
    },
    "Sort Clouds Based on XOY Distance to Camera Center": {
        "subgroup": "Sort",
        "systemType": true
    },
    "Sort Pick Points": {
        "subgroup": "Sort",
        "systemType": true
    },
    "Sort by Three Values": {
        "subgroup": "Sort",
        "systemType": true
    },
    "Sort by Two Values": {
        "subgroup": "Sort",
        "systemType": true
    },
    "Transform Clouds from Current Coordinate to Specific Coordinate": {
        "systemType": true
    },
    "enums": {
        "mmind::DataIterator::PlayMode": {
            "PlayAll": "Play All",
            "RepeatAll": "Repeat All",
            "RepeatOne": "Repeat One",
            "Shuffle": "Shuffle"
        },
        "mmind::PPFEnums::RegistrationMode": {
            "EdgeRegistration": "Edge Matching",
            "SurfaceRegistration": "Surface Matching"
        },
        "mmind::Step::ExecFlags": {
            "ContinueWhenNoOutput": "Continue When No Output",
            "NotifyProcedureOutWhenNoOutput": "Notify Procedure Out When No Output",
            "ReloadFile": "Reload File",
            "ReuseInput": "Reuse Input",
            "TextOutput": "Textualize Output",
            "TriggerCtrlWhenNoOutput": "Trigger Control Flow When No Output",
            "TriggerCtrlWhenOutput": "Trigger Control Flow When Output",
            "VisualizeOutput": "Visualize Output"
        },
        "mmind::StepBlobAnalysis::Connectivity": {
            "EIGHT_CONNECTION": "Eight-Connectivity",
            "FOUR_CONNECTION": "Four-Connectivity"
        },
        "mmind::StepBlobAnalysis::ContourRetrievalMode": {
            "RETR_EXTERNAL": "Outer",
            "RETR_TREE": "All"
        },
        "mmind::StepBlobAnalysis::Polarity": {
            "BRIGHTER_THAN_BACKGROUND": "Brighter than Background",
            "DARKER_THAN_BACKGROUND": "Darker than Background"
        },
        "mmind::StepBlobAnalysis::SortCriteria": {
            "AREA": "Area",
            "CIRCULARITY": "Circularity",
            "PERIMETER": "Perimeter",
            "RECTANGULARITY": "Rectangularity"
        },
        "mmind::StepBlobAnalysis::ThresholdMethod": {
            "AUTO_THRESHOLD": "Auto",
            "BINARY_THRESHOLD": "Custom"
        },
        "mmind::StepCalcDistanceCircleToCircle::DistanceMode": {
            "CenterToCenter": "Center To Center"
        },
        "mmind::StepCalcDistanceCircleToSegment::DistanceMode": {
            "CenterToSegment": "Center To Segment"
        },
        "mmind::StepCalcDistancePointToCircle::DistanceMode": {
            "PointToCenter": "Point To Center"
        },
        "mmind::StepCloudROI::InputCloudCoordType": {
            "Camera": "Camera Coordinate",
            "Robot": "Robot Coordinate"
        },
        "mmind::StepCoarseRegistrationV2::RegistrationMode": {
            "EdgeRegistration": "Edge Registration",
            "SurfaceRegistration": "Surface Registration"
        },
        "mmind::StepCoarseRegistrationV2::VisualizationOption": {
            "PointsUsedInPv": "Points Used in Pose Verification",
            "RegistrationResult": "Registration Result",
            "SampledModel": "Sampled Model ",
            "SampledScene": "Sampled Scene"
        },
        "mmind::StepCoarseRegistrationV2::VoxelLengthGenetationStrategy": {
            "AutoHalfAveDist": "Auto Generated According to Points Distance",
            "AutoHalfLeafSize": "Auto Generated According to Leaf Size"
        },
        "mmind::StepDeepLearningPack::ClsResultsOutputFlags": {
            "ConfidencesOutput": "Confidences Output",
            "LabelsOutput": "Labels Output"
        },
        "mmind::StepDeepLearningPack::DetResultsOutputFlags": {
            "BboxesOutput": "Bounding Boxes Output",
            "ConfidencesOutput": "Confidences Output",
            "LabelsOutput": "Labels Output",
            "ResultImagesOutput": "Result Images Output"
        },
        "mmind::StepDeepLearningPack::SegResultsOutputFlags": {
            "AreasOutput": "Areas Output",
            "ConfidencesOutput": "Confidences Output",
            "ContoursOutput": "Contours Output",
            "MaskOutput": "Mask Output",
            "PerimetersOutput": "Perimeters Output",
            "SegResultOutput": "Result Output"
        },
        "mmind::StepDeepLearningPackInfer::ClsResultsOutputFlags": {
            "ConfidencesOutput": "Output Confidence",
            "LabelsOutput": "Output Label"
        },
        "mmind::StepDeepLearningPackInfer::FastPositioningResultsOutputFlags": {
            "ResultDatasOutput": "Output Rotation Angle",
            "ResultImagesOutput": "Output Result Image"
        },
        "mmind::StepDeepLearningPackInfer::InstanceSegResultsOutputFlags": {
            "BboxMasksOutput": "Output Bounding Box Masks",
            "BboxesOutput": "Output Bounding Boxes",
            "ConfidencesOutput": "Output Confidences",
            "LabelsOutput": "Output Labels",
            "MasksOutput": "Output Masks"
        },
        "mmind::StepDeepLearningPackInfer::ObjResultsOutputFlags": {
            "BboxesOutput": "Output Bounding Boxes",
            "ConfidencesOutput": "Output Confidences",
            "LabelsOutput": "Output Labels",
            "ResultImagesOutput": "Output Images"
        },
        "mmind::StepDeepLearningPackInfer::SegResultsOutputFlags": {
            "ContoursOutput": "Output Contours",
            "MaskOutput": "Output Mask",
            "SegResultOutput": "Output Result"
        },
        "mmind::StepGeneralReadImage::ImageSource": {
            "Dir": "Directory",
            "File": "File"
        },
        "mmind::StepGeneralReadPointCloud::PointCloudSource": {
            "Dir": "Dir",
            "File": "File"
        },
        "mmind::StepGeneralReadPointCloud::PointCloudType": {
            "PointCloudNormal": "PointCloudNormal",
            "PointCloudXYZ": "PointCloudXYZ",
            "PointCloudXYZRGB": "PointCloudXYZRGB"
        },
        "mmind::StepGraspPointPredictor::GripperType": {
            "ParallelJaw": "Parallel Jaw",
            "SuctionCup": "Suction Cup"
        },
        "mmind::StepGraspPointPredictor::MethodType": {
            "ArgMax": "Binary Thresholding",
            "PositiveProbability": "Original Probability"
        },
        "mmind::StepGraspPoseEstimation::ShowType": {
            "All": "Show Final Score",
            "FinalScore": "Final Score",
            "ObjectLength": "Show Object Length",
            "ObjectToBinDist": "Show Object To Bin Distance",
            "PointsInMask": "Show Number of Points in Mask ",
            "PoseDirection": "Show Pose Direction",
            "PoseHeight": "Show Pose Height",
            "SuckerLength": "Show Sucker Length",
            "SuckerSize": "Show Sucker Diameter",
            "SuctionCupDiameter": "Show Suction Cup Diameter"
        },
        "mmind::StepLightSourceControl::Operation": {
            "TurnOffDevice": "Turn Off Device",
            "TurnOnDevice": "Turn On Device"
        },
        "mmind::StepMeasurePrimitives::SubPixelAlgo": {
            "Fast": "Fast",
            "Precise": "Precise"
        },
        "mmind::StepReadImage::ImageSource": {
            "Dir": "Directory",
            "File": "File"
        },
        "mmind::StepRotPoseToGoalDirection::AxisTypeWithCustomized": {
            "Neg_X": "-X",
            "Neg_Y": "-Y",
            "Neg_Z": "-Z",
            "Pos_X": "+X",
            "Pos_Y": "+Y",
            "Pos_Z": "+Z"
        },
        "mmind::StepSaveResult::OutputPathType": {
            "Absolute": "Absolute",
            "BaseName": "BaseName",
            "FileName": "Filename"
        },
        "mmind::StepStraightenRingShapedImageRegion::RadialDirection": {
            "Inward": "Inward",
            "Outward": "Outward"
        },
        "mmind::enums::FilePathType": {
            "BaseName": "Base Name",
            "CompletePath": "Complete Path",
            "FileName": "File Name"
        },
        "mmind::enums::RegistrationMode": {
            "EdgeRegistration": "Edge Registration",
            "SurfaceRegistration": "Surface Registration"
        },
        "mmind::enums::SceneType": {
            "Camera": "Camera Coordinate",
            "Robot": "Robot Coordinate"
        },
        "mmind::ppfEnum::RegistrationMode": {
            "EdgeRegistration": "Edge Registration",
            "SurfaceRegistration": "Surface Registration"
        }
    },
    "mmind::APS2": {
        "properties": {
            "baudRate": {
                "infrequentlyUsed": true,
                "maximum": 100000,
                "minimum": 0
            },
            "dataBits": {
                "infrequentlyUsed": true
            },
            "flowControl": {
                "infrequentlyUsed": true
            },
            "parity": {
                "infrequentlyUsed": true
            },
            "portIndex": {
                "maximum": 100,
                "minimum": 0,
                "valueToolTip": "If the port name is COM1, the corresponding port index is 1."
            },
            "stopBits": {
                "infrequentlyUsed": true
            }
        }
    },
    "mmind::AbstractCamera": {
        "properties": {
            "cameraId": {
                "name": "Camera ID",
                "subtype": 4,
                "valueToolTip": "Select camera"
            },
            "cameraParameterGroupName": {
				"name": "Camera Calibration Parameters",
                "subtype": 3
            },
            "reconnectTimes": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "Max times to reconnect to the camera if connection failure occured.",
                "maximum": 10,
                "minimum": 1,
                "name": "Reconnect Times",
                "showSlider": false,
                "singleStep": 1
            },
            "virtualMode": {
                "subtype": 1
            }
        }
    },
    "mmind::AbstractLaserProfiler": {
        "groupInfos": {
            "Stop Criteria": [
                "ySampleRatio",
                "transDist",
                "maxRowNum",
                "timeOut",
                "rowNumConstraint"
            ]
        },
        "properties": {
            "configFileName": {
                "subtype": 2
            },
            "ip": {
                "name": "IP",
                "subtype": 4
            },
            "maxRowNum": {
                "maximum": 2147483647,
                "minimum": 0,
                "name": "Max Row Number"
            },
            "pulseEquivalency": {
                "decimals": 10,
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.0001,
                "subtype": 2,
                "valueToolTip": "The resolution of the signals received from the motion control platform."
            },
            "rowNumConstraint": {
                "valueToolTip": "The acquisition process will terminate when the timeout or the row number condition is satisfied."
            },
            "saveEncoderValuesToJson": {
                "infrequentlyUsed": true,
                "valueToolTip": "If this option is checked, the encoder values from the motion control platform will be saved in a subfolder named \"EncoderValues\" in the current project."
            },
            "timeOut": {
                "maximum": 500000,
                "minimum": 0,
                "valueToolTip": "The acquisition process will terminate when the timeout or the row number condition is satisfied."
            },
            "timerInterval": {
                "infrequentlyUsed": true,
                "maximum": 5000,
                "minimum": 0,
                "valueToolTip": "The frequency to acquire a package of data from the camera."
            },
            "transDist": {
                "decimals": 3,
                "maximum": 100000,
                "minimum": 0,
                "name": "Translation Distance",
                "singleStep": 0.001,
                "subtype": 2,
                "valueToolTip": "Desired Row Number = Translation Distance/Refinement Ratio/Pluse Equivalency"
            },
            "xOffset": {
                "maximum": 5000,
                "minimum": -5000,
                "name": "Horizontal Offset",
                "subtype": 2,
                "valueToolTip": "The horizontal translation for each turn in the round trip.\nThis value could be negative."
            },
            "ySampleRatio": {
                "maximum": 100000,
                "minimum": 1,
                "name": "Refinement Ratio",
                "valueToolTip": "It is the refinement ratio along the translation direction. In most cases, this value can be obtained from the camera software.\nThis property is only used to calculate the number of required rows and does not change the refinement ratio of the camera."
            }
        }
    },
    "mmind::AbstractLightSourceController": {
        "properties": {
            "channels": {
                "valueToolTip": "The channels and the luminous intensities should be set in pairs. The channel index starts from 0."
            },
            "luminousIntensities": {
                "valueToolTip": "The channels and the luminous intensities should be set in pairs. The minimum luminous intensities are all zero, and the maximum values depend on the device."
            }
        }
    },
    "mmind::AdaptiveThreshold": {
        "properties": {
            "adaptiveMethod": {
                "infrequentlyUsed": true
            },
            "blockSize": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "minimum": 2,
                "singleStep": 1
            },
            "constant": {
                "infrequentlyUsed": true,
                "keyToolTip": "Constant subtracted from the mean or weighted mean (see the details below). Normally, it is positive but may be zero or negative as well."
            },
            "threImgType": {
                "infrequentlyUsed": true,
                "name": "Image Type"
            },
            "threOperationType": {
                "name": "Segmentation Operation",
                "valueToolTip": "The following operation is recommended:\nTHRESH_BINARY: Generate a mask image of the pixels whose intensity is higher than the threshold.\nTHRESH_BINARY_INV: Generate a mask image of the pixels whose intensity is lower than the threshold."
            }
        }
    },
    "mmind::AlignedCircumscribedRect": {
        "properties": {
            "alignedSearchRadius": {
                "minimum": 1,
                "singleStep": 1,
                "suffix": "pixel"
            }
        }
    },
    "mmind::AlignedInscribedRect": {
        "properties": {
            "alignedSearchRadius": {
                "minimum": 1,
                "singleStep": 1,
                "suffix": "pixel"
            },
            "translationStep": {
                "minimum": 0,
                "singleStep": 1,
                "suffix": "pixel"
            }
        }
    },
    "mmind::BgSegmentator": {
        "groupInfos": {
            "Initialization Status": [
                "initialized",
                "imgWidth",
                "imgHeight",
                "projectDir"
            ]
        },
        "properties": {
            "imgHeight": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1,
                "suffix": "pixel"
            },
            "imgWidth": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1,
                "suffix": "pixel"
            },
            "projectDir": {
                "subtype": 1
            }
        }
    },
    "mmind::BilateralFilter": {
        "properties": {
            "diameter": {
                "decimals": 0,
                "keyToolTip": "The diameter of each pixel neighborhood that is used during filtering",
                "minimum": 0,
                "singleStep": 1
            },
            "sigmaColor": {
                "decimals": 0,
                "keyToolTip": "A larger value of the parameter means that\nfarther pixels will influence each other as long as their color are close enough.",
                "minimum": 0,
                "singleStep": 1
            },
            "sigmaSpace": {
                "decimals": 0,
                "keyToolTip": "A larger value of the parameter means that farther color within the pixel neighborhood will be mixed together, resulting in larger areas of semi-equal color.",
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::BoxFilter": {
        "properties": {
            "kernelSize": {
                "decimals": 0,
                "keyToolTip": "The kernel size.",
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::CCTagDetector": {
        "properties": {
            "cannyHighThreshold": {
                "minimum": 0
            },
            "cannyLowThreshold": {
                "minimum": 0
            },
            "innerCircleRadius": {
                "minimum": 0
            }
        }
    },
    "mmind::CLAHE": {
        "properties": {
            "clipLimit": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The threshold for contrast limit. \nIf an intensity value has the number of pixels larger than this, those pixels are distributed into other bins in the histogram.",
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::CannyDetector": {
        "properties": {
            "highThreshold": {
                "decimals": 4,
                "keyToolTip": "The pixel is kept for being an edge pixel if its gradient is larger this value.",
                "maximum": 255,
                "minimum": 1,
                "name": "High Threshold (1 ~ 255)",
                "singleStep": 1
            },
            "lowThreshold": {
                "decimals": 4,
                "keyToolTip": "The pixel is rejected for not being an edge pixel if its gradient is below this value.",
                "maximum": 255,
                "minimum": 1,
                "name": "Low Threshold (1 ~ 255)",
                "singleStep": 1
            }
        }
    },
    "mmind::CircleCloudsFilter": {
        "groupInfos": {
            "Contour Settings": [
                "minAreaThreshold",
                "maxAreaThreshold",
                "minCircularity",
                "maxCircularity",
                "minConvexity",
                "maxConvexity",
                "minInertia",
                "maxInertia"
            ]
        },
        "properties": {
            "contourRetrievalMode": {
                "keyToolTip": "Project the point cloud to 2D plane and retrieve its contour.",
                "valueToolTip": "RETR_EXTERNAL: Take the contour.\nRETR_HULL: Take the convex hull of the contour."
            },
            "maxAreaThreshold": {
                "keyToolTip": "A point cloud with larger area than this value will be discarded.",
                "minimum": 0,
                "suffix": "pixel"
            },
            "maxCircularity": {
                "maximum": 1,
                "minimum": 0,
                "valueToolTip": "( 0 ~ 1 )"
            },
            "maxConvexity": {
                "maximum": 1,
                "minimum": 0,
                "valueToolTip": "( 0 ~ 1 )"
            },
            "maxInertia": {
                "maximum": 1,
                "minimum": 0,
                "valueToolTip": "( 0 ~ 1 )"
            },
            "minAreaThreshold": {
                "keyToolTip": "A point cloud with smaller area than this value will be discarded.",
                "minimum": 0
            },
            "minCircularity": {
                "maximum": 1,
                "minimum": 0,
                "valueToolTip": "( 0 ~ 1 )"
            },
            "minConvexity": {
                "maximum": 1,
                "minimum": 0,
                "valueToolTip": "( 0 ~ 1 )"
            },
            "minInertia": {
                "maximum": 1,
                "minimum": 0,
                "valueToolTip": "( 0 ~ 1 )"
            }
        }
    },
    "mmind::CircleCloudsFilterOldVersion": {
        "properties": {
            "contourRetrievalMode": {
                "valueToolTip": "RETR_EXTERNAL: Take the contour.\nRETR_HULL: Take the convex hull of the contour."
            },
            "minAreaThreshold": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::CircleDetectorHough": {
        "properties": {
            "accumulatorThre": {
                "infrequentlyUsed": true,
                "keyToolTip": "The accumulator threshold for the circle centers at the detection stage. The lower the threshold, the more the detected circles.",
                "minimum": 0,
                "name": "Accumulator Threshold",
                "singleStep": 1
            },
            "dp": {
                "infrequentlyUsed": true,
                "keyToolTip": "The ratio of the image resolution to the accumulator resolution. The higher the value, the more detected circles.",
                "minimum": 0
            },
            "edgeSharpness": {
                "keyToolTip": "Edge sharpness level is divided into 10 levels. The higher the level is, the sharper the edge is.",
                "maximum": 10,
                "minimum": 1,
                "singleStep": 1,
                "suffix": "level"
            },
            "edgeSmoothness": {
                "keyToolTip": "The level of edge smoothness is divided into 10 levels. The higher the level is, the smoother the edge is.",
                "maximum": 10,
                "minimum": 1,
                "singleStep": 1,
                "suffix": "level"
            },
            "gradientThre": {
                "infrequentlyUsed": true,
                "keyToolTip": "The high threshold of Canny Edge Detector. The lower the threshold, the more the edge pixels.",
                "minimum": 0,
                "name": "Gradient Threshold"
            },
            "minDistBetweenCircles": {
                "infrequentlyUsed": false,
                "keyToolTip": "The minimum distance between the centers of the detected circles.",
                "minimum": 0,
                "name": "Min Distance Between Circles",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "similarityToCircle": {
                "infrequentlyUsed": false,
                "keyToolTip": "The circle similarity level is divided into 10 levels. The higher the level is, the more circular shape is detected.",
                "maximum": 10,
                "minimum": 1,
                "singleStep": 1,
                "suffix": "level"
            }
        }
    },
    "mmind::CircleDetectorRansac": {
        "properties": {
            "disThre": {
                "keyToolTip": "If the distance between a point and the circle is larger than this value, this point will not be considered to belong to this circle.",
                "minimum": 0,
                "name": "Distance Threshold",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "maxIter": {
                "infrequentlyUsed": true,
                "keyToolTip": "The maximum iteration times.",
                "minimum": 0,
                "name": "Max Iteration Times",
                "singleStep": 1
            },
            "minContourSize": {
                "keyToolTip": "The minimum contour size.",
                "minimum": 0,
                "singleStep": 1,
                "suffix": "pixel"
            },
            "ratio": {
                "keyToolTip": "The proportion threshold of the detected circle points to the expected circle points. If the proportion is less than this value, this detected circle will be eliminated.",
                "maximum": 1,
                "minimum": 0,
                "name": "Ratio (0 ~ 1.0)"
            }
        }
    },
    "mmind::CloudCapacityFilter": {
        "properties": {
            "maxPointsNum": {
                "keyToolTip": "A point cloud with more  points than this value will be discarded.",
                "minimum": 0
            },
            "minPointsNum": {
                "keyToolTip": "A point cloud with less  points than this value will be discarded.",
                "minimum": 0,
                "name": "Min Points Number"
            }
        }
    },
    "mmind::CloudCapacityFilterOldVersion": {
        "properties": {
            "minPointsNum": {
                "name": "Min Points Number"
            }
        }
    },
    "mmind::CloudPreprocessingGPU": {
        "groupInfos": {
            "Calculation Settings": [
                "isBatched",
                "calNormRadius"
            ],
            "Concave & Convex Removal Settings": [
                "removeConvexAndConcave",
                "concaveRadius",
                "concaveThreshold",
                "convexThreshold"
            ],
            "Outlier Removal Settings": [
                "removeSparse",
                "sparseRadius",
                "sparseThreshold",
                "sparseCircleTime"
            ]
        },
        "properties": {
            "calNormRadius": {
                "keyToolTip": "Points within the search radius will be used to calculate the normal.",
                "maximum": 1,
                "minimum": 0,
                "name": "Search Radius",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "concaveRadius": {
                "infrequentlyUsed": true,
                "maximum": 1,
                "minimum": 0,
                "name": "Search Radius",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "concaveThreshold": {
                "infrequentlyUsed": true,
                "minimum": 0
            },
            "convexThreshold": {
                "infrequentlyUsed": true,
                "minimum": 0
            },
            "isBatched": {
                "infrequentlyUsed": true,
                "keyToolTip": "Check this option when there are too many point clouds and the video memory is too small.",
                "name": "Calc in Batches"
            },
            "removeConvexAndConcave": {
                "infrequentlyUsed": true,
                "name": "Remove Convex and Concave Points"
            },
            "removeSparse": {
                "name": "Remove Outliers"
            },
            "sparseCircleTime": {
                "infrequentlyUsed": true,
                "minimum": 0,
                "name": "Circle Times"
            },
            "sparseRadius": {
                "maximum": 1,
                "minimum": 0,
                "name": "Search Radius",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "sparseThreshold": {
                "keyToolTip": "When the number of points within the search radius of the current point is less than the outlier threshold, it is regarded as a sparse point.",
                "minimum": 0,
                "name": "Outlier Threshold"
            }
        }
    },
    "mmind::ColorBalancer": {
        "properties": {
            "blueToYellow": {
                "decimals": 0,
                "keyToolTip": "This image is converted to the Lab color space.The \"b\" value (blueToYellow) is rescaled from one to this value.",
                "maximum": 127,
                "minimum": -128,
                "singleStep": 1,
                "valueToolTip": "Value between -128 and 127."
            },
            "greenToRed": {
                "decimals": 0,
                "keyToolTip": "This image is converted to the Lab color space.The \"a\" value (greenToRed) is rescaled from one to this value.",
                "maximum": 127,
                "minimum": -128,
                "singleStep": 1,
                "valueToolTip": "Value between -128 and 127."
            },
            "lightness": {
                "decimals": 0,
                "keyToolTip": "This image is converted to the Lab color space.The lightness is rescaled from one to this value.",
                "maximum": 127,
                "minimum": -128,
                "singleStep": 1,
                "valueToolTip": "Value between -128 and 127."
            }
        }
    },
    "mmind::ColorValueSegmentator": {
        "groupInfos": {
            "Custom Settings": [
                "threshold",
                "backgroundImgPath"
            ]
        },
        "properties": {
            "backgroundImgPath": {
                "keyToolTip": "The absolute or relative path of the color background image.",
                "subtype": 2
            },
            "threshold": {
                "valueToolTip": "Default is 30."
            }
        }
    },
    "mmind::ConditionalMeanFilter": {
        "properties": {
            "kernelSize": {
                "decimals": 0,
                "minimum": 1,
                "singleStep": 1
            },
            "threshold": {
                "decimals": 0,
                "keyToolTip": "Pixels with a pixel value difference greater than this threshold are not counted during filtering.",
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::DepthValueSegmentator": {
        "groupInfos": {
            "Custom Settings": [
                "threshold",
                "backgroundImgPath"
            ]
        },
        "properties": {
            "backgroundImgPath": {
                "keyToolTip": "The absolute or relative path of the color background image.",
                "subtype": 2
            },
            "threshold": {
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm",
                "valueToolTip": "Defualt is 5."
            }
        }
    },
    "mmind::EditableRoi2DStep": {
        "properties": {
            "roi": {
                "name": "ROI"
            }
        }
    },
    "mmind::EuclideanCluster": {
        "properties": {
            "clusterTolerance": {
                "keyToolTip": "The maximum distance between points in a cluster.",
                "minimum": 0,
                "name": "Max Distance of Neighbouring Points in Output Clusters",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "cores": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "Number of cores for parallel processing tasks.\n0：Maximum number of cores.",
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::External2D": {
        "properties": {
            "AutoExposure": {
                "keyState": true
            },
            "ExposureTime": {
                "minimum": 0
            },
            "MeanGrayValue": {
                "decimals": 0,
                "maximum": 255,
                "minimum": 0,
                "showSlider": true,
                "singleStep": 1
            }
        }
    },
    "mmind::FilterRegLocalMatcher": {
        "properties": {
            "iterationNumber": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The upper limit of the number of iterations.\nThe higher the value is, the longer the execution tends to be.",
                "minimum": 0,
                "name": "Number of Iterations",
                "singleStep": 1
            },
            "matchingMode": {
                "keyToolTip": "HighSpeed: The fastest mode but with the lower precision.\nStandard: A stable mode.\nHighPrecision: The mode with the highest precision but time-consuming."
            },
            "standardDeviation": {
                "decimals": 6,
                "infrequentlyUsed": false,
                "keyToolTip": "The higher the value is, the less precise the result but the faster the execution.",
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "standardDeviationUpdateStepNumber": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The parameter for fine-tuning of the standard deviation.",
                "minimum": 1,
                "singleStep": 1
            }
        }
    },
    "mmind::GammaCorrection": {
        "properties": {
            "gamma": {
                "decimals": 2,
                "keyToolTip": "If gamma>1, image brightness will be increased. If 0<gamma<1, image brightness will be reduced.",
                "maximum": 10,
                "minimum": 0,
                "singleStep": 0.1,
                "valueToolTip": "If gamma>1, image brightness will be increased. If 0<gamma<1, image brightness will be reduced."
            }
        }
    },
    "mmind::GaussianFilter": {
        "properties": {
            "sigmaX": {
                "decimals": 0,
                "keyToolTip": "The Gaussian kernel standard deviation in X direction",
                "minimum": 0,
                "singleStep": 1,
                "valueToolTip": "The larger the value, the more obvious the smoothing effect."
            },
            "sigmaY": {
                "decimals": 0,
                "keyToolTip": "The Gaussian kernel standard deviation in Y direction",
                "minimum": 0,
                "singleStep": 1,
                "valueToolTip": "The larger the value, the more obvious the smoothing effect."
            },
            "sizeX": {
                "decimals": 0,
                "keyToolTip": "The width of the kernel size.",
                "minimum": 0,
                "singleStep": 1,
                "valueToolTip": "A bigger"
            },
            "sizeY": {
                "decimals": 0,
                "keyToolTip": "The height of the kernel size.",
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::GuidedFilter": {
        "properties": {
            "eps": {
                "keyToolTip": "regularization term of Guided Filter.",
                "minimum": 0
            },
            "kernelSize": {
                "decimals": 0,
                "keyToolTip": "The image smoothing effect is more obvious with a larger kernel size.",
                "minimum": 1,
                "singleStep": 1
            }
        }
    },
    "mmind::ICPLocalMatcher": {
        "groupInfos": {
            "Iteration Settings": [
                "nearestPointSearchRadius",
                "mse",
                "iterNum",
                "windowSize",
                "automaticWeight",
                "complexObject",
                "showCorresponse"
            ],
            "Point Pair Rejection": [
                "rejectPair",
                "stddevMulThresh",
                "pointPairAngleDiffThre",
                "applyWeightsOnPairs",
                "removeRepeatCorrespond",
                "removeRepeatCorrespondType"
            ]
        },
        "properties": {
            "applyWeightsOnPairs": {
                "infrequentlyUsed": true,
                "keyToolTip": "If checked, the weight of the model will be used in the iteration of the algorithm. \nTherefore, it tends to have a better matching result of the model fragments with the high weight."
            },
            "automaticWeight": {
                "keyToolTip": "If checked, the automatic weight function will be used.\nFacing the objects whose matching result is bad, then this function is worth to try."
            },
            "complexObject": {
                "keyToolTip": "If the target object is a complex object (not in primitive shape), and if using the automatic weight function as well, please check this option."
            },
            "iterNum": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The upper limit of the number of iterations.\nThe higher the value is, the longer the execution tends to be.",
                "minimum": 1,
                "name": "Number of Iterations",
                "singleStep": 1
            },
            "mse": {
                "decimals": 6,
                "infrequentlyUsed": true,
                "keyToolTip": "The lower limit of the MSE in each iteration.\nThe higher the value is, the quicker the algorithm ends.",
                "minimum": 0,
                "name": "MSE Threshold"
            },
            "nearestPointSearchRadius": {
                "keyToolTip": "The radius for searching neighbor points.\nIt is recommended to be a high value when the sampling interval is large.",
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "pointPairAngleDiffThre": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "If the angle difference between the corresponding point pair's normals is larger than this value, the point pair will be eliminated.",
                "minimum": 0,
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            },
            "rejectPair": {
                "infrequentlyUsed": true,
                "keyToolTip": "If checked, the function of rejecting pairs will be used."
            },
            "removeRepeatCorrespond": {
                "infrequentlyUsed": true,
                "keyToolTip": "If checked, the function of removing repeating corresponding points will be used.\nIt is recommended when the model point cloud has more points than the point cloud of a single object in the scene."
            },
            "removeRepeatCorrespondType": {
                "infrequentlyUsed": true,
                "keyToolTip": "MinDis: More repeating corresponding point pairs will be eliminated.\nGlobalMin: Less repeating corresponding point pairs will be eliminated."
            },
            "showCorresponse": {
                "infrequentlyUsed": false,
                "keyToolTip": "Show corresponding points in each iteration."
            },
            "stddevMulThresh": {
                "infrequentlyUsed": true,
                "keyToolTip": "The point pair whose distance is outside N sigma will be eliminated.",
                "minimum": 0,
                "name": "N Sigma Threshold"
            },
            "windowSize": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The parameter for finding the local minimum. \nThe higher the value is, the more reliable minimum the algorithm will find.",
                "minimum": 2,
                "singleStep": 1
            }
        }
    },
    "mmind::IlluminationNormalization": {
        "groupInfos": {
            "Background Adjustment Settings": [
                "roi"
            ],
            "Gaussain Kernel Settings": [
                "kernelSize",
                "kernelSizeSmall",
                "kernelSizeMedium",
                "kernelSizeLarge"
            ],
            "General Settings": [
                "meanIllumination",
                "method"
            ]
        },
        "properties": {
            "kernelSize": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The Gaussian surround space scales constant.",
                "maximum": 999,
                "minimum": 3,
                "singleStep": 2
            },
            "kernelSizeLarge": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The large Gaussian surround space scales constant.",
                "maximum": 999,
                "minimum": 3,
                "singleStep": 2
            },
            "kernelSizeMedium": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The medium Gaussian surround space scales constant.",
                "maximum": 999,
                "minimum": 3,
                "singleStep": 2
            },
            "kernelSizeSmall": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The small Gaussian surround space scales constant.",
                "maximum": 999,
                "minimum": 3,
                "singleStep": 2
            },
            "meanIllumination": {
                "decimals": 0,
                "keyToolTip": "The mean illumination.",
                "minimum": 0,
                "singleStep": 1
            },
            "method": {
                "keyToolTip": "Choose the method for illumination normalization.",
                "valueToolTip": "Choose the method according to the actual effect. It is recommended to use Retinex_SSR or Retinex_MSR."
            },
            "roi": {
                "name": "ROI"
            }
        }
    },
    "mmind::ImgRectify": {
        "properties": {
            "paraPath": {
                "keyToolTip": "The folder path that saves the camera intrinsic parameter file.",
                "name": "Camera Parameter File Name",
                "stringFileFilter": "*.json",
                "subtype": 2
            }
        }
    },
    "mmind::ImgResize": {
        "properties": {
            "height": {
                "minimum": 1,
                "singleStep": 1
            },
            "width": {
                "keyToolTip": "Resize the image.",
                "minimum": 1,
                "singleStep": 1
            }
        }
    },
    "mmind::LMICamera": {
        "properties": {
            "ip": {
                "name": "Camera IP"
            },
            "receiveTimeOut": {
                "decimals": 0,
                "minimum": 0,
                "name": "Reply Time Out",
                "singleStep": 0
            }
        }
    },
    "mmind::LargestInscribedRect": {
        "properties": {
            "angleStep": {
                "maximum": 360,
                "minimum": 0,
                "name": "Angle Step",
                "singleStep": 1,
                "suffix": "°"
            },
            "translationStep": {
                "minimum": 1,
                "singleStep": 1,
                "suffix": "pixel"
            }
        }
    },
    "mmind::LightSourceControl": {
        "properties": {
            "luminousIntensities": {
                "valueToolTip": "The intensity range of OPT : [0~255]\nThe intensity range of APS2(APS2_24V200MA) : [0~999]\nThe intensity range of APS2(APS2_24V4A) : [0~999]\nThe intensity range of APS2(APS2_24V10A) : [0~255]"
            }
        }
    },
    "mmind::Lucid": {
        "properties": {
            "NetCamIp": {
                "name": "3D Camera's IP",
                "subtype": 4
            },
            "TimeOut": {
                "decimals": 0,
                "minimum": 0,
                "name": "Reply Time Out",
                "singleStep": 1
            },
            "cam2dAutoExposure": {
                "name": "Use Auto Exposure on 2D Camera"
            },
            "cam2dExposureTime": {
                "decimals": 2,
                "maximum": 1000,
                "minimum": 0.02,
                "name": "2D Camera's Exposure Time",
                "singleStep": 0.01
            },
            "cam2dIp": {
                "name": "2D Camera's IP"
            },
            "cam2dMeanGrayValue": {
                "decimals": 0,
                "maximum": 255,
                "minimum": 0,
                "name": "2D Camera's Mean Gray Value",
                "singleStep": 1
            },
            "cam2dType": {
                "keyState": true,
                "name": "2D Camera's Type"
            },
            "cam3dAccumulatedImages": {
                "decimals": 0,
                "maximum": 32,
                "minimum": 1,
                "name": "3D Camera's Accumulated Images",
                "singleStep": 1
            },
            "cam3dDepthGain": {
                "infrequentlyUsed": true,
                "name": "3D Camera's Gain"
            },
            "cam3dEnableConfidenceThresh": {
                "infrequentlyUsed": false,
                "name": "Use Confidence Threshold on 3D Camera"
            },
            "cam3dEnableSpatialFilter": {
                "infrequentlyUsed": true,
                "name": "Use Spatial Filter on 3D Camera"
            },
            "cam3dExposure": {
                "infrequentlyUsed": true,
                "name": "3D Camera's Exposure"
            },
            "cam3dInfraredGain": {
                "decimals": 1,
                "maximum": 128,
                "minimum": 0,
                "name": "3D Camera's Infrared Gain",
                "singleStep": 0.1
            },
            "cam3dMinConfidenceThresh": {
                "decimals": 0,
                "infrequentlyUsed": false,
                "maximum": 65535,
                "minimum": 0,
                "name": "3D Camera's Min Confidence Threshold",
                "singleStep": 1
            },
            "cam3dWorkDist": {
                "infrequentlyUsed": true,
                "name": "3D Camera's Working Distance"
            },
            "limitAverageGrayValueOfOutputImage": {
                "keyToolTip": "true: Limit the average gray value of the output image. When the gray value of the output image is not within the set range, it will be collected again until it meets the gray range or reaches the maximum number of acquisitions; false: Does not limit the average gray value of the output image.",
                "name": "Limit Average Gray Value of Output Image"
            },
            "maxGrayValue": {
                "decimals": 0,
                "maximum": 255,
                "minimum": 0,
                "singleStep": 1
            },
            "maxIterationNums": {
                "decimals": 0,
                "minimum": 1,
                "singleStep": 1
            },
            "minGrayValue": {
                "decimals": 0,
                "maximum": 255,
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::MOGSegmentator": {
        "groupInfos": {
            "Custom Settings": [
                "history",
                "threshold",
                "detectShadows",
                "backgroundSeriesDir",
                "learningRate",
                "thresholdGen",
                "nMixtures",
                "shadowThres",
                "backgroundRatio"
            ]
        },
        "properties": {
            "backgroundRatio": {
                "infrequentlyUsed": true,
                "keyToolTip": "When this value is small, the gaussian mixture models might not use all learnt models to estimate, which might affect the performance.",
                "maximum": 1,
                "valueToolTip": "Default is 0.9."
            },
            "backgroundSeriesDir": {
                "keyToolTip": "Abosulate or relative path of the folder containing the background images under different lighting conditions.",
                "subtype": 1,
                "valueToolTip": "After editing the path, user needs to check \"reloadFile\" and run the step once to reinitialize.\nIf \"initialized\" is True and before continuously running the vision project, user needs to uncheck \"reloadFile\" so as to remove the redundant initialization process and reduce execution time."
            },
            "history": {
                "keyToolTip": "When this value is small, the memory usage can be smaller.\nRecommend to set it as the number of pictures under the background series directory."
            },
            "learningRate": {
                "infrequentlyUsed": true,
                "keyToolTip": "This paramter only affect the initialization process of the mixture of gaussian models."
            },
            "nMixtures": {
                "infrequentlyUsed": true
            },
            "shadowThres": {
                "infrequentlyUsed": true,
                "keyToolTip": "If this threshold value is set to be close to 255, it means user don't want the shadow appear in foreground mask.\nOtherwise, if this value is smaller than 128 and close to 0, the shadow area will appear in foreground mask.\nIf the value is set to be -1, user can run this single step to visualize the mask with shadow area (which is marked as grey.)",
                "maximum": 254,
                "minimum": -1
            },
            "threshold": {
                "keyToolTip": "When this value is smaller, more pixels can be recognized as foreground pixels."
            },
            "thresholdGen": {
                "infrequentlyUsed": true
            }
        }
    },
    "mmind::MechEye": {
        "groupInfos": {
            "Debug Properties": [
                "saveDbgImgs",
                "savePath",
                "maxSavingNum"
            ]
        },
        "properties": {
            "configGroup": {
                "infrequentlyUsed": true,
				"name": "Camera Config Group",
                "keyToolTip": "This setting should be used with a running Mech-Eye camera.\nIf Mech-Eye has a specific configuration for black objects called 'black'; and another specific configuration for white objects called 'white', then here user can input the configuration name to use the specific settings in Mech-Eye.\nSuitable for a case where multiple vision projects is using same Mech-Eye camera, and each of the project needs to detect objects with various colors. Then vision project can set to their own camera configuration through here.",
                "subtype": 3,
                "valueToolTip": "Default is empty input, so as to use the current configuration from Mech-Eye."
            },
            "maxSavingNum": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The maximum of saved debug images.",
                "minimum": 0,
                "singleStep": 1
            },
            "mergeParamsInJson": {
                "infrequentlyUsed": true
            },
            "needRectify": {
                "infrequentlyUsed": true,
                "notEditable": false,
                "required": false,
                "subtype": 1
            },
            "saveDbgImgs": {
                "infrequentlyUsed": true,
                "name": "Save Debug Images",
                "subtype": 1
            },
            "savePath": {
                "infrequentlyUsed": true,
                "keyToolTip": "Directory to save debug images.\nIf save debug images is set True, but directory path is empty, then debug images will be saved under current project directory.",
                "name": "Debug Image Directory",
                "subtype": 1
            }
        }
    },
    "mmind::MedianFilter": {
        "properties": {
            "kernelSize": {
                "decimals": 0,
                "keyToolTip": "The image smoothing effect is more obvious with a larger kernel size.",
                "minimum": 1,
                "singleStep": 1
            }
        }
    },
    "mmind::MorphOperatorWithKernel": {
        "properties": {
            "kernelSize": {
                "decimals": 0,
                "keyToolTip": "The size of the kernel.",
                "maximum": 999,
                "minimum": 3,
                "singleStep": 2,
                "suffix": "pixel"
            },
            "morphShapes": {
                "name": "Kernel Shape",
                "valueToolTip": "MORPH_RECT: Use a rectangular kernel.\nMORPH_CROSS: Use a cross-like kernel.\nMORPH_ELLIPSE: Use a ellipse-shaped kernel."
            }
        }
    },
    "mmind::NetCamera": {
        "properties": {
            "portNumber": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "maximum": 65535,
                "minimum": 1,
                "name": "Camera Port (1 ~ 65535)",
                "singleStep": 1
            },
            "timeOut": {
                "decimals": 0,
                "maximum": 9999,
                "minimum": 1,
                "singleStep": 1
            }
        }
    },
    "mmind::NormalEstimation": {
        "properties": {
            "halfKernelSize": {
                "infrequentlyUsed": true,
                "keyToolTip": "Points that are within the search kernel and whose distance to the center point is less than the search radius will be used to calculate the normal."
            },
            "searchRadius": {
                "infrequentlyUsed": true,
                "keyToolTip": "Points that are within the search kernel and whose distance to the center point is less than the search radius will be used to calculate the normal.",
                "maximum": 1,
                "minimum": 0.001,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            }
        }
    },
    "mmind::NormalsFilter": {
        "groupInfos": {
            "Angle Thresholding Settings": [
                "minAngle",
                "maxAngle"
            ],
            "Reference Direction": [
                "useRobotZInCamera",
                "alignX",
                "alignY",
                "alignZ"
            ]
        },
        "properties": {
            "maxAngle": {
                "decimals": 0,
                "keyToolTip": "Maximum angle difference between reference direction and normal of point.",
                "maximum": 90,
                "minimum": 0,
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            },
            "minAngle": {
                "decimals": 0,
                "keyToolTip": "Minimum angle difference between reference direction and normal of point.",
                "maximum": 90,
                "minimum": 0,
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            },
            "useRobotZInCamera": {
                "keyToolTip": "Using robot Z axis described in camera coordinate as th reference direction."
            }
        }
    },
    "mmind::OPT": {
        "properties": {
            "ip": {
                "name": "IP"
            }
        }
    },
    "mmind::OrderByDateTime": {
        "properties": {
            "dirExpiration": {
                "keyToolTip": "Select the refresh period of the file directory, refresh the directory every week or month, or never refresh.",
                "name": "Folder Expiration",
                "valueToolTip": "Week: Only keep files for a week.\nMonth: Only keep the files for a month.\nForever: No time constraints."
            }
        }
    },
    "mmind::OrderByIndexDir": {
        "properties": {
            "folderNameLength": {
                "keyToolTip": "Forders are named by indices. The value of this property is the number of digits."
            }
        }
    },
    "mmind::OrderBySequence": {
        "properties": {
            "autoOverwriteFiles": {
                "name": "Overwrite Existing File"
            },
            "maxFileSize": {
                "keyToolTip": "The max number of files saved.",
                "minimum": 1,
                "name": "Max File Num"
            }
        }
    },
    "mmind::PPFInitPose": {
        "groupInfos": {
            "Clustering Settings": [
                "clusterRatio",
                "clusterDeltaAngle",
                "clusterDeltaDist",
                "clusterTransformTopN"
            ],
            "Pose Verification Settings": [
                "usePV",
                "pvMarkedMargin",
                "voxelLength",
                "pvOutputSize"
            ],
            "Results Visualization": [
                "showSampledSceneCloud",
                "showOutputModelAndSceneCloud",
                "showSampledModelCloud"
            ],
            "Sample Settings": [
                "sampler",
                "autoUniformSample",
                "expectedModelSampledNum",
                "maxSizeOfSampledModel",
                "maxSizeOfSampledScene",
                "leafSize",
                "minLeafSize"
            ],
            "Voting Settings": [
                "distQuantification",
                "angleQuantification",
                "maxVoteRatio",
                "refStep",
                "referredStep",
                "denseSideBySideEdges"
            ]
        },
        "properties": {
            "angleQuantification": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The quantification of the angle between points' normals ( Angle Interval= 360° / Angle Quantification ).\nThe bigger the angle quantification is, the more precise the result tends to be, but the higher the requirements for point cloud quality.",
                "minimum": 1,
                "singleStep": 1
            },
            "autoUniformSample": {
                "keyToolTip": "Enable the function of calculating the Sampling Interval automatically given \"Expected Point Number of Sampled Model\".",
                "name": "Enable Automatic Downsampling"
            },
            "clusterDeltaAngle": {
                "infrequentlyUsed": true,
                "keyToolTip": "This is the maximum angle difference in one cluster after the poses are clustered.",
                "minimum": 0,
                "name": "Threshold of Angle Difference",
                "suffix": "°"
            },
            "clusterDeltaDist": {
                "decimals": 4,
                "infrequentlyUsed": true,
                "keyToolTip": "This is the maximum distance difference in one cluster after the poses are clustered.",
                "minimum": 0,
                "name": "Threshold of Distance Difference",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "clusterRatio": {
                "infrequentlyUsed": true,
                "keyToolTip": "The ratio of pose candidates used for clustering.\nThe higher the value is, the higher probability to find the accurate matching result, but the more time-consuming the execution.",
                "minimum": 0
            },
            "clusterTransformTopN": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The top N poses with high scores will be output.",
                "minimum": 1,
                "name": "Output First N Clusters with High Scores",
                "singleStep": 1
            },
            "denseSideBySideEdges": {
                "keyToolTip": "This option is checked under two situations. \n1. The boundary point cloud is used; \nThe orientation of each point is \"Normal Direction\"; \nObjects are placed densely side by side. \n2. The boundary point cloud is used; \nThe orientation of each point is \"Tangent Direction\";\nMultiple objects need to be matched in one point cloud.\nThe front and back of the workpiece may appear randomly."
            },
            "distQuantification": {
                "infrequentlyUsed": true,
                "keyToolTip": "The value for the quantification of the distance between points ( Distance Interval = \"Distance Quantification\" * \"Sampling Interval\" ).\nThe bigger the value is, the less precise the result tends to be.",
                "minimum": 0.0001,
                "name": "Distance Quantification",
                "singleStep": 0.001
            },
            "expectedModelSampledNum": {
                "decimals": 0,
                "keyToolTip": "The expected point number of the sampled model point cloud.\nThe smaller the value, the less the point number of the sampled point cloud. Thus, the estimated poses become less precise.",
                "minimum": 1,
                "name": "Expected Point Number of Sampled Model",
                "singleStep": 1
            },
            "leafSize": {
                "decimals": 6,
                "keyToolTip": "The max distance between points of the sampled point cloud.\nThe bigger the value, the less the point number of the sampled point cloud. Thus, the estimated poses become less precise.",
                "minimum": 0.0001,
                "name": "Sampling Interval",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "maxSizeOfSampledModel": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The upper limit of the point number of the sampled model point cloud.",
                "minimum": 1,
                "name": "Max Point Number of Sampled Model",
                "singleStep": 1
            },
            "maxSizeOfSampledScene": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The lower limit of the point number of the sampled model point cloud.",
                "minimum": 1,
                "name": "Max Point Number of Sampled Scene",
                "singleStep": 1
            },
            "maxVoteRatio": {
                "infrequentlyUsed": true,
                "keyToolTip": "Poses whose score is higher than the value, highest pose score in the vote * \"Max Vote Ratio\", will be used to the cluster or pose verification process. \nThe lower the value is, the higher probability to find the accurate matching result, but the more time-consuming the execution.",
                "minimum": 0
            },
            "minLeafSize": {
                "decimals": 6,
                "keyToolTip": "After \"Enable Automatic Downsampling\" is checked, the sampling interval will be calculated. \nWhen the calculated sampling interval is less than this value, this value will be used as the sampling interval.",
                "minimum": 0.0001,
                "name": "Min Sampling Interval",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "pvMarkedMargin": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The number of marked neighbor voxels.\nThe higher the value is, the less precise the result tends to be.",
                "minimum": 1,
                "name": "Marked Margin",
                "singleStep": 1
            },
            "pvOutputSize": {
                "decimals": 0,
                "keyToolTip": "The expected number of detected poses in each point cloud.",
                "minimum": 1,
                "name": "Maximum Number of Detected Poses in Each Point Cloud",
                "singleStep": 1
            },
            "refStep": {
                "decimals": 0,
                "infrequentlyUsed": false,
                "keyToolTip": "This parameter is used for sampling the point cloud to make point pairs.\nThe bigger the value, the faster the execution, but the accuracy becomes lower.",
                "minimum": 1,
                "name": "Reference Point Step",
                "singleStep": 1
            },
            "referredStep": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "This parameter is used for sampling the point cloud to make point pairs.\nThe bigger the value, the faster the execution, but the accuracy becomes lower.",
                "minimum": 1,
                "name": "Referred Point Step",
                "singleStep": 1
            },
            "showOutputModelAndSceneCloud": {
                "keyToolTip": "Show the estimated poses of objects by rendering the transformed models and the scene point cloud.",
                "name": "Show Matching Results"
            },
            "showSampledModelCloud": {
                "infrequentlyUsed": true,
                "keyToolTip": "Show the sampled point cloud of the model."
            },
            "showSampledSceneCloud": {
                "infrequentlyUsed": true,
                "keyToolTip": "Show the sampled point cloud of the scene."
            },
            "usePV": {
                "infrequentlyUsed": true,
                "keyToolTip": "If checked, Pose Verification algorithm will be used for selecting correct poses.",
                "name": "Use Pose Verification"
            },
            "voxelLength": {
                "infrequentlyUsed": false,
                "keyToolTip": "The length of the voxel.\nThe bigger the value is, the less precise the result tends to be.",
                "minimum": 0,
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            }
        }
    },
    "mmind::PPFInitPoseEasyMode": {
        "groupInfos": {
            "Output Settings": [
                "outputSize"
            ],
            "Result Visualization": [
                "showSampledModelCloud",
                "showSampledSceneCloud",
                "showOutputModelAndSceneCloud"
            ],
            "Speed Control": [
                "mainSpeedController",
                "secondarySpeedController"
            ]
        },
        "properties": {
            "mainSpeedController": {
                "decimals": 0,
                "keyToolTip": "The bigger the number is, the much faster the algorithm runs.\nHowever, the accuracy is decreasing as well. It has a bigger impact than \"Secondary Speed Controller\".",
                "maximum": 6,
                "minimum": 1,
                "name": "Main Speed Controller (1 ~ 6)",
                "singleStep": 1,
                "valueToolTip": "Integer [1,6]"
            },
            "outputSize": {
                "decimals": 0,
                "keyToolTip": "The expected number of detected poses in each point cloud.",
                "minimum": 1,
                "name": "Maximum Number of Detected Poses in Each Point Cloud",
                "singleStep": 1
            },
            "secondarySpeedController": {
                "decimals": 0,
                "keyToolTip": "The bigger the number is, the much faster the algorithm runs.\nHowever, the accuracy is decreasing as well. It has a smaller impact than \"Main Speed Controller\".",
                "maximum": 20,
                "minimum": 1,
                "name": "Secondary Speed Controller (1 ~ 20)",
                "singleStep": 1,
                "valueToolTip": "Integer [1,20]"
            },
            "showOutputModelAndSceneCloud": {
                "infrequentlyUsed": false,
                "keyToolTip": "Show the estimated poses of objects by rendering the transformed models and the scene point cloud.",
                "name": "Show Matching Results"
            },
            "showSampledModelCloud": {
                "infrequentlyUsed": true,
                "keyToolTip": "Show the sampled point cloud of the model.",
                "name": "Show Sampled Point Cloud of Model"
            },
            "showSampledSceneCloud": {
                "infrequentlyUsed": true,
                "keyToolTip": "Show the sampled point cloud of the scene.",
                "name": "Show Sampled Point Cloud of Scene"
            }
        }
    },
    "mmind::Procedure": {
        "icon_name": "Procedure",
        "keywords": "measure"
    },
    "mmind::ROIByFile": {
        "properties": {
            "height": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            },
            "roiFile": {
                "name": "Color Roi File",
                "subtype": 4,
                "valueToolTip": "Set 2D ROI"
            },
            "startX": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            },
            "startY": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            },
            "width": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::ROIByParam": {
        "properties": {
            "height": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            },
            "startX": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            },
            "startY": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            },
            "width": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::ROISettings": {
    },
    "mmind::RectCloudsFilter": {
        "properties": {
            "minRectangularity": {
                "keyToolTip": "The point clouds with a ratio of nonzero pixel in the bounding rectangle greater than this value can be considered as valid.",
                "maximum": 1,
                "minimum": 0,
                "valueToolTip": "( 0 ~ 1 )"
            }
        }
    },
    "mmind::RegionGrowingSeg": {
        "properties": {
            "curvatureThreshold": {
                "keyToolTip": "The curvature threshold of the point.",
                "maximum": 1,
                "minimum": 0
            },
            "searchNum": {
                "decimals": 0,
                "keyToolTip": "The number of neighbours.",
                "minimum": 0,
                "name": "Number of Neighbours",
                "singleStep": 1
            },
            "smoothnessThreshold": {
                "keyToolTip": "The angle threshold between the points normals.",
                "suffix": "°"
            }
        }
    },
    "mmind::Roi3DSetting": {
        "groupInfos": {
            "3D ROI Settings": [
                "roiBoundaryPath",
                "isOnlyRoi",
                "useRoiInFlange"
            ]
        },
        "properties": {
            "isOnlyRoi": {
                "keyToolTip": "Checked to apply 3D ROI.",
                "name": "Use 3D ROI"
            },
            "roiBoundaryPath": {
                "keyToolTip": "Setting tool of the region of interest (ROI).",
                "name": "3D ROI Name",
                "stringFileFilter": "*.json",
                "subtype": 4,
                "valueToolTip": "Set 3D ROI"
            },
            "useRoiInFlange": {
                "infrequentlyUsed": true,
                "keyToolTip": "When the system is in eye in hand mode, checked this option to transform the 3D ROI in the flange coordinate.",
                "name": "Use 3D ROI in Flange"
            }
        }
    },
    "mmind::SmartRayCamera": {
        "properties": {
            "profileNumbers": {
                "minimum": 0
            },
            "timeOut": {
                "minimum": 0
            },
            "transportResolution": {
                "minimum": 0,
                "singleStep": 0.0001
            }
        }
    },
    "mmind::SolidCloudsFilter": {
        "properties": {
            "ratio": {
                "keyToolTip": "The point clouds with a ratio of nonzero pixel in the contour greater than this value can be considered as solid.",
                "maximum": 1,
                "minimum": 0
            },
            "removeSloidCloud": {
                "name": "Remove Solid Clouds"
            }
        }
    },
    "mmind::StagDetector": {
        "properties": {
            "libraryNumber": {
                "name": "编码库"
            }
        }
    },
    "mmind::StatisticalOutlierFilter": {
        "properties": {
            "meanK": {
                "decimals": 0,
                "keyToolTip": "The number of nearest neighbors to use for mean distance estimation.",
                "minimum": 1,
                "singleStep": 1
            },
            "stddevMulThresh": {
                "keyToolTip": "The standard deviation multiplier for the distance threshold calculation.",
                "minimum": 0
            }
        }
    },
    "mmind::Step": {
        "properties": {
            "execFlags": {
                "name": "Execution Flags"
            },
            "parameterTuningLevel": {
                "name": "Parameters Tuning Level"
            }
        }
    },
    "mmind::Step2DBoundaryEstimation": {
        "groupInfos": {
            "Contour Settings": [
                "lineSize",
                "ContourRetrievalMode",
                "minContourSize",
                "layerIndex",
                "isGroupContours"
            ],
            "Morphological Operation Settings": [
                "dilateSize",
                "erodeSize"
            ]
        },
        "icon_name": "Estimate Point Cloud Edges by 2D Method",
        "keywords": "2D Boundary Estimation",
        "properties": {
            "ContourRetrievalMode": {
                "valueToolTip": "CV_RETR_EXTERNAL: Retrieves only the extreme outer contours.\nCV_RETR_LIST: \tRetrieves all of the contours without establishing any hierarchical relationships.\nCV_RETR_CCOMP: Retrieves all of the contours and organizes them into a two-level hierarchy. \nCV_RETR_TREE: Retrieves all of the contours and reconstructs a full hierarchy of nested contours.\n"
            },
            "dilateSize": {
                "decimals": 0,
                "minimum": 1,
                "name": "Dilation Kernel Size",
                "singleStep": 2,
                "suffix": "pixel"
            },
            "erodeSize": {
                "decimals": 0,
                "minimum": 1,
                "name": "Erosion Kernel Size",
                "singleStep": 2,
                "suffix": "pixel"
            },
            "isGroupContours": {
                "keyToolTip": "The contours belong to one cloud will be merged.",
                "name": "Merge Contours in Same Point Cloud"
            },
            "layerIndex": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "Set the required contour of the specified hierarchy levels.",
                "name": "Customized Hierarchy",
                "singleStep": 1,
                "valueToolTip": "The hierarchy increases from the outer layer to the inner layer.\nThe outermost layer hierarchy is 1.\nBesides, there are special values to be noticed: 0 means all the contours and -1 means the innermost layer."
            },
            "lineSize": {
                "decimals": 0,
                "keyToolTip": "The width of the contour lines when convert the 2D points to 3D points.",
                "minimum": 0,
                "name": "2D Line Width",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "minContourSize": {
                "decimals": 0,
                "keyToolTip": "For each detected contour, the number of points in it must be larger than this number.",
                "minimum": 0,
                "name": "Min Length",
                "singleStep": 10,
                "suffix": "pixel"
            }
        }
    },
    "mmind::Step2Dmask3D": {
        "icon_name": "Apply Masks to Point Cloud",
        "keywords": "2Dmask3D/2D Mask 3D",
        "subgroup": "Image - Point Cloud"
    },
    "mmind::Step2dCamera": {
        "groupInfos": {
            "Camera Settings": [
                "cameraType",
                "ip",
                "isAutoExposure",
                "exposureTime",
                "meanGrayValue",
                "isSoftwareTrigger",
                "timeoutMs"
            ],
            "Gray Value Range Settings": [
                "limitAverageGrayValueOfOutputImage",
                "minGrayValue",
                "maxGrayValue",
                "maxIterationNums"
            ],
            "Hdr Imaging": [
                "useHdrImaging",
                "useToneMapping",
                "exposureBegin",
                "exposureEnd",
                "exposureMultiple"
            ]
        },
        "icon_name": "Camera 2D",
        "infrequentlyUsed": true,
        "keywords": "measure",
        "properties": {
            "exposureBegin": {
                "maximum": 1000,
                "minimum": 0,
                "singleStep": 1,
                "suffix": "ms"
            },
            "exposureEnd": {
                "maximum": 1000,
                "minimum": 0,
                "singleStep": 1,
                "suffix": "ms"
            },
            "exposureMultiple": {
                "keyToolTip": "Each camera exposure will be multiplied by this multiple",
                "maximum": 99,
                "minimum": 1,
                "singleStep": 1
            },
            "exposureTime": {
                "maximum": 1000,
                "minimum": 0,
                "singleStep": 1,
                "suffix": "ms"
            },
            "isOutputGrayImage": {
                "name": "Output Gray Image"
            },
            "limitAverageGrayValueOfOutputImage": {
                "keyToolTip": "true:calc average gray value;\nfalse:don't calc average gray value.",
                "name": "Limit Average Gray Value of Output Image",
                "valueToolTip": "Select ture when autoexposure is used."
            },
            "maxGrayValue": {
                "keyToolTip": "max average gray value for rgb or gray image."
            },
            "maxIterationNums": {
                "keyToolTip": "max iteration number"
            },
            "maxRecaptureTime": {
                "keyToolTip": "When the camera captures images abnormally, multiple captures will be performed, and this value is the maximum number of recaptures.",
                "minimum": 1
            },
            "meanGrayValue": {
                "keyToolTip": "Expect mean gray value.",
                "maximum": 255,
                "minimum": 0,
                "singleStep": 1,
                "suffix": "pixel"
            },
            "minGrayValue": {
                "keyToolTip": "min average gray value for rgb or gray image."
            },
            "timeoutMs": {
                "maximum": 100000,
                "minimum": 100,
                "name": "Timeout",
                "singleStep": 1,
                "suffix": "ms"
            }
        },
        "subgroup": "Capture from Camera"
    },
    "mmind::Step2dCircleDetector": {
        "groupInfos": {
            "Settings of Circle Radius": [
                "minRadius",
                "maxRadius"
            ]
        },
        "icon_name": "Detect Circle Centers",
        "infrequentlyUsed": true,
        "keywords": "Find 2d Circle Center",
        "properties": {
            "maxRadius": {
                "keyToolTip": "The maximum circle radius.",
                "minimum": 0,
                "suffix": "pixel"
            },
            "minRadius": {
                "keyToolTip": "The minimum circle radius.",
                "minimum": 0,
                "suffix": "pixel"
            }
        },
        "subgroup": "Circle"
    },
    "mmind::Step2dShapeMatching": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "properties": {
            "angleExtent": {
                "maximum": 360,
                "suffix": "°"
            },
            "startAngle": {
                "maximum": 360,
                "suffix": "°"
            },
            "thresh": {
                "maximum": 1
            }
        }
    },
    "mmind::Step3DBoundaryEstimation": {
        "groupInfos": {
            "Boundary Estimation Settings": [
                "angleThreshold"
            ],
            "Neighbour Search Settings": [
                "nearestNeighbourSearchType",
                "searchNumber",
                "searchRadius"
            ]
        },
        "icon_name": "Estimate Point Cloud Edges by 3D Method",
        "keywords": "3D Boundary Estimation",
        "properties": {
            "angleThreshold": {
                "decimals": 0,
                "keyToolTip": "A point is identified as a boundary point when the angle between its normal and its neighbor's normal is larger than this value.",
                "maximum": 360,
                "minimum": 0,
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            },
            "nearestNeighbourSearchType": {
                "keyToolTip": "The method for searching neighbor points."
            },
            "searchNumber": {
                "decimals": 0,
                "keyToolTip": "The number of neighbor points which will be searched for estimating normal vectors of points.  ",
                "minimum": 1,
                "singleStep": 5
            },
            "searchRadius": {
                "infrequentlyUsed": false,
                "keyToolTip": "The radius for searching neighbor points which are used to estimate normal vectors of points.",
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            }
        }
    },
    "mmind::Step3Dmask2D": {
        "groupInfos": {
            "Morphological Operation": [
                "erodeSize",
                "closingOperateSize",
                "dilateSize"
            ],
            "Projection Operation": [
                "projectAlongObjZAxis",
                "scaleRatio"
            ]
        },
        "icon_name": "Project 3D Point Cloud to 2D Image",
        "keywords": "3Dmask2D/3D mask 2D",
        "properties": {
            "closingOperateSize": {
                "decimals": 0,
                "keyToolTip": "The kernel size for the closed operation after the Orthographic projection.\nFilling small holes in objects, connecting neighboring objects, smoothing their boundaries while not changing their area significantly.",
                "maximum": 999,
                "minimum": 3,
                "name": "Closing Operation Kernel Size",
                "singleStep": 2
            },
            "dilateSize": {
                "decimals": 0,
                "keyToolTip": "Increase the area of the object and join broken parts of an object.",
                "maximum": 999,
                "minimum": 3,
                "name": "Dilate Kernel Size",
                "singleStep": 2
            },
            "erodeSize": {
                "decimals": 0,
                "keyToolTip": "Remove small white noises and detach two connected objects.",
                "maximum": 999,
                "minimum": 3,
                "name": "Erode Kernel Size",
                "singleStep": 2
            },
            "imageType": {
                "keyToolTip": "Color image or depth image.",
                "valueToolTip": "Color: To generate a color mask image.\nDepth: To generate a depth mask image."
            },
            "projectAlongObjZAxis": {
                "name": "Project Along Object Z Axis"
            },
            "projectionType": {
                "valueToolTip": "OrthographicProjection: Each line that is originally parallel will be parallel after this transformation.\nPrespectiveProjection: From the perspective view."
            },
            "scaleRatio": {
                "infrequentlyUsed": true,
                "keyToolTip": "The scale of the orthographic projection.The default value is 1000, that is, one pixel is 1 mm.",
                "minimum": 0,
                "name": "Scale Ratio"
            },
            "useMorphOperation": {
                "keyToolTip": "Checked to apply the morphological operation to smooth the image.",
                "name": "Apply Morphological Operation"
            }
        },
        "subgroup": "Image - Point Cloud"
    },
    "mmind::StepAbstractDetector": {
        "groupInfos": {
            "Font Settings": [
                "manuallyFontScale",
                "fontScale"
            ]
        },
        "properties": {
            "confidenceThreshold": {
                "maximum": 1,
                "minimum": 0,
                "name": "Confidence Threshold (0 ~ 1.0)",
                "singleStep": 0.1
            },
            "fontScale": {
                "decimals": 1,
                "maximum": 10,
                "minimum": 0,
                "name": "Font Size (0 ~ 10)",
                "singleStep": 0.5
            },
            "manuallyFontScale": {
                "keyToolTip": "Selected to use customized font size.",
                "name": "Customized Font Size"
            },
            "maxInstancesPerImage": {
                "decimals": 0,
                "maximum": 2000,
                "minimum": 0,
                "name": "Max Detected Objects (0 ~ 2000)",
                "singleStep": 50
            },
            "sendResultSize": {
                "infrequentlyUsed": true,
                "keyToolTip": "If checked, send the number of results to Mech-Viz.",
                "name": "Notify Mech-Viz the Num of Detected Objects"
            }
        }
    },
    "mmind::StepAbstractUnpack": {
        "groupInfos": {
            "Dimension Settings": [
                "vectorLevel"
            ]
        },
        "properties": {
            "vectorLevel": {
                "decimals": 0,
                "keyToolTip": "If the operation layer is 0, the operation will performed on every elements in the lists.",
                "maximum": 14,
                "minimum": 0,
                "name": "Operation Layer",
                "singleStep": 1,
                "valueToolTip": "The innermost layer is 0."
            }
        }
    },
    "mmind::StepAcceptAll": {
        "icon_name": "Accept All",
        "infrequentlyUsed": true,
        "keywords": "measure",
        "subgroup": "Step IO"
    },
    "mmind::StepAddLabels": {
        "groupInfos": {
            "File Settings": [
                "labelFile"
            ]
        },
        "icon_name": "Add Labels to Poses",
        "keywords": "classify",
        "properties": {
            "labelFile": {
                "subtype": 4,
                "valueToolTip": "Set label\n\nOnly the first label in the file will be used."
            }
        }
    },
    "mmind::StepAdjustPoseRotation": {
        "groupInfos": {
            "Axis Settings": [
                "axisType"
            ],
            "Input Usage Settings": [
                "inputPoseUsage"
            ],
            "Method Selection": [
                "rectifyMethod"
            ],
            "Reference Direction": [
                "x",
                "y",
                "z"
            ]
        },
        "icon_name": "Point Axes of Poses to Given Direction",
        "keywords": "Rectify Poses/Pose Rectify/Bool",
        "properties": {
            "axisType": {
                "keyToolTip": "Choose the axis to be adjusted.",
                "name": "Axis to Be Adjusted"
            },
            "inputPoseUsage": {
                "valueToolTip": "All: Use all the reference poses to adjust the original poses one to one.\nFirstOnly: Only use the first reference pose to adjust the original poses."
            },
            "rectifyMethod": {
                "keyToolTip": "The adjustment method.",
                "name": "Rectification Method",
                "valueToolTip": "HARD_RECTIFY: Rotate the specified axis to the specified reference direction.\nRoTATION: Rotate the specified axis around the Z axis to the direction close to the specified reference direction. It is often used to grasp objects with symmetrical structure."
            },
            "symmetryAngle": {
                "decimals": 0,
                "keyToolTip": "Find the minimum rotation angle to the reference direction.",
                "minimum": 0,
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°",
                "valueToolTip": "If this value is 90 degrees, rotate the poses around the Z-axis 4 times with the step of 90 degrees. Select the result with the smallest angle between the specified axis of the reference pose and  the original pose."
            },
            "x": {
                "keyToolTip": "If the port of input reference is not activated, this value will be used.",
                "name": "X-axis"
            },
            "y": {
                "keyToolTip": "If the port of input reference is not activated, this value will be used.",
                "name": "Y-axis"
            },
            "z": {
                "keyToolTip": "If the port of input reference is not activated, this value will be used.",
                "name": "Z-axis"
            }
        },
        "subgroup": "Adjust Orientation"
    },
    "mmind::StepAdjustPosesToPointCloudSurface": {
        "groupInfos": {
            "Adjust Method Settings": [
                "adjustMethod",
                "x",
                "y",
                "z"
            ],
            "Coordinate System Settings": [
                "coordinateType"
            ],
            "Point Cloud Range Settings": [
                "extractPointCloudMethod",
                "percent",
                "minZ",
                "maxZ",
                "innerRadius",
                "outerRadius"
            ],
            "Usage Setting of Inputs": [
                "mappingType"
            ]
        },
        "icon_name": "Adjust Poses to Point Cloud Surface",
        "properties": {
            "adjustMethod": {
                "keyToolTip": "Move to Center: Move the input poses to the center of the extracted point clouds;\nMove a Certain Dis Along Z Axis: The input poses are moved along the Z-axis of\n the specified coordinate system for a certain distance (the projected length of\n the vector formed by the extracted point cloud center and the input pose on the\n Z-axis)."
            },
            "coordinateType": {
                "keyToolTip": "Use the object coordinate system or world coordinate system to adjust the poses."
            },
            "innerRadius": {
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "mappingType": {
                "keyToolTip": "One To One: There should be a one-to-one correspondence \nbetween the input point clouds and the intput poses. \nFirst To All: Adjust all poses using the first point cloud in the point cloud list."
            },
            "maxZ": {
                "keyToolTip": "The maximum distance threshold along Z-axis.",
                "name": "Max Z Value",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "minZ": {
                "keyToolTip": "The minimum distance threshold along Z-axis.",
                "name": "Min Z Value",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "outerRadius": {
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "percent": {
                "minimum": 0.0001
            }
        },
        "subgroup": "Adjust Translation"
    },
    "mmind::StepAutoTrajectory": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Cloud Mask Processing Settings": [
                "dilateSize",
                "erodeSize"
            ],
            "Trajectory Settings": [
                "minTrajLength",
                "depthDiffThre"
            ],
            "Visualization Settings": [
                "showTrajImagScale"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "depthDiffThre": {
                "keyToolTip": "If the depth difference is greater than depthDiffThre, it will be recognized as the track point.",
                "minimum": 0,
                "singleStep": 1
            },
            "dilateSize": {
                "keyToolTip": "Dilation kernel size.",
                "minimum": 1,
                "singleStep": 1
            },
            "erodeSize": {
                "keyToolTip": "Erosion kernel size.",
                "minimum": 1,
                "singleStep": 1
            },
            "minTrajLength": {
                "keyToolTip": "Minimum size of trajectory pixels.",
                "minimum": 0,
                "singleStep": 10,
                "suffix": "pixel"
            },
            "showTrajImagScale": {
                "keyToolTip": "Trajectory image scale ratio when show trajectory."
            }
        },
        "subgroup": "Generate Trajectory"
    },
    "mmind::StepBgSubtraction": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Post Processing Settings": [
                "useRefinement",
                "niters",
                "kernelSize",
                "areaThres"
            ],
            "Subtractor Properties": [
                "subtractorType"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "areaThres": {
                "infrequentlyUsed": true,
                "keyToolTip": "Contours, whose area is smaller than this threshold, will be considered as noise and will not appear in the foreground mask."
            },
            "kernelSize": {
                "infrequentlyUsed": true,
                "keyToolTip": "kernel size",
                "maximum": 999,
                "minimum": 3,
                "singleStep": 2,
                "valueToolTip": "should be non negative odd number"
            },
            "niters": {
                "infrequentlyUsed": true
            },
            "useRefinement": {
                "keyToolTip": "If checked, step will use morph operations and consideration on contours' size to make refinement on foreground masks.\nIf subtractorType is not Mog,then the default option is False."
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepBinaryClassifier": {
        "groupInfos": {
            "Threshold Settings": [
                "multiThreshold"
            ]
        },
        "icon_name": "Dichotomize Values by Threshold",
        "keywords": "classify/Classifier",
        "properties": {
            "multiThreshold": {
                "keyToolTip": "The thresholds of the input data. \nThe thresholds are connected by semicolon(';').",
                "name": "Thresholds of Input Data for Each Port"
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepBlobAnalysis": {
        "groupInfos": {
            "Detection Settings": [
                "polarity",
                "thresholdMethod",
                "binaryThreshold",
                "connectivity",
                "contourRetrievalMode"
            ],
            "Filtering Settings": [
                "filterByArea",
                "filterAreaByMaximum",
                "filterAreaByMinimum",
                "filterByPerimeter",
                "filterByPerimeterMaximum",
                "filterByPerimeterMinimum",
                "filterByPrincipalAxisAngle",
                "filterByPrincipalAxisAngleMaximum",
                "filterByPrincipalAxisAngleMinimum",
                "filterByRectangularity",
                "filterByRectangularityMaximum",
                "filterByRectangularityMinimum",
                "filterByRectAngle",
                "filterByRectAngleMaximum",
                "filterByRectAngleMinimum",
                "filterByCircularity",
                "filterByCircularityMaximum",
                "filterByCircularityMinimum"
            ],
            "Validation Settings": [
                "validateByArea",
                "validateByAreaMaximum",
                "validateByAreaMinimum",
                "validateByCircularity",
                "validateByCircularityMaximum",
                "validateByCircularityMinimum",
                "validateByPrincipalAxisAngle",
                "validateByPrincipalAxisAngleMaximum",
                "validateByPrincipalAxisAngleMinimum"
            ]
        },
		"icon_name": "Blob Analysis",
        "properties": {
            "binaryThreshold": {
                "name": "Binarization Threshold",
                "valueToolTip": "The grayscale threshold for image binarization."
            },
            "connectivity": {
                "name": "Connectivity",
                "singleStep": 0,
                "valueToolTip": "This parameter sets what neighboring pixels of a pixel are considered pixels in the same Blob as the pixel. If selecting \"Four-Connectivity\", each of the upper, lower, left, and right pixels is considered to be in the same Blob as the center pixel if the two have similar values. If selecting \"Eight-Connectivity\", each of the eight surrounding pixels is considered to be in the same Blob as the center pixel if the two have similar values."
            },
            "contourRetrievalMode": {
                "name": "Contour Retrieval Method",
                "valueToolTip": "This parameter sets which contours are considered as contours of the Blobs output. If selecting \"Outer\", only the outer contours will be considered. If selecting \"All\", all inner and outer contours will be considered."
            },
            "filterAreaByMaximum": {
                "name": "Area Upper Limit"
            },
            "filterAreaByMinimum": {
                "name": "Area Lower Limit"
            },
            "filterByArea": {
                "valueToolTip": "Filter by pixel-wise area."
            },
            "filterByCircularity": {
                "name": "Filter by Circularity",
                "valueToolTip": "The circularity values of the Blobs are obtained by dividing the areas of the Blobs by their minimum circumcircles' areas."
            },
            "filterByCircularityMaximum": {
                "name": "Circularity Upper Limit"
            },
            "filterByCircularityMinimum": {
                "name": "Circularity Lower Limit"
            },
            "filterByPerimeter": {
                "name": "Filter by Perimeter",
                "valueToolTip": "Filter by pixel-wise perimeter."
            },
            "filterByPerimeterMaximum": {
                "name": "Perimeter Upper Limit"
            },
            "filterByPerimeterMinimum": {
                "name": "Perimeter Lower Limit"
            },
            "filterByPrincipalAxisAngle": {
                "name": "Filter by Principal Axis Orientation",
                "valueToolTip": "The principal axis is the axis running through the direction along which a Blob has the longest projection span. The following angle is the angle between the principal axis and the positive X axis of the image."
            },
            "filterByPrincipalAxisAngleMaximum": {
                "name": "Principal Axis Angle Upper Limit"
            },
            "filterByPrincipalAxisAngleMinimum": {
                "name": "Principal Axis Angle Lower Limit"
            },
            "filterByRectAngle": {
                "name": "Filter by Min Circumscribed Rect Orientation",
                "valueToolTip": "The orientation of a rectangle is the orientation of the long side. The following angle is the angle between the orientation of the rectangle and the positive X axis of the image."
            },
            "filterByRectAngleMaximum": {
                "name": "Rect Angle Upper Limit"
            },
            "filterByRectAngleMinimum": {
                "name": "Rect Angle Lower Limit"
            },
            "filterByRectangularity": {
                "name": "Filter by Rectangularity",
                "valueToolTip": "The rectangularity values of the Blobs are obtained by dividing the areas of the Blobs by their minimum circumscribed rectangles' areas."
            },
            "filterByRectangularityMaximum": {
                "name": "Rectangularity Upper Limit"
            },
            "filterByRectangularityMinimum": {
                "name": "Rectangularity Lower Limit"
            },
            "polarity": {
                "name": "Blob Region Selection",
                "singleStep": 0,
                "valueToolTip": "This parameter specifies what type of pixel regions will be selected as Blobs. If \"Darker than Background\" is selected, adjacent pixels with similar pixel values darker than the background will be counted as Blob pixels. If \"Brighter than Background\" is selected, the opposite is true."
            },
            "sortCriteria": {
                "name": "Sorting Criteria",
                "singleStep": 0
            },
            "thresholdMethod": {
                "name": "Binarization Threshold Setting",
                "singleStep": 0,
                "valueToolTip": "This parameter specifies how to set the image binarization grayscale threshold. If selecting \"Auto\", the threshold will be calculated automatically. If selecting \"Custom\", the threshold needs to be set manually."
            },
            "validateByArea": {
                "name": "Validate by Area"
            },
            "validateByAreaMaximum": {
                "name": "Area Upper Limit"
            },
            "validateByAreaMinimum": {
                "name": "Area Lower Limit"
            },
            "validateByCircularity": {
                "name": "Validate by Circularit"
            },
            "validateByCircularityMaximum": {
                "name": "Circularity Upper Limit"
            },
            "validateByCircularityMinimum": {
                "name": "Circularity Lower Limit"
            },
            "validateByPrincipalAxisAngle": {
                "name": "Validate by Principal Axis Orientation"
            },
            "validateByPrincipalAxisAngleMaximum": {
                "name": "Principal Axis Angle Upper Limit"
            },
            "validateByPrincipalAxisAngleMinimum": {
                "name": "Principal Axis Angle Lower Limit"
            }
        }
    },
    "mmind::StepBoolListLogicalOperation": {
        "icon_name": "Boolean List Logical Operation",
        "infrequentlyUsed": true,
        "properties": {
            "portCount": {
                "maximum": 16,
                "minimum": 1
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepBoxDimensionsValidation": {
        "groupInfos": {
            "Box Dimension Information": [
                "boxDimensionErrorTolerance",
                "knownDimensionFilterType",
                "unknownDimensionFilterType",
                "boxDimensionInfoType"
            ],
            "Dimension Type": [
                "x",
                "y",
                "z"
            ]
        },
        "icon_name": "Validate Box Dimensions",
        "properties": {
            "boxDimensionErrorTolerance": {
                "keyToolTip": "Tolerance of the difference range between the maximum and minimum box size",
                "maximum": 1000,
                "minimum": 0,
                "storeUnit": 0,
                "subtype": 2
            },
            "x": {
                "infrequentlyUsed": true
            },
            "y": {
                "infrequentlyUsed": true
            },
            "z": {
                "infrequentlyUsed": true
            }
        }
    },
    "mmind::StepBoxMasksValidation": {
        "groupInfos": {
            "Missing Detection": [
                "allBoxesMustBeDetected",
                "sizeRatioOfRemainingBoxToStandardBox",
                "marginWidth",
                "showMarginMask"
            ],
            "Rectangularity Validation": [
                "rectangularityValidation",
                "minRectangularity",
                "filterType"
            ],
            "Size Consistency": [
                "allBoxesMustBeSameDimension",
                "boxDimensionErrorTolerance"
            ]
        },
        "icon_name": "Validate Box Masks",
        "properties": {
            "boxDimensionErrorTolerance": {
                "keyToolTip": "Tolerance of the difference range between the maximum and minimum box size",
                "maximum": 1000,
                "minimum": 0,
                "storeUnit": 0,
                "subtype": 2
            },
            "marginWidth": {
                "infrequentlyUsed": true,
                "keyToolTip": "The remaining mask gap width.",
                "maximum": 1000,
                "minimum": 1
            },
            "minRectangularity": {
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 1
            },
            "rectangularityValidation": {
                "keyToolTip": "The definition of rectangularity: the ratio of the mask area to the minimum circumscribed rectangle area of the mask."
            },
            "showMarginMask": {
                "infrequentlyUsed": true,
                "keyToolTip": "Display the remaining mask margin."
            },
            "sizeRatioOfRemainingBoxToStandardBox": {
                "decimals": 2,
                "keyToolTip": "The ratio threshold of the box size in the remaining mask to the standard box size.",
                "maximum": 1,
                "minimum": 0,
                "subtype": 1
            }
        }
    },
    "mmind::StepBridge": {
        "developingType": true,
        "infrequentlyUsed": true,
        "properties": {
            "maxTimeOutInSec": {
                "minimum": 1,
                "name": "Max Time Out [s]"
            },
            "portsList": {
                "subtype": 4,
                "valueToolTip": "Open editor"
            },
            "runLastProjectInCurrentThread": {
                "infrequentlyUsed": true
            }
        }
    },
    "mmind::StepCalcAbsoluteValues": {
        "deprecatedType": true,
        "icon_name": "Calc Absolute Values",
        "infrequentlyUsed": true
    },
    "mmind::StepCalcAngleBetweenSegments": {
        "icon_name": "measure_angle_between_line",
        "keywords": "measure",
        "outportMapping": "[[1,2]]",
        "subgroup": "2D Measuring"
    },
    "mmind::StepCalcAngleOfSpecifiedDir": {
        "icon_name": "Calc Included Angle Between Specified Axis of Poses",
        "infrequentlyUsed": true,
        "keywords": "Calc Angle Of Specified Dir",
        "properties": {
            "outPutAbsoluteValue": {
                "name": "Output Absolute Value",
                "valueToolTip": "If True is checked, the output value will be positive."
            },
            "rotAxis": {
                "keyToolTip": "The rotated axis of the first pose makes the specified axis of the first pose to reach the direction of the specified axis of the second pose. \nIf the axis of the first pose rotates clockwise, the included angle is postive.",
                "name": "Rotated Axis",
                "valueToolTip": "Can not be the same with the specified axis."
            },
            "specifiedAxis": {
                "keyToolTip": "Calculate the included angle between the specified axis of the two input poses."
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepCalcAngleWrtVector3d": {
        "icon_name": "Calc Angle Between Vector3D",
        "infrequentlyUsed": true,
        "subgroup": "Vector3D Related"
    },
    "mmind::StepCalcBoxSize": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Background Settings": [
                "backgroudFileName",
                "backgroundHeight",
                "backgroundHeightSource"
            ],
            "Calculation Settings": [
                "searchRadius"
            ],
            "Scene Information": [
                "plateThickness"
            ]
        },
        "infrequentlyUsed": true,
        "keywords": "Calc Box Size",
        "properties": {
            "backgroudFileName": {
                "keyToolTip": "The relative path of the backgound depth image in the project directory.",
                "stringFileFilter": "*png *jpg",
                "subtype": 2
            },
            "backgroundHeight": {
                "keyToolTip": "The background's height in robot coordinates, used to calculate box's Z length.",
                "singleStep": 0.005,
                "subtype": 2,
                "suffix": "m"
            },
            "backgroundHeightSource": {
                "keyToolTip": "Provide some information about the height of base in the robot coordinate.",
                "valueToolTip": "BackgroundFile: Generate the height from the background image.\nCustomizedHeight: Set a customized height."
            },
            "plateThickness": {
                "keyToolTip": "Thickness of the plate placed on background to form a flat area, such as roller belt. The plate is to be removed during robot execution.",
                "maximum": 0.5,
                "minimum": 0,
                "singleStep": 0.002,
                "subtype": 2,
                "suffix": "m"
            },
            "searchRadius": {
                "keyToolTip": "The search radius to determine box top vertices' depth in the depth image.",
                "minimum": 0,
                "subtype": 0,
                "suffix": "pixel"
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepCalcCalibBoardPose": {
        "developingType": true,
        "groupInfos": {
            "Blob Detector": [
                "minThreshold",
                "maxThreshold",
                "minCircleArea",
                "maxCircleArea",
                "minDist",
                "minCircularity",
                "minConvexity"
            ]
        },
        "subgroup": "Pose"
    },
    "mmind::StepCalcCloudCurvature": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "keywords": "Calc Cloud Curvature",
        "properties": {
            "measurement": {
                "name": "Output Type",
                "valueToolTip": "Mean: Take the average curvarture of the points in a point cloud to update the curvarture of the current point cloud.\nMax: Take the max curvarture of the points in a point cloud to update the curvarture of the current point cloud.\nPercentile: Sort the curvature of the points in a cloud, and take the curvature at that percentile.\nReCalculate: Recalculate the curvature for each point cloud."
            },
            "percentile": {
                "keyToolTip": "The location of the target curvature after sorting curvatures of the points in a point cloud.",
                "maximum": 100,
                "minimum": 0,
                "suffix": "th"
            }
        },
        "subgroup": "Normal / Curvature"
    },
    "mmind::StepCalcCloudFilterFlag": {
        "groupInfos": {
            "Cloud Preprocessing Settings": [
                "useOrthographicProj",
                "dilateSize",
                "erodeSize"
            ]
        },
        "icon_name": "Validate Point Clouds",
        "keywords": "Calc Cloud Filter Flag/Bool",
        "properties": {
            "_filterType": {
                "keyToolTip": "Project the point cloud to 2D plane and validate it.",
                "name": "Filter",
                "sub_object_types": [
                    "mmind::CircleCloudsFilter",
                    "mmind::CloudCapacityFilter",
                    "mmind::RectCloudsFilter",
                    "mmind::SolidCloudsFilter"
                ],
                "valueToolTip": "CircleCloudsFilter: Remove the point clouds whose projections are  non-circular.\nCloudCapcityFilter: Filter the point clouds based on the point cloud size.\nRectCloudsFilter: Remove the point clouds whose projections are non-rectangular .\nSolidCloudsFilter: Remove solid point clouds."
            },
            "dilateSize": {
                "decimals": 0,
                "infrequentlyUsed": false,
                "keyToolTip": "Increase the area of the object and join broken parts of an object.",
                "minimum": 1,
                "name": "Dilation Kernel Size",
                "singleStep": 2
            },
            "erodeSize": {
                "decimals": 0,
                "infrequentlyUsed": false,
                "keyToolTip": "Remove small white noises and detach two connected objects.",
                "minimum": 1,
                "name": "Erosion Kernel Size",
                "singleStep": 2
            },
            "useOrthographicProj": {
                "infrequentlyUsed": true,
                "keyToolTip": "After the projection, every line that was originally parallel will be parallel.",
                "name": "Use Orthographic Projection"
            }
        },
        "subgroup": "Validate and Get Clouds"
    },
    "mmind::StepCalcCloudSortCriteria": {
        "groupInfos": {
            "Reference Point": [
                "baseX",
                "baseY",
                "baseZ"
            ]
        },
        "icon_name": "Calc Specified Property of Point Clouds",
        "infrequentlyUsed": true,
        "keywords": "Calc Cloud Sort Criteria/Sort Point Cloud/Sort Cloud",
        "properties": {
            "axisForSorting": {
                "name": "Specified Property",
                "valueToolTip": "NONE: Output 0.\nX: Output the X value of the representative point.\nY: Output the Y value of the representative point.\nZ: Output the Z value of the representative point.\nDIS2BasePt: Output the distance between the representative point and the reference point."
            },
            "baseX": {
                "name": "X"
            },
            "baseY": {
                "name": "Y"
            },
            "baseZ": {
                "name": "Z"
            },
            "refPointForSorting": {
                "keyToolTip": "The point to represent the point cloud.",
                "name": "Representative Point",
                "valueToolTip": "CenterPoint: Take the center of the point clouds to represent the point cloud.\nBoundaryMinimun: Take the minimum values along x-axis, y-axis and z-axis to represent the point cloud.\nBoundaryMaximmun: Take the maximum values along x-axis, y-axis and z-axis to represent the point cloud."
            }
        }
    },
    "mmind::StepCalcCylinderPoses": {
        "icon_name": "Calc Cylinder Poses",
        "infrequentlyUsed": true,
        "subgroup": "Calc Pose"
    },
    "mmind::StepCalcDiagonalLength": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "subgroup": "3D Length / Distance"
    },
    "mmind::StepCalcDiameterAndThickness": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Hough Circles Parameters": [
                "dp",
                "edgeGradientThres",
                "accumulatorThres",
                "minRadius",
                "maxRadius"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "accumulatorThres": {
                "minimum": 0.0001
            },
            "closingOperateSize": {
                "keyToolTip": "The kernel size of closing operation.",
                "maximum": 999,
                "minimum": 3,
                "singleStep": 2
            },
            "dp": {
                "infrequentlyUsed": true,
                "minimum": 0.0001
            },
            "edgeGradientThres": {
                "infrequentlyUsed": true,
                "minimum": 0.0001
            },
            "maxRadius": {
                "minimum": 0
            },
            "minRadius": {
                "minimum": 0
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepCalcDisparitySGBM": {
        "developingType": true,
        "groupInfos": {
            "Match Settings": [
                "matchMode",
                "rightMatcherType",
                "minDepth",
                "maxDepth",
                "SADWindowSize",
                "preFilterCap",
                "uniquenessRatio",
                "speckleWindowSize",
                "speckleRange",
                "P1",
                "P2",
                "useGray"
            ],
            "Occlusion Check": [
                "useOcclutionFilter",
                "occKernelSize",
                "occLRCheckDispThres",
                "occInterpolation"
            ],
            "Post-processing Settings": [
                "postProcessingMode",
                "lambda",
                "sigma",
                "depthRadius",
                "wlsCheckMode",
                "windowSize",
                "nonZeroCountRatio",
                "sigmaXYRatio"
            ],
            "Visual & Debug": [
                "visualScale",
                "showOcclusionCheck",
                "showOriginLRImgs",
                "showPreprocessEffects",
                "showWlsEffects",
                "showSpeckleRemoval",
                "showWlsComponetBasedRemoval",
                "visualSpeckleAreaThres"
            ]
        },
        "keywords": "calculate/depth",
        "properties": {
            "P1": {
                "infrequentlyUsed": true
            },
            "P2": {
                "infrequentlyUsed": true
            },
            "SADWindowSize": {
                "infrequentlyUsed": true,
                "keyToolTip": "The window size for initial cost calculation, which should be positive and odd.",
                "suffix": "pixel",
                "valueToolTip": "Recommend: 3 <= windowSize <= 11"
            },
            "depthRadius": {
                "infrequentlyUsed": true
            },
            "lambda": {
                "keyToolTip": "Larger values force filtered disparity map edges to adhere more to source image edges.",
                "name": "Edge Reservation Coefficient (8000 ~ 20000)",
                "valueToolTip": "Recommend: 8000 <= lambda <= 20000."
            },
            "matchMode": {
                "valueToolTip": "Default setting is recommended."
            },
            "maxDepth": {
                "keyToolTip": "The maximum depth value in interest.",
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "minDepth": {
                "keyToolTip": "The minimum depth value in interest.",
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "nonZeroCountRatio": {
                "infrequentlyUsed": true
            },
            "occKernelSize": {
                "infrequentlyUsed": true,
                "maximum": 999,
                "minimum": 3,
                "singleStep": 2,
                "valueToolTip": "Default setting is recommanded."
            },
            "occLRCheckDispThres": {
                "infrequentlyUsed": true
            },
            "postProcessingMode": {
                "name": "Post-processing Mode"
            },
            "preFilterCap": {
                "infrequentlyUsed": true,
                "keyToolTip": "Truncation value for the prefiltered image pixels. It's related to Birchfield-Tomasi pixel cost function.",
                "name": "Upper Threshold of Gradient in Pre-filter  (15 ~ 63)",
                "suffix": "pixel",
                "valueToolTip": "Recommend: 15 <= preFilterCap <= 63."
            },
            "rightMatcherType": {
                "infrequentlyUsed": true
            },
            "showOcclusionCheck": {
                "infrequentlyUsed": true
            },
            "showOriginLRImgs": {
                "infrequentlyUsed": true
            },
            "showPreprocessEffects": {
                "infrequentlyUsed": true
            },
            "showSpeckleRemoval": {
                "infrequentlyUsed": true
            },
            "showWlsComponetBasedRemoval": {
                "infrequentlyUsed": true
            },
            "showWlsEffects": {
                "infrequentlyUsed": true
            },
            "sigma": {
                "keyToolTip": "Large values can lead to disparity leakage through low-contrast edges. \nSmall values can make the filter too sensitive to noise and textures in the source image.",
                "maximum": 10,
                "name": "Color Image Blur Coefficient (0.8 ~ 2)",
                "singleStep": 0.1,
                "valueToolTip": "Recommend: 0.8 <= sigma <= 2."
            },
            "sigmaXYRatio": {
                "infrequentlyUsed": true
            },
            "speckleRange": {
                "infrequentlyUsed": true,
                "keyToolTip": "Maximum disparity variation within each connected component.\nThis value should be positive when speckle filtering is in use.",
                "name": "Max Disparity Value Difference of Neighbor Pixels in Same Speckle",
                "suffix": "pixel"
            },
            "speckleWindowSize": {
                "keyToolTip": "Maximum size of smooth disparity regions to consider as noise speckles. Set it to 0 to disable speckle filtering.\nThis value is positively related to camera resolution. Need to set a proper value to see the filtering effects.",
                "name": "Max Speckle Area Size",
                "suffix": "pixel"
            },
            "uniquenessRatio": {
                "infrequentlyUsed": true
            },
            "useGray": {
                "infrequentlyUsed": true,
                "keyToolTip": "True（default）: left & right images will be convert to 1 channel and match as as gray image.\nFalse: match with 3 channels."
            },
            "visualScale": {
                "infrequentlyUsed": true
            },
            "visualSpeckleAreaThres": {
                "infrequentlyUsed": true
            },
            "windowSize": {
                "infrequentlyUsed": true
            },
            "wlsCheckMode": {
                "infrequentlyUsed": true,
                "name": "WLS Validation Mode"
            }
        },
        "subgroup": "Supplement"
    },
    "mmind::StepCalcDistAlongAxisWithinMask": {
        "groupInfos": {
            "Axis Settings": [
                "axisType"
            ]
        },
        "icon_name": "Calc Mask's Span on Given Line",
        "infrequentlyUsed": true,
        "keywords": "Calc Dist Along Axis Within Mask",
        "properties": {
            "axisType": {
                "keyToolTip": "The specified axis of the input poses decides the direction of the line."
            }
        },
        "subgroup": "3D Length / Distance"
    },
    "mmind::StepCalcDistanceBetweenSegments": {
        "icon_name": "measure_line_to_line",
        "keywords": "measure",
        "outportMapping": "[[1,2]]",
        "subgroup": "2D Measuring"
    },
    "mmind::StepCalcDistanceCircleToCircle": {
        "icon_name": "measure_circle_to_circle",
        "keywords": "measure",
        "outportMapping": "[[1,2]]",
        "subgroup": "2D Measuring"
    },
    "mmind::StepCalcDistanceCircleToSegment": {
        "icon_name": "measure_circle_to_line",
        "keywords": "measure",
        "outportMapping": "[[1,2]]",
        "subgroup": "2D Measuring"
    },
    "mmind::StepCalcDistancePointToCircle": {
        "icon_name": "measure_point_to_circle",
        "keywords": "measure",
        "outportMapping": "[[1,2]]",
        "subgroup": "2D Measuring"
    },
    "mmind::StepCalcDistancePointToIntersectionLine": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "keywords": "Calc Distance Point To Intersection Line",
        "properties": {
            "difTheoreticalAndActualValue": {
                "keyToolTip": "The difference between the theoretical value and the actual value(calculated value).",
                "subtype": 2,
                "suffix": "m"
            },
            "planeAOffsetDistance": {
                "keyToolTip": "offset of plane A;",
                "subtype": 2,
                "suffix": "m"
            },
            "planeBOffsetDistance": {
                "keyToolTip": "offset of plane B;",
                "subtype": 2,
                "suffix": "m"
            },
            "useMaxValue": {
                "keyToolTip": "true: max value;\nfalse: average value;"
            }
        },
        "subgroup": "3D Length / Distance"
    },
    "mmind::StepCalcDistancePointToPlane": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Plane Fitting Settings": [
                "distanceThreshold",
                "maxIterations"
            ]
        },
        "icon_name": "Calc Distance from 3D Points to Plane",
        "infrequentlyUsed": true,
        "keywords": "Calc Distance Point To Plane/measure",
        "properties": {
            "distanceThreshold": {
                "infrequentlyUsed": true,
                "keyToolTip": "The distance threshold used to fit a plane.\nThe larger the value, the rougher the plane.",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "maxIterations": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "Number of iterations of the fitted plane.",
                "minimum": 0,
                "singleStep": 1
            },
            "outputValueType": {
                "valueToolTip": "MaxValue: Output the max value of the distances\nAverageValue: Output the average value of the distances"
            }
        },
        "subgroup": "3D Length / Distance"
    },
    "mmind::StepCalcDistancePointToPoint": {
        "icon_name": "measure_point_to_point",
        "keywords": "measure",
        "outportMapping": "[[1,2]]",
        "subgroup": "2D Measuring"
    },
    "mmind::StepCalcDistancePointToSegment": {
        "icon_name": "measure_point_to_line",
        "keywords": "measure",
        "outportMapping": "[[1,2]]",
        "subgroup": "2D Measuring"
    },
    "mmind::StepCalcDistanceToBasePose": {
        "groupInfos": {
            "Reference Pose": [
                "baseX",
                "baseY",
                "baseZ"
            ]
        },
        "icon_name": "Calc Distance to Reference Pose",
        "keywords": "Calc Distance To BasePose",
        "properties": {
            "baseX": {
                "name": "X",
                "valueToolTip": "This value is used when the reference pose port is not activated."
            },
            "baseY": {
                "name": "Y",
                "valueToolTip": "This value is used when the reference pose port is not activated."
            },
            "baseZ": {
                "name": "Z",
                "valueToolTip": "This value is used when the reference pose port is not activated."
            },
            "distanceType": {
                "keyToolTip": "NONE: Output an empty list.\nDis2ReferencePose: Calculate the distance between input pose and reference pose in three-dimensional space.\nDis2ReferencePoseOnXYPlane: Calculate the distance between input pose and reference pose  on the XY plane."
            }
        },
        "subgroup": "3D Length / Distance"
    },
    "mmind::StepCalcEdgePointsNormal": {
        "icon_name": "Calc Edge Points Normal",
        "infrequentlyUsed": true,
        "properties": {
            "knn": {
                "minimum": 1
            }
        },
        "subgroup": "Normal / Curvature"
    },
    "mmind::StepCalcFlatnessError": {
        "icon_name": "Calc Flatness Error",
        "keywords": "measure",
        "properties": {
            "inlierDistanceThreshold": {
                "decimals": 4,
                "maximum": 10,
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2
            },
            "maxIterations": {
                "decimals": 0,
                "maximum": 1000,
                "minimum": 0,
                "singleStep": 1
            }
        },
        "subgroup": "Global Dimensioning and Tolerancing"
    },
    "mmind::StepCalcHistogram": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "binSize": [
                "chan1BinSize",
                "chan2BinSize",
                "chan3BinSize"
            ],
            "range": [
                "chan1Range",
                "chan2Range",
                "chan3Range"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "chan1BinSize": {
                "keyToolTip": "Array of histogram sizes of channel1"
            },
            "chan1Range": {
                "keyToolTip": "Value range of channel 1."
            },
            "chan2BinSize": {
                "keyToolTip": "Array of histogram sizes of channel2."
            },
            "chan2Range": {
                "keyToolTip": "Value range of channel 2."
            },
            "chan3BinSize": {
                "keyToolTip": "Array of histogram sizes of channel3."
            },
            "chan3Range": {
                "keyToolTip": "Value range of channel 3."
            },
            "histogramMatType": {
                "keyToolTip": "Select channels."
            }
        }
    },
    "mmind::StepCalcLengthAlongAxis": {
        "groupInfos": {
            "Reference Direction": [
                "axisType"
            ]
        },
        "icon_name": "Calc Length Along Axis",
        "infrequentlyUsed": true,
        "properties": {
            "axisType": {
                "keyToolTip": "Length will be calculated along the direction of reference axis."
            }
        },
        "subgroup": "3D Length / Distance"
    },
    "mmind::StepCalcLengthOfVector3d": {
        "icon_name": "Calc Length of Vector3D",
        "infrequentlyUsed": true,
        "subgroup": "Vector3D Related"
    },
    "mmind::StepCalcMaskArea": {
        "groupInfos": {
            "Area Calculation Settings": [
                "areaType"
            ]
        },
        "icon_name": "Calc Areas of Masks",
        "properties": {
            "areaType": {
                "name": "Calc Method",
                "valueToolTip": "FilledContourArea:Retrieve the contour of nonzero area and calculate the area within the contour. \nNonZeroPixelArea: Calculate the area with nonzero pixel."
            }
        },
        "subgroup": "Calc Mask Property"
    },
    "mmind::StepCalcMaskDistance": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Custom Settings": [
                "distanceMode",
                "maskAreaMinThres",
                "pixelDistanceThres"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "distanceMode": {
                "keyToolTip": "Modes for calculating distances"
            },
            "maskAreaMinThres": {
                "keyToolTip": "minimum area threshold of mask",
                "minimum": 1
            },
            "pixelDistanceThres": {
                "keyToolTip": "Pixel distance between masks"
            }
        },
        "subgroup": "Calc Mask Property"
    },
    "mmind::StepCalcMeanGrayValue": {
        "icon_name": "Calc Mean Gray Value",
        "subgroup": "Others"
    },
    "mmind::StepCalcNonzeroCenter": {
        "icon_name": "Calc Center Point of Non-zero Areas",
        "infrequentlyUsed": true,
        "keywords": "Calc Nonzero Center",
        "properties": {
            "centerType": {
                "valueToolTip": "MassCenter: Center of non-zero value in the area.\nBoundingBoxCenter: Center of bouding box of the area."
            }
        },
        "subgroup": "Calc Mask Property"
    },
    "mmind::StepCalcNormalizedVector3d": {
        "icon_name": "Calc Normalized Vector3D",
        "infrequentlyUsed": true,
        "subgroup": "Vector3D Related"
    },
    "mmind::StepCalcParallelismError": {
        "icon_name": "Calc Parallelism Error",
        "keywords": "measure",
        "properties": {
            "inlierDistanceThreshold": {
                "minimum": 0,
                "storeUnit": 2,
                "subtype": 2
            },
            "maxIterations": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            }
        },
        "subgroup": "Global Dimensioning and Tolerancing"
    },
    "mmind::StepCalcPixelSizeAtSpecifiedHeight": {
        "icon_name": "Calc Pixel Size at Specified Height",
        "infrequentlyUsed": true
    },
    "mmind::StepCalcPlaneWidth": {
        "developingType": true
    },
    "mmind::StepCalcPoseFilterFlag": {
        "groupInfos": {
            "Reference Direction": [
                "dirX",
                "dirY",
                "dirZ"
            ]
        },
        "icon_name": "Validate Poses by Included Angle to Reference Direction",
        "keywords": "Calc Pose Filter Flag/Bool",
        "properties": {
            "AxisType": {
                "name": "Pose's Selected Axis"
            },
            "angleThreshold": {
                "decimals": 0,
                "keyToolTip": "If the angle diffrence between z-axis and the reference direction is bigger than the threshold, the pose will be considered as invalid.",
                "maximum": 180,
                "minimum": 0,
                "name": "Max Angle Difference (0 ~ 180)",
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            },
            "dirX": {
                "name": "X"
            },
            "dirY": {
                "name": "Y"
            },
            "dirZ": {
                "name": "Z"
            },
            "filterOutAllPoses": {
                "infrequentlyUsed": true,
                "keyToolTip": "If there exists a invalid poses in the input list, output an empty list.",
                "name": "Output Empty List if Containing Invalid Poses"
            }
        },
        "subgroup": "Validate"
    },
    "mmind::StepCalcPoseFromHeatMap": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Connected Area Search Settings": [
                "lowerThre",
                "probabilityThre",
                "poiPrecision",
                "probabilityStep",
                "convexityThre",
                "bboxLToWRatioThre",
                "LRRAngleStep",
                "LRRTanslationStep",
                "treatContourAsConcaveIfHasHole",
                "thresholdUsage"
            ],
            "Connected Area Settings": [
                "areaSizeLowerBound",
                "areaSizeUpperBound"
            ],
            "Gripper Settings": [
                "gripperType"
            ],
            "Parallel Jaw Related Settings": [
                "secondToMaxRatio",
                "useApproximatedTheta",
                "rotationClassNum"
            ],
            "Pick Candidate Settings": [
                "extractMethod"
            ],
            "Pose Extraction Settings": [
                "topK",
                "distThre"
            ],
            "Score Settings": [
                "scoreType"
            ],
            "Visualization Settings": [
                "showContourThre",
                "showConvexity",
                "showArea",
                "showPointConfidence",
                "showCupDiameters",
                "fontScale"
            ]
        },
        "infrequentlyUsed": true,
        "keywords": "Calc Pose From Heat Map",
        "properties": {
            "LRRAngleStep": {
                "infrequentlyUsed": true,
                "keyToolTip": "The rotation search step when searching for the largest rotated rectangle (LRR) within a contour.",
                "maximum": 45,
                "minimum": 1,
                "name": "Angle Step for Searching LRR",
                "suffix": "°"
            },
            "LRRTanslationStep": {
                "infrequentlyUsed": true,
                "keyToolTip": "The translation search step when searching for the largest rotated rectangle  (LRR) within a contour.",
                "maximum": 999,
                "minimum": 1,
                "name": "Translation Step for Searching LRR",
                "suffix": "pixel"
            },
            "areaSizeLowerBound": {
                "infrequentlyUsed": true,
                "maximum": 100000,
                "minimum": 1,
                "name": "Min Size of Areas",
                "singleStep": 1,
                "suffix": "pixel",
                "valueToolTip": "This value should be a positive nbumber to make sure the contour have a valid size."
            },
            "areaSizeUpperBound": {
                "infrequentlyUsed": true,
                "maximum": 100000,
                "minimum": 1,
                "name": "Max Size of Areas",
                "singleStep": 1,
                "suffix": "pixel",
                "valueToolTip": "This value should be larger than the lower bound value such that size contraint range is valid. \nWhen this value is equal to lower bound value, the connected component will only be constrained with the lower bound."
            },
            "bboxLToWRatioThre": {
                "decimals": 2,
                "infrequentlyUsed": true,
                "keyToolTip": "Threshold of the longer edge to shorter edge ratio of contour's bounding box. When a contour is concave, if its bboxLToWRatio is greater than this threshold, center of largest rotated rectangle will be grasp point, if its bboxLToWRatio is smaller than this threshold, center of incircle (POI) will be grasp point.",
                "maximum": 99,
                "minimum": 1,
                "name": "Aspect Ratio Threshold of Bounding Boxes"
            },
            "calcDepthMethod": {
                "infrequentlyUsed": true,
                "name": "Method to Calc Z of Poses"
            },
            "convexityThre": {
                "decimals": 2,
                "infrequentlyUsed": true,
                "keyToolTip": "When the convexity of a heat area is greater than this value, the centroid will be the grasp point, otherwise the center of incircle (POI) or center of largest rotated rectangle (LLR) withing the contour will be used as grasp point (depending on the longer edge to shorter edge ratio of contour's bounding box).",
                "maximum": 1,
                "minimum": 0,
                "name": "Convextiy Threshold of Areas (0 ~ 1)"
            },
            "depthSearchRadius": {
                "infrequentlyUsed": true,
                "keyToolTip": "The search radius to determine heat points' depth in the depth image.",
                "maximum": 1000,
                "minimum": 1,
                "name": "Radius to Calc Z of Poses",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "distThre": {
                "keyToolTip": "Minimum distance threshold when extracting heat points from heat map.",
                "suffix": "pixel"
            },
            "extractMethod": {
                "name": "Extraction Method of Pick Candidates ",
                "valueToolTip": "topK: Output the first K pick points.\nareaCenter:"
            },
            "fontScale": {
                "decimals": 1,
                "infrequentlyUsed": true,
                "maximum": 2,
                "minimum": 0.5,
                "name": "Font Scale (0.5 ~ 2.0)"
            },
            "gripperType": {
                "name": "Gripper Type",
                "valueToolTip": "SuctionCup: The suction cup.\nParallelJaw:  The parallel jaw."
            },
            "histPrecision": {
                "infrequentlyUsed": true,
                "keyToolTip": "The histogram precision when calculating heat point's depth using median value.",
                "maximum": 1000,
                "minimum": 0,
                "singleStep": 0.02
            },
            "lowerThre": {
                "decimals": 2,
                "keyToolTip": "The minimum allowed probability of heat points.",
                "maximum": 1,
                "minimum": 0,
                "name": "Lowest Probability to Generate Areas (0 ~ 1)",
                "singleStep": 0.05
            },
            "poiPrecision": {
                "infrequentlyUsed": true,
                "keyToolTip": "The precision of pole of inaccessibility.",
                "maximum": 999,
                "minimum": 1,
                "name": "Precision to Calc Poses (POI)",
                "suffix": "pixel"
            },
            "probabilityStep": {
                "decimals": 2,
                "infrequentlyUsed": true,
                "keyToolTip": "When no heat area are generated using the set probability threshold, threshold will be decreased by this step value, until the threshold reaches the lower threshold.",
                "maximum": 1,
                "minimum": 0.01,
                "name": "Decreasing Step of Probability Threshold (0 ~ 1)"
            },
            "probabilityThre": {
                "decimals": 2,
                "keyToolTip": "The start threshold to get connected high probability areas.",
                "maximum": 1,
                "minimum": 0,
                "name": "Probability Threshold to Generate Areas (0 ~ 1)",
                "singleStep": 0.05
            },
            "rotationClassNum": {
                "keyToolTip": "The number of classes of theta in the DL model."
            },
            "showArea": {
                "infrequentlyUsed": true
            },
            "showContourThre": {
                "infrequentlyUsed": true,
                "name": "Show Corresponding Thresholds for Contours"
            },
            "showConvexity": {
                "infrequentlyUsed": true
            },
            "showCupDiameters": {
                "infrequentlyUsed": true,
                "name": "Show Diameters for Suction Cups"
            },
            "showPointConfidence": {
                "infrequentlyUsed": true
            },
            "thresholdUsage": {
                "valueToolTip": "Multiple Thresholds: Use thresholds within the set probability range to get connected  areas. Extracts more poses from heat map, but has slower speed."
            },
            "topK": {
                "decimals": 1,
                "keyToolTip": "Top K poses with higher probability will be extracted."
            },
            "treatContourAsConcaveIfHasHole": {
                "infrequentlyUsed": true
            },
            "useContourApproximateDir": {
                "infrequentlyUsed": true,
                "keyToolTip": "Checked to calculate PCA of extracted contour, and the direction of the first eigenvector will be used as the X axis of output pose.",
                "name": "Use Principal Direction as X-axis of Poses"
            }
        },
        "subgroup": "Novel Objects Picking"
    },
    "mmind::StepCalcPosesAndSizes": {
        "groupInfos": {
            "Advanced Calculation Settings": [
                "useMaxDistAlongSpecifiedDir"
            ],
            "Box Pose Calculation Settings": [
                "calcBoxZLen",
                "backgroundHeight"
            ],
            "Pose Calculation Settings": [
                "translationType",
                "rotationType",
                "useBestAlignedRect",
                "alignSearchRadius"
            ],
            "Reference Direction": [
                "x",
                "y",
                "z"
            ]
        },
        "icon_name": "Calc Poses and Dimensions from Planar Point Clouds",
        "keywords": "Calculate Poses and Sizes from Plane Point Clouds/Calc Poses And Sizes/Calc Sizes",
        "properties": {
            "alignSearchRadius": {
                "minimum": 1,
                "singleStep": 1,
                "suffix": "pixel"
            },
            "backgroundHeight": {
                "keyToolTip": "The background's height in robot coordinates, used to calculate box's z length.",
                "name": "Fixed Height for Box Bottom",
                "singleStep": 0.005,
                "subtype": 2,
                "suffix": "m"
            },
            "calcBoxZLen": {
                "keyToolTip": "Select only when it is necessary to calculate box's z length.",
                "name": "Calc Boxes' Height"
            },
            "rotationType": {
                "keyToolTip": "Using bounding rectangle orientation or point cloud PCA orientation as pose rotaion.",
                "name": "Method to Calc Pose Orientation"
            },
            "translationType": {
                "keyToolTip": "Using bounding rectangle centroid or point cloud centroid as pose translation.",
                "name": "Method to Calc Pose Center"
            },
            "useBestAlignedRect": {
                "valueToolTip": "The bounding rectangle aligned with the outline of the object as much as possible."
            },
            "useMaxDistAlongSpecifiedDir": {
                "infrequentlyUsed": true,
                "name": "Use Max Dist Along Reference Direction"
            },
            "x": {
                "infrequentlyUsed": true
            },
            "y": {
                "infrequentlyUsed": true
            },
            "z": {
                "infrequentlyUsed": true
            }
        },
        "subgroup": "Calc Pose"
    },
    "mmind::StepCalcPositionTolerance": {
        "infrequentlyUsed": true,
        "properties": {
            "savePath": {
                "subtype": 1
            },
            "stdDiameter": {
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "stdDis2Center": {
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "tolerance": {
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepCalcProfile": {
        "developingType": true
    },
    "mmind::StepCalcProfileBySampling": {
        "developingType": true
    },
    "mmind::StepCalcProjectionLengthAlongRefDir": {
        "groupInfos": {
            "Reference Direction": [
                "dirX",
                "dirY",
                "dirZ"
            ]
        },
        "icon_name": "Calc Projection Length Along Reference Direction",
        "infrequentlyUsed": true,
        "properties": {
            "dirX": {
                "name": "X"
            },
            "dirY": {
                "name": "Y"
            },
            "dirZ": {
                "name": "Z"
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepCalcRect2dPose": {
        "icon_name": "Calc Rect 2D Pose",
        "infrequentlyUsed": true,
        "subgroup": "Calc Pose"
    },
    "mmind::StepCalcRect3dPose": {
        "groupInfos": {
            "Output Pose Strategy": [
                "outputNumberType"
            ],
            "Pose Calculation Settings": [
                "searchRadius"
            ],
            "Sucker Properties": [
                "suckerLengthX",
                "suckerLengthY",
                "suckerMaskOtherRectRatio"
            ]
        },
        "icon_name": "Calc Poses and Dimensions of Rectangles",
        "keywords": "Calc Poses and Sizes of Rectangles/Calc Rect 3d Pose/Calc 3D",
        "properties": {
            "inputType": {
                "infrequentlyUsed": true,
                "keyToolTip": "Change the input port types.",
                "valueToolTip": "Depth: Take the depth image of boxes as the input.\nVertexAndSize: Take the vertices and dimensions of the boxes as the input."
            },
            "outputNumberType": {
                "keyToolTip": "The detected information of one box may not be unique.",
                "name": "Poses Number",
                "valueToolTip": "Multiple: Output all poses of one box.\nOne: Output one pose of one box."
            },
            "searchRadius": {
                "infrequentlyUsed": true,
                "keyToolTip": "The raidus to search depth given a position in image.",
                "minimum": 0,
                "name": "Radius to Calc Poses' Z Value",
                "suffix": "pixel"
            },
            "suckerLengthX": {
                "keyToolTip": "Sucker coverd area's x dimenstion. Used when sucker is biger than target box, to avoid picking adjacent boxes.",
                "minimum": 0,
                "name": "Sucker Length along X Axis",
                "subtype": 2,
                "suffix": "m"
            },
            "suckerLengthY": {
                "keyToolTip": "Sucker coverd area's y dimenstion. Used when sucker is biger than target box, to avoid picking adjacent boxes.",
                "minimum": 0,
                "name": "Sucker Length along Y Axis",
                "subtype": 2,
                "suffix": "m"
            },
            "suckerMaskOtherRectRatio": {
                "infrequentlyUsed": true,
                "keyToolTip": "If the ratio of the overlap area of the suction cup to the other box and the box area is greater than this threshold, it is considered that other box will be taken.",
                "minimum": 0
            }
        },
        "subgroup": "Calc Pose"
    },
    "mmind::StepCalcSideApproximateMidpoint": {
        "developingType": true,
        "icon_name": "Calc Midpoint of Specified Side of Rectangle",
        "keywords": "Calc Side Approximate Midpoint",
        "properties": {
            "pointZInCamera": {
                "keyToolTip": "The Z value of the midpoint in the camera coordinate.",
                "name": "Z Value of Midpoint",
                "subtype": 2
            },
            "specifiedSide": {
                "keyToolTip": "Calculate the midpoint of the specified side."
            }
        },
        "subgroup": "Adjust Trajectory"
    },
    "mmind::StepCalcSizeInMat": {
        "groupInfos": {
            "Correspondence Settings": [
                "correspondenceType"
            ]
        },
        "icon_name": "From Actual Dimensions to Dimensions in Pixels",
        "properties": {
            "correspondenceType": {
                "keyToolTip": "\"OneActualSizeWithAllPointCloud\": Each element in the input list of dimensions correspond for each actual point clouds one-to-one.\n\"OneActualSizeWithOnePointCloud\" : First element in the input list of dimensions for all point clouds."
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepCalcTransformFromTwoPointSet": {
        "icon_name": "default"
    },
    "mmind::StepCalibDirectOfLineScanCamera": {
    },
    "mmind::StepCaliperBaseClass": {
        "properties": {
            "edgeSelection": {
                "keyToolTip": "This parameter sets which detected edge point should be selected as the edge point for fitting in a single edge detection frame."
            },
            "edgeDetectionFrameHalfWidth": {
                "keyToolTip": "Half the width of the edge detection frames. When the edge is not clear, the value can be increased appropriately. When the edge is clear, the value can be decreased appropriately.",
                "maximum": 1000,
                "minimum": 0
            },
            "edgePolarityType": {
                "keyToolTip": "This parameter sets which type of grayscale changes from top to bottom in the vertical direction within the edge detection frames will be regarded as object edges.",
                "singleStep": 0
            },
            "grayscaleChangeLowerThreshold": {
                "keyToolTip": "Points with grayscale changes above this threshold within the edge detection frames will be regarded as object edge points.",
                "maximum": 255,
                "minimum": 1
            },
            "numberOfEdgeDetectionFrames": {
                "keyToolTip": "This parameter sets the number of edge detection frames generated within the set ROI. Object edge points for fitting will be generated within each edge detection frame.",
                "maximum": 1000,
                "minimum": 3,
                "name": "Number of Edge Detection Frames",
                "singleStep": 1
            },
            "sigmaOfGaussianFilter": {
                "decimals": 1,
                "keyToolTip": "The Gaussian filter coefficient used to filter the image vertically within the edge detection frames. The recommended value is 1.",
                "maximum": 100,
                "minimum": 0.4,
                "singleStep": 0.1
            }
        }
    },
    "mmind::StepCamera": {
        "groupInfos": {
            "Background Removal Settings": [
                "removeBackgroundByDepth",
                "depthBackgroundFileName",
                "backgroundDepthThres"
            ],
            "Camera Settings": [
                "cameraType",
                "dataPath",
                "startFrameName",
                "playMode",
                "filePathType"
            ]
        },
        "icon_name": "Capture Images from Camera",
        "keywords": "measure",
        "properties": {
            "backgroundDepthThres": {
                "decimals": 1,
                "infrequentlyUsed": true,
                "keyToolTip": "Points will be removed when depth difference compared to background image is larger than threshold value.",
                "maximum": 20,
                "minimum": 0.01,
                "name": "Variation of Background Depth",
                "singleStep": 0.1,
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "dataPath": {
                "subtype": 1
            },
            "depthBackgroundFileName": {
                "infrequentlyUsed": true,
                "name": "Depth Background Image File",
                "stringFileFilter": "*.png *.jpg",
                "subtype": 4,
                "valueToolTip": "Set 2D Background"
            },
            "filePathType": {
                "infrequentlyUsed": true,
                "notEditable": false,
                "required": false,
                "singleStep": 0
            },
            "recaptureTimes": {
                "decimals": 0,
                "maximum": 10,
                "minimum": 1,
                "singleStep": 1
            },
            "removeBackgroundByDepth": {
                "infrequentlyUsed": true,
                "keyToolTip": "Whether to use depth threshold to remove background",
                "subtype": 1
            },
            "robotName": {
                "keyToolTip": "It should be the same robot name shown in Mech-Center.\nSpecifically, robot name contains vender name and robot type.",
                "name": "Robot Service Name in Mech-Center"
            },
            "startFrameName": {
                "name": "Current Frame Name",
                "subtype": 3
            }
        },
        "subgroup": "Capture from Camera"
    },
    "mmind::StepCaptureCloudInBox": {
        "groupInfos": {
            "Box Dimensions' Settings": [
                "halfX",
                "halfY",
                "halfZ"
            ],
            "Usage Settings of Input Clouds": [
                "inputCloudUsage"
            ]
        },
        "icon_name": "Extract 3D Points in Cuboid",
        "keywords": "Capture Cloud In Box",
        "properties": {
            "halfX": {
                "keyToolTip": "The half length of the box on the x-axis of the world coordinate system.",
                "minimum": 0,
                "name": "Half Length of Box on X-Axis",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "halfY": {
                "keyToolTip": "The half length of the box on the y-axis of the world coordinate system.",
                "minimum": 0,
                "name": "Half Length of Box on Y-Axis",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "halfZ": {
                "keyToolTip": "The half length of the box on the z-axis of the world coordinate system.",
                "minimum": 0,
                "name": "Half Length of Box on Z-Axis",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "inputCloudUsage": {
                "keyToolTip": "\"OneToOne\": Cuboid generated from each center pose for each point cloud. \n\"FirstToAll\": Cuboid generated from each center pose for the first point cloud. \n\"AllToFirst\": Cuboid generated from the first center pose for all point clouds.",
                "name": "Input Point Cloud Usage"
            }
        },
        "subgroup": "Extract Points by Geometry"
    },
    "mmind::StepCaptureCloudInSetCylinder": {
        "groupInfos": {
            "Cylinder Properties": [
                "radius"
            ],
            "Ring and Sector Radius Properties": [
                "xoyDisMinThre",
                "xoyDisMaxThre"
            ],
            "Sector Angle Properties": [
                "startAngle",
                "endAngle"
            ],
            "Usage Settings for Input Clouds": [
                "useCenter",
                "inputPointCloudUsage"
            ],
            "Z Direction Properties": [
                "zDisMinThre",
                "zDisMaxThre"
            ]
        },
        "icon_name": "Extract 3D Points in Cylinder",
        "keywords": "Extract Points in Cylinders/Capture Cloud In Set Cylinder",
        "properties": {
            "endAngle": {
                "decimals": 4,
                "keyToolTip": "The end angle of the sector on XY-plane.",
                "singleStep": 0.01,
                "subtype": 3,
                "suffix": "°"
            },
            "extractPointsType": {
                "keyToolTip": "3D points inside this specified shape will be extracted.",
                "name": "Shape Type"
            },
            "inputPointCloudUsage": {
                "keyToolTip": "\"All\": Cylinder generated from each center pose for each point cloud.\n\"FirstOnly\": Cylinder generated from each center pose for the first point cloud."
            },
            "radius": {
                "keyToolTip": "The radius of the circle on XY-plane.",
                "subtype": 2,
                "suffix": "m"
            },
            "startAngle": {
                "decimals": 4,
                "keyToolTip": "The start angle of the sector on XY-plane.",
                "singleStep": 0.01,
                "subtype": 3,
                "suffix": "°"
            },
            "useCenter": {
                "infrequentlyUsed": true,
                "keyToolTip": "If checked, the center of the object point cloud is used to check if it is inside the cylinder.",
                "name": "Check If Object inside Cylinder by Its Point Center"
            },
            "xoyDisMaxThre": {
                "keyToolTip": "The maximum distance on XY-plane.",
                "minimum": 0,
                "name": "Outer Radius",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "xoyDisMinThre": {
                "keyToolTip": "The minimum distance on XY-plane.",
                "minimum": 0,
                "name": "Inner Radius",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "zDisMaxThre": {
                "keyToolTip": "The maximum coordinate in the Z-axis.",
                "name": "Max Z Value",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "zDisMinThre": {
                "keyToolTip": "The minimum coordinate in the Z-axis.",
                "name": "Min Z Value",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            }
        },
        "subgroup": "Extract Points by Geometry"
    },
    "mmind::StepCaptureLargeInnerRectMask": {
        "groupInfos": {
            "Inscribed Rectangle Calculation Settings": [
                "angleStep",
                "translationStep",
                "aspectThre",
                "topN",
                "minArea",
                "intersectionAreaThre"
            ],
            "Poses & Sizes Settings": [
                "baseZ",
                "ratioToHighestZ",
                "searchNeighborRadius"
            ]
        },
        "properties": {
            "angleStep": {
                "minimum": 1
            },
            "aspectThre": {
                "minimum": 0.0001
            },
            "baseZ": {
                "minimum": 0
            },
            "intersectionAreaThre": {
                "minimum": 0
            },
            "minArea": {
                "minimum": 0
            },
            "ratioToHighestZ": {
                "minimum": 0
            },
            "searchNeighborRadius": {
                "minimum": 0,
                "suffix": "pixel"
            },
            "topN": {
                "minimum": 0,
                "singleStep": 1
            },
            "translationStep": {
                "minimum": 1,
                "singleStep": 1,
                "suffix": "pixel"
            }
        }
    },
    "mmind::StepCapturePoseInRoiFlag": {
        "icon_name": "Validate Existence of Poses in 3D ROI",
        "properties": {
            "inputPosesCoordType": {
                "name": "Input Poses Coordinate Type"
            }
        },
        "subgroup": "Validate"
    },
    "mmind::StepChamferMatching": {
        "groupInfos": {
            "Candidate Search Settings": [
                "objectMainDirection",
                "directionVariationRange",
                "translateStepInM",
                "rotateStep"
            ],
            "Template Variant": [
                "lineAngleQuantization",
                "directionCost",
                "baseScale",
                "minScaleExponent",
                "maxScaleExponent",
                "baseAspect",
                "minAspectExponent",
                "maxAspectExponent"
            ],
            "Threshold Settings": [
                "maxMeanDistanceError",
                "overlapThre"
            ]
        },
        "icon_name": "2D Matching",
        "properties": {
            "baseAspect": {
                "infrequentlyUsed": true,
                "keyToolTip": "The aspect of templates will be changed by \"Base Aspect\" ^ \"Aspect Exponent\".\n\"Aspect Exponent\" are integers within [\"Min Aspect Exponent\", \"Max Aspect Exponent\"].\nThe higher the value, the more probability to match the target correctly, but the more time-consuming the execution.",
                "minimum": 0,
                "name": "Base Aspect Ratio"
            },
            "baseScale": {
                "infrequentlyUsed": true,
                "keyToolTip": "Templates will be scaled by \"Base Scale\" ^ \"Scale Exponent\".\n\"Scale Exponent\" are integers within [\"Min Scale Exponent\", \"Max Scale Exponent\"].\nThe higher the value, the more probability to match the target correctly, but the more time-consuming the execution.",
                "minimum": 0
            },
            "directionCost": {
                "infrequentlyUsed": true,
                "keyToolTip": "The higher the value, the more precise the result, but the more time-consuming the execution.",
                "maximum": 1,
                "minimum": 0,
                "name": "Direction Cost Weight",
                "singleStep": 0.1
            },
            "directionVariationRange": {
                "decimals": 0,
                "keyToolTip": "The range of the object orientation in the scene.",
                "maximum": 180,
                "minimum": 0,
                "name": "Search Range of Orientation (0 ~ 180)",
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            },
            "lineAngleQuantization": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "Quantify the orientation of edge lines. For rectangles, 180 degrees are divided into \"Line Angle Quantization\" intervals. The higher the value, the more precise the result, but the more time-consuming the execution.",
                "maximum": 360,
                "minimum": 1,
                "name": "Line Angle Quantization (1 ~ 360)",
                "singleStep": 1
            },
            "maxAspectExponent": {
                "infrequentlyUsed": true,
                "keyToolTip": "Reference value: 0, 1, 2 and 3.\nThe higher the value, the more probability to match the target correctly, but the more time-consuming the execution.",
                "maximum": 10,
                "minimum": -10,
                "singleStep": 1,
                "valueToolTip": "Square of 1.05 is 1.1, cube is 1.157, fourth power is 1.216."
            },
            "maxMeanDistanceError": {
                "keyToolTip": "The maximum mean distance error of every matched template. The higher the value, the more accurate the result.",
                "minimum": 0,
                "name": "Max Mean Distance Error",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "maxScaleExponent": {
                "infrequentlyUsed": true,
                "keyToolTip": "Reference valus: 0, 1, 2 and 3.\nThe higher the value, the more probability to match the target correctly, but the more time-consuming the execution.",
                "maximum": 10,
                "minimum": -10,
                "singleStep": 1,
                "valueToolTip": "Square of 1.05 is 1.1, cube is 1.157, fourth power is 1.216."
            },
            "minAspectExponent": {
                "infrequentlyUsed": true,
                "keyToolTip": "Reference values: -3, -2, -1 and 0.\nThe lower the value, the more probability to match the target correctly, but the more time-consuming the execution.",
                "maximum": 10,
                "minimum": -10,
                "singleStep": 1
            },
            "minScaleExponent": {
                "infrequentlyUsed": true,
                "keyToolTip": "Reference values: -3, -2, -1 and 0.\nThe lower the value, the more probability to match the target correctly, but the more time-consuming the execution.",
                "maximum": 10,
                "minimum": -10,
                "singleStep": 1
            },
            "objectMainDirection": {
                "decimals": 0,
                "keyToolTip": "The coarse orientation of objects in the scene.\nIn the case of rectangles, define the direction of the horizontal side as the 0-degree direction, and the direction of the vertical side as the 90-degree direction.",
                "maximum": 360,
                "minimum": 0,
                "name": "Coarse Orientation of Objects (0 ~ 360)",
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            },
            "overlapThre": {
                "keyToolTip": "Results are eliminated if their overlap ratios are higher than this value. The higher the value, the more results tend to be output which are overlapped by each other.",
                "maximum": 1,
                "minimum": 0,
                "name": "Overlap Threshold (0 ~ 1.0)"
            },
            "rotateStep": {
                "decimals": 4,
                "keyToolTip": "The lower the value, the more precise the result, but the more time-consuming the execution.",
                "maximum": 180,
                "minimum": 0,
                "name": "Rotation Step of Template (0 ~ 180)",
                "singleStep": 0.5,
                "subtype": 3,
                "suffix": "°"
            },
            "translateStepInM": {
                "keyToolTip": "The lower the value, the more precise the result, but the more time-consuming the execution.",
                "minimum": 0,
                "name": "Translation Step of Template",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            }
        },
        "subgroup": "2D Matching"
    },
    "mmind::StepClassifiedBySpecifiedThreshold": {
        "groupInfos": {
            "File Settings": [
                "thresholdValueFile",
                "labelFile"
            ]
        },
        "icon_name": "Stratify Values by Thresholds",
        "keywords": "Classified By Set Threshold/classify",
        "properties": {
            "labelFile": {
                "keyToolTip": "A file that stores multiple labels in the format [ label_1, label_2, ... label_M].\nThere is an equation between the size of the labels and that of the thresholds, which is M =N + 1.",
                "name": "Label File Name",
                "stringFileFilter": "*.json",
                "subtype": 4,
                "valueToolTip": "Set labels"
            },
            "thresholdValueFile": {
                "keyToolTip": "A file that stores multiple thresholds in the format [ threshold_1, threshold_2, ... threshold_N ].\nFor N  thresholds, N + 1 labels are necessary.",
                "name": "Threshold File Name",
                "stringFileFilter": "*.json",
                "subtype": 4,
                "valueToolTip": "Set thresholds"
            }
        }
    },
    "mmind::StepCloudCluster": {
        "icon_name": "Point Cloud Clustering",
        "keywords": "Cloud Cluster/measure",
        "properties": {
            "cloudClusterType": {
                "name": "Cluster Algorithm",
                "valueToolTip": "EuclideanCluster: Determine whether it belongs to this category based on the distance.\nRegionGrowingSeg: Determine whether it belongs to this category according to the normal and curvature."
            },
            "gpu": {
                "infrequentlyUsed": false,
                "keyToolTip": "Usually faster than the CPU when the input clouds have a large size, and it also depends on the performance of CPU and GPU.",
                "name": "GPU"
            },
            "maxClusterNum": {
                "decimals": 0,
                "keyToolTip": "The maximum points number of a cluster, otherwise the cluster will be deleted.",
                "minimum": 0,
                "name": "Max Points Num in Cluster",
                "singleStep": 100
            },
            "minClusterNum": {
                "decimals": 0,
                "keyToolTip": "The minimum points number of a cluster, otherwise the cluster will be deleted.",
                "minimum": 0,
                "name": "Min Points Num in Cluster",
                "singleStep": 100
            }
        },
        "subgroup": "Cluster"
    },
    "mmind::StepCloudDistortionCorrection": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "subgroup": "Reshape / Transform / Move"
    },
    "mmind::StepCloudFilterByModelAndPose": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Searching Radius": [
                "filterRadiusThre"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "filterRadiusThre": {
                "keyToolTip": "The search radius to filter out points that are overlapping loaded model.",
                "minimum": 0,
                "subtype": 2,
                "suffix": "m"
            }
        },
        "subgroup": "Remove Points"
    },
    "mmind::StepCloudNumLimit": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Keep First N Clouds": [
                "cloudNumLimit"
            ],
            "Remove Last N Clouds": [
                "removeLast",
                "removeNum"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "cloudNumLimit": {
                "decimals": 0,
                "keyToolTip": "Number of clouds limitaion.",
                "singleStep": 1
            },
            "removeLast": {
                "keyToolTip": "Remove the last specified number of point clouds."
            },
            "removeNum": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::StepCloudPreprocessing": {
        "icon_name": "Calc Normals of Point Cloud and Filter It",
        "keywords": "Cloud Preprocessing/GPU",
        "properties": {
            "cloudPreprocessingType": {
                "name": "Normal Calc Methods",
                "valueToolTip": "CloudPreprocessingGPU: Calculate the normals and convert the input. It is recommened when the GPU exists and the user need the normals information.\nCloudXYZToCloudNormal: Simple and fast type conversion without actual calculation of the normals.\nNormalEstimation: The general method. Choose this one if the normals information is needed and the GPU is not exists."
            }
        },
        "subgroup": "Normal / Curvature"
    },
    "mmind::StepCloudROI": {
        "groupInfos": {
            "Empty Status Settings": [
                "minPointNum",
                "isSendNoCloudInfo"
            ]
        },
        "icon_name": "Extract 3D Points in 3D ROI",
        "properties": {
            "coordinateSystemType": {
                "keyToolTip": "The coordinate system where the input  point cloud is located.",
                "name": "Input Cloud Coordinate Type"
            },
            "isSendNoCloudInfo": {
                "keyToolTip": "If checked, send the empty status of points in 3D ROI.",
                "name": "Send Empty Status of Points in 3D ROI"
            },
            "minPointNum": {
                "decimals": 0,
                "keyToolTip": "Threshold of number of points within 3D ROI. If the number of points in the 3D ROI is small than the threshold, then the Step outputs no point cloud.",
                "minimum": 0,
                "name": "Min Points Number in 3D ROI",
                "singleStep": 1
            }
        },
        "subgroup": "Extract Points by Geometry"
    },
    "mmind::StepCloudSampler": {
        "icon_name": "Down-Sample Point Cloud",
        "keywords": "Cloud Sampler/measure",
        "properties": {
            "samplerType": {
                "keyToolTip": "Select the desired sampler。\n”UniformSampler“: The points of the output point cloud are selected from the original point cloud. The normals of the selected points remain.\n”VoxelGridSampler“: The points of the output point cloud are generated based on the voxels in 3D space, both the normals and the point positions are changed compared with those of the original point cloud."
            }
        },
        "subgroup": "Remove Points"
    },
    "mmind::StepCloudScale": {
        "icon_name": "Cloud Scale",
        "infrequentlyUsed": true,
        "keywords": "measure",
        "properties": {
            "ratioScale": {
                "keyToolTip": "Coordinate (x, y, z) of every point will be multiplied by ratioScale.",
                "minimum": 0
            }
        },
        "subgroup": "Reshape / Transform / Move"
    },
    "mmind::StepCloudServer": {
        "groupInfos": {
            "Cloud Settings": [
                "inputType"
            ],
            "Object Information Settings": [
                "sendObjInfo"
            ]
        },
        "icon_name": "Send Point Cloud to Mech-Viz",
        "keywords": "Cloud Server",
        "properties": {
            "areInputsInCamCoord": {
                "keyToolTip": "When input point cloud and object poses are in camera coordinate, this property should be checked."
            },
            "inputType": {
                "keyToolTip": "Input cloud type.",
                "name": "Input Point Cloud Type",
                "valueToolTip": "CloudXYZRGB: The colored point cloud with point positions.\nCloudXYZ: The point cloud with point positions.\nCloudXYZNORMAL: The point cloud with point positions and normals."
            },
            "sendObjInfo": {
                "keyToolTip": "Checked to send detected obj info to Mech-Viz. Once checked, the points in the cloud belonging to detected objects should have been removed by step 'Cloud Filter By model And Pose'. With object info, Mech-Viz will place CAD model and collision model into point cloud for both visualization and collision detection.",
                "name": "Send Object Information"
            }
        }
    },
    "mmind::StepCloudSizeClassifier": {
        "groupInfos": {
            "Aspect Ratio Settings": [
                "aspectRatioThre"
            ],
            "Height Difference Threshold Settings": [
                "heightDiffLowerRatioThre",
                "heightDiffUpperRatioThre",
                "baseHeight"
            ],
            "Length Difference Threshold Settings": [
                "lengthDiffLowerRatioThre",
                "lengthDiffUpperRatioThre"
            ],
            "Width Difference Threshold Settings": [
                "widthDiffLowerRatioThre",
                "widthDiffUpperRatioThre"
            ]
        },
        "icon_name": "Classification by Point Clouds' Sizes",
        "keywords": "Clouds Size Classifier/Cloud Size Classifier/classify/filter/",
        "properties": {
            "aspectRatioThre": {
                "keyToolTip": "The aspect is defined by the length divided by the width\nWhen the aspect within the following range , the point cloud is valid.\n[  (1+Threshold) * Reference Aspect , (1-Threshold)* Reference Aspect  ]",
                "name": "Aspect Ratio Threshold"
            },
            "baseHeight": {
                "keyToolTip": "When the input height is empty, the height of the point clouds will equal the Z value of the point cloud center minus this value.",
                "name": "Reference Hight",
                "subtype": 2,
                "suffix": "m"
            },
            "heightDiffLowerRatioThre": {
                "keyToolTip": "If the input point cloud satisfies the requirement, it might be qualified.\nHeight > (1+ Threshold)*Reference Height",
                "name": "Lower Ratio Threshold",
                "valueToolTip": "Generally negative"
            },
            "heightDiffUpperRatioThre": {
                "keyToolTip": "If the input point cloud satisfies the requirement, it might be qualified.\nHeight < (1+ Threshold)*Reference Height",
                "name": "Upper Ratio Threshold",
                "valueToolTip": "Generally positive"
            },
            "lengthDiffLowerRatioThre": {
                "keyToolTip": "If the input point cloud satisfies the requirement, it might be qualified.\nLength> (1+ Threshold)*Reference Length",
                "name": "Lower Ratio Threshold",
                "valueToolTip": "Generally negative "
            },
            "lengthDiffUpperRatioThre": {
                "keyToolTip": "If the input point cloud satisfies the requirement, it might be qualified.\nLength < (1+ Threshold)*Reference Length",
                "name": "Upper Ratio Threshold",
                "valueToolTip": "Generally positive"
            },
            "widthDiffLowerRatioThre": {
                "keyToolTip": "If the input point cloud satisfies the requirement, it might be qualified.\nWidth> (1+ Threshold)*Reference Width",
                "name": "Lower Ratio Threshold",
                "valueToolTip": "Generally negative"
            },
            "widthDiffUpperRatioThre": {
                "keyToolTip": "If the input point cloud satisfies the requirement, it might be qualified.\nwidth< (1+ Threshold)*Reference Width",
                "name": "Upper Ratio Threshold",
                "valueToolTip": "Generally positive"
            }
        },
        "subgroup": "Validate and Get Clouds"
    },
    "mmind::StepCloudSmoothAndNormalEstimation": {
        "groupInfos": {
            "Smoothing Settings": [
                "polynomialOrder",
                "searchRadius",
                "numThreads",
                "computeNormals"
            ]
        },
        "icon_name": "Cloud Smooth And Normal Estimation",
        "infrequentlyUsed": true,
        "properties": {
            "computeNormals": {
                "keyToolTip": "Normal will be recalculated by cloud after smoothing."
            },
            "numThreads": {
                "infrequentlyUsed": true,
                "keyToolTip": "The maximum number of hardware threads to use.",
                "maximum": 8,
                "minimum": 1
            },
            "polynomialOrder": {
                "keyToolTip": "The order of the polynomial to be fit.",
                "minimum": 0,
                "valueToolTip": "recommond value(3,4,5)"
            },
            "searchRadius": {
                "keyToolTip": "The sphere radius that is to be used for determining the k-nearest neigbors used for fitting.",
                "maximum": 1,
                "minimum": 0,
                "subtype": 2,
                "suffix": "m"
            }
        },
        "subgroup": "Normal / Curvature"
    },
    "mmind::StepCloudTransform": {
        "groupInfos": {
            "Transformation Settings": [
                "transformType"
            ]
        },
        "icon_name": "Transform Point Clouds",
        "keywords": "Cloud Transformer/measure",
        "properties": {
            "transformType": {
                "keyToolTip": "Transform the points in the clouds into another coordinate system.",
                "name": "Transformation Type",
                "valueToolTip": "CameraToRobot: Transform the point clouds from the camera coordinate to the robot coordiante.\nRobotToCamera: Transform the point clouds from the robot coordinate to the camera coordiante.\nAllWithFirst: Tranform the point clouds with the first reference poses.\nFirstWithAll: Tranform the first point cloud using the reference poses.\nUseCorrespondenceInput: Transform the point clouds with the referecnce poses one to one.\nAffineTransform: Transform the point clouds with an affine matirx."
            }
        }
    },
    "mmind::StepCloudXYZ2CloudNormal": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true
    },
    "mmind::StepCloudsFilter": {
        "deprecatedType": true,
        "groupInfos": {
            "Clouds Projection Settings": [
                "projectionType"
            ],
            "Morphological Transformation": [
                "erodeSize",
                "dilateSize"
            ]
        },
        "icon_name": "Point Cloud Filter",
        "keywords": "clouds filter",
        "properties": {
            "_filterType": {
                "name": "Filter Type",
                "valueToolTip": "CircleCloudsFilter: Remove the point clouds whose projections are  non-circular.\nCloudCapcityFilter: Filter the point clouds based on the point cloud size.\nRectCloudsFilter: Remove the point clouds whose projections are non-rectangular .\nSolidCloudsFilter: Remove solid point clouds."
            },
            "dilateSize": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "minimum": 1,
                "name": "Dilation Kernel Size",
                "singleStep": 2
            },
            "erodeSize": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "minimum": 1,
                "name": "Erosion Kernel Size",
                "singleStep": 2
            },
            "projectionType": {
                "valueToolTip": "Orthographic: Each line that is originally parallel will be parallel after this transformation. Prespective: From the perspective view."
            }
        }
    },
    "mmind::StepCloudsInROI": {
        "deprecatedType": true,
        "properties": {
            "coordType": {
                "name": "Input Cloud Coordinate Type"
            }
        },
        "subgroup": "Extract Points by Geometry"
    },
    "mmind::StepCoarseRegistration": {
        "icon_name": "3D Coarse Matching",
        "keywords": "3D Match/Coarse Registration/Calc Init Pose/Initial"
    },
    "mmind::StepCoarseRegistrationMultiTemplate": {
        "icon_name": "3D Coarse Matching",
        "keywords": "Coarse Registration Multi Template"
    },
    "mmind::StepCoarseRegistrationV2": {
        "groupInfos": {
            "Pose Filtering Settings": [
                "filterCandidatePoseByAxis",
                "AxisType",
                "angleThreshold",
                "useDistanceNMS",
                "referenceDir"
            ],
            "Pose Verification Settings": [
                "voxelLength",
                "outputNum",
                "voxelLengthGenetationStrategy",
                "minVoxelLength",
                "maxVoxelLength"
            ],
            "Preprocessing Settings": [
                "maxScenePointNum",
                "expectedModelPointNum",
                "neighbourNumber"
            ],
            "Result Visualization": [
                "visualizationOption"
            ],
            "Voting Settings": [
                "maxVoteRatio",
                "referredStep",
                "refStep",
                "angleQuantification",
                "distQuantification",
                "maxNumOfPointPairsPerFeature"
            ]
        },
        "icon_name": "3D Coarse Matching",
        "keywords": "3D Match/Coarse Registration/Calc Init Pose/Initial",
        "properties": {
            "AxisType": {
                "infrequentlyUsed": false,
                "keyToolTip": "The constraint axis on the pose.\n\nPlease see the tooltip of the parameter \"Filter Candite Pose by Axis\" for its use.",
                "name": "Constraint Axis",
                "notEditable": false,
                "required": false,
                "singleStep": 0
            },
            "angleQuantification": {
                "infrequentlyUsed": false,
                "keyToolTip": "This parameter sets the quantification scale of the angles between points' normals (angle Interval = 360° / angle quantification).\nThe larger the value, the higher the accuracy of the matching result, but the higher the requirement for the quality of the input point clouds.",
                "maximum": 360,
                "minimum": 1,
                "name": "Angle Quantification",
                "notEditable": false,
                "required": false,
                "singleStep": 10
            },
            "angleThreshold": {
                "infrequentlyUsed": false,
                "maximum": 180,
                "minimum": 0,
                "name": "Angle Difference Upper Threshold",
                "notEditable": false,
                "required": false,
                "singleStep": 1,
                "subtype": 3,
                "valueToolTip": "Please see the tooltip of the parameter \"Filter Candite Pose by Axis\"."
            },
            "distQuantification": {
                "infrequentlyUsed": false,
                "maximum": 10,
                "minimum": 0.01,
                "name": "Distance Quantification",
                "notEditable": false,
                "required": false,
                "singleStep": 0.1,
                "valueToolTip": "This parameter sets the quantification scale of the distances between points (distance interval = distance quantification * sampling interval).\nThe larger the value is, the less accurate the result tends to be."
            },
            "expectedModelPointNum": {
                "keyToolTip": "The expected point count of the sampled model point cloud.\nThe smaller the value, the fewer points in the sampled point cloud, and the lower the matching accuracy.",
                "maximum": 3000,
                "minimum": 20,
                "name": "Expected Point Count of Sampled Model",
                "singleStep": 10
            },
            "filterCandidatePoseByAxis": {
                "infrequentlyUsed": false,
                "keyToolTip": "The pose with a significant angle difference between the constraint axis and the reference direction (larger than the angle difference upper threshold) will not be considered pose candidates.\nIt is usually used to filter out poses corresponding to mirror matching results.",
                "name": "Filter Candidate Poses by Specified Axis Angles",
                "notEditable": false,
                "required": false,
                "subtype": 1
            },
            "maxNumOfPointPairsPerFeature": {
                "infrequentlyUsed": false,
                "keyToolTip": "The upper limit of the number of point pairs contained in each feature during the model analysis.\nThe smaller the value, the faster the execution, but the lower the accuracy.",
                "maximum": 99999,
                "minimum": 1,
                "name": "Upper Limit of Point Pair Count per Feature",
                "notEditable": false,
                "required": false,
                "showSlider": false,
                "singleStep": 10
            },
            "maxScenePointNum": {
                "infrequentlyUsed": false,
                "keyToolTip": "If the number of points of the sampled input point cloud is larger than this value, the input point cloud will be ignored and empty data will be output.",
                "maximum": 100000,
                "minimum": 100,
                "name": "Point Count Upper Threshold of Sampled Input Point Cloud",
                "singleStep": 100
            },
            "maxVoteRatio": {
                "decimals": 2,
                "infrequentlyUsed": false,
                "keyToolTip": "Poses with scores higher than the highest score multiplied by the vote ratio lower threshold in voting will go through pose verification.\nThe lower the value, the more likely exact matches will be found, but the longer the execution time.",
                "maximum": 1,
                "minimum": 0,
                "name": "Vote Ratio Lower Threshold",
                "notEditable": false,
                "required": false,
                "singleStep": 0.1
            },
            "maxVoxelLength": {
                "decimals": 6,
                "infrequentlyUsed": false,
                "keyToolTip": "The upper limit of the voxel length.",
                "maximum": 1,
                "minimum": 1e-06,
                "name": "Voxel Length Upper Limit",
                "notEditable": false,
                "required": false,
                "singleStep": 0.001,
                "subtype": 2
            },
            "minVoxelLength": {
                "decimals": 6,
                "infrequentlyUsed": false,
                "keyToolTip": "The lower limit of the voxel length.",
                "maximum": 1,
                "minimum": 1e-06,
                "name": "Voxel Length Lower Limit",
                "notEditable": false,
                "required": false,
                "singleStep": 0.001,
                "subtype": 2
            },
            "neighbourNumber": {
                "infrequentlyUsed": false,
                "keyToolTip": "The number of neighboring points used for calculating the orientation of each point.",
                "maximum": 100,
                "minimum": 1,
                "name": "Number of Neighboring Points",
                "notEditable": false,
                "required": false,
                "singleStep": 0
            },
            "outputNum": {
                "keyToolTip": "The expected number of matched poses for each input point cloud.",
                "maximum": 1000,
                "minimum": 1,
                "name": "Expected Number of Detected Poses per Input Point Cloud",
                "singleStep": 1
            },
            "refStep": {
                "infrequentlyUsed": false,
                "keyToolTip": "This parameter is used to sample points in the point cloud to make point pairs.\nThe larger the value, the faster the execution, but the lower the accuracy.",
                "maximum": 20,
                "minimum": 1,
                "name": "Referring Point Sampling Step",
                "notEditable": false,
                "required": false,
                "singleStep": 1
            },
            "referenceDir": {
                "keyToolTip": "Please see the tooltip of the parameter \"Filter Candite Pose by Axis\".",
                "name": "Reference Direction"
            },
            "referredStep": {
                "infrequentlyUsed": false,
                "keyToolTip": "This parameter is used to sample points in the point cloud to make point pairs.\nThe larger the value, the faster the execution, but the lower the accuracy.",
                "maximum": 20,
                "minimum": 1,
                "name": "Referred Point Sampling Step",
                "notEditable": false,
                "required": false,
                "singleStep": 1
            },
            "registrationMode": {
                "keyToolTip": "Please select the matching mode according to what the model point cloud is.\nIf the model point cloud is for the object edges, please select \"Edge Matching\".\nIf the model point cloud is for the object surface, please select \"Surface Matching\".",
                "name": "Matching Mode",
                "singleStep": 0
            },
            "useDistanceNMS": {
                "infrequentlyUsed": false,
                "keyToolTip": "Filter out candidate poses whose distance to the selected poses is less than 0.1 times the diameter of the object.",
                "name": "Use Distance NMS",
                "notEditable": false,
                "required": false,
                "subtype": 1
            },
            "visualizationOption": {
                "infrequentlyUsed": false,
                "keyToolTip": "After enabling Debug Output, the selected options will be generated and displayed.",
                "name": "Visualization Options",
                "notEditable": false,
                "required": false,
                "singleStep": 0
            },
            "voxelLength": {
                "decimals": 6,
                "infrequentlyUsed": false,
                "keyToolTip": "The length of the voxel. The bigger the value is, the less accurate the result tends to be.",
                "maximum": 1,
                "minimum": 1e-06,
                "name": "Voxel Length",
                "notEditable": false,
                "required": false,
                "singleStep": 0.001,
                "subtype": 2
            },
            "voxelLengthGenetationStrategy": {
                "infrequentlyUsed": false,
                "keyToolTip": "The voxel length can be generated automatically or set manually. For new users, the auto mode is recommended.",
                "name": "Voxel Length Generation Strategy",
                "notEditable": false,
                "required": false,
                "singleStep": 0
            }
        }
    },
    "mmind::StepCoherentLineDrawing": {
        "developingType": true,
        "groupInfos": {
            "Edge Tangent Flow": [
                "ETF_iter",
                "ETF_kernel"
            ],
            "Flow-based Difference-of-Gaussians": [
                "CLD_iter",
                "sigma_c",
                "sigma_m",
                "tau",
                "rho"
            ],
            "Visualization Settings": [
                "showCoherentLineImg",
                "showEdgeTangentFlowImg",
                "showEdgeTangentArrowImg"
            ]
        },
        "icon_name": "Coherent Line Drawing",
        "subgroup": "Line"
    },
    "mmind::StepCollectionTrigger": {
        "developingType": true,
        "properties": {
            "collectionCount": {
                "keyToolTip": "Count threshold in the collection from data flow"
            },
            "comparisonType": {
                "infrequentlyUsed": false,
                "keyToolTip": "The logic to determine whether the data flow can pass this step or not."
            }
        },
        "subgroup": "Trigger"
    },
    "mmind::StepColorImageFusion": {
        "infrequentlyUsed": true,
        "subgroup": "Color Image Processing"
    },
    "mmind::StepCombine2dAnd3dPose": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "keywords": "Combine 2d And 3d Pose",
        "subgroup": "Adjust Orientation"
    },
    "mmind::StepCompareDepth": {
        "developingType": true,
        "icon_name": "Compare Two Depth Image",
        "properties": {
            "downDif": {
                "keyToolTip": "Lower threshold for acceptable differencein two depth image, calculation unit: mm.\nThe pixel where depth difference is over this threshold but smaller than the upper threshold will be represented in green.",
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "upperDif": {
                "keyToolTip": "Upper threshold for acceptable differencein two depth image, calculation unit: mm.\nThe pixel where depth difference is over this threshold will be represented in red.",
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            }
        },
        "subgroup": "Supplement"
    },
    "mmind::StepComposeSize3d": {
        "icon_name": "From NumberList to Size3DList",
        "infrequentlyUsed": true,
        "subgroup": "Conversion"
    },
    "mmind::StepComposeVector3DFromNumbers": {
        "icon_name": "Compose Vector3D From Numbers",
        "infrequentlyUsed": true,
        "subgroup": "Vector3D Composition & Decomposition"
    },
    "mmind::StepControlLightSource": {
        "icon_name": "Control Light Source",
        "keywords": "measure"
    },
    "mmind::StepConvertCloudNormalToCloudRGB": {
        "icon_name": "From Cloud (XYZ-Normal) to Cloud (XYZ-RGB)",
        "keywords": "Convert CloudNormal To CloudRGB/xyznormal/xyzrgb",
        "subgroup": "Others"
    },
    "mmind::StepConvertCloudVectorToCloud": {
        "icon_name": "Merge Point Clouds",
        "keywords": "Convert Cloud Vector To Cloud/list",
        "subgroup": "Merge"
    },
    "mmind::StepConvertImgEdgeToThreedEdges": {
        "icon_name": "Convert 2D Points to 3D Points",
        "properties": {
            "calcEdgeNormal": {
                "keyToolTip": "If true, normals are calculated.",
                "name": "Calc Normal"
            },
            "epsilon": {
                "keyToolTip": "The error tolerance of the RANSAC fitting algorithm.\nIf it is chosen smaller than it should, fewer inliers are used;\nIf it is too large, more outliers are included;\nBoth situations mentioned above will lead to an inaccurate normal estimation.",
                "name": "Error Tolerance"
            },
            "iterations": {
                "decimals": 0,
                "keyToolTip": "The maximum number of iterations to use.",
                "minimum": 0,
                "singleStep": 1
            },
            "searchRadius": {
                "keyToolTip": "The radius of the bounding sphere of all the neighbors used to compute the surface normal at each point.",
                "minimum": 0
            }
        },
        "subgroup": "Image - Point Cloud"
    },
    "mmind::StepConvertNumberListToVariantList": {
        "icon_name": "From Numbers to Variants",
        "subgroup": "Conversion"
    },
    "mmind::StepConvertPoseVecToPoseVecs": {
        "icon_name": "From PoseList to PoseLists",
        "infrequentlyUsed": true,
        "keywords": "Convert PoseVec To PoseVecs",
        "subgroup": "Conversion"
    },
    "mmind::StepConvertVariantListToNumberList": {
        "icon_name": "From Variants to Numbers",
        "subgroup": "Conversion"
    },
    "mmind::StepConvertVariantListToVariant": {
        "icon_name": "From Variants to Variant",
        "subgroup": "Conversion"
    },
    "mmind::StepConvertVariantToVariantList": {
        "icon_name": "From Variant to Variants",
        "subgroup": "Conversion"
    },
    "mmind::StepCoordsTransform": {
        "groupInfos": {
            "Transformation Settings": [
                "transformType"
            ]
        },
        "icon_name": "Transform Poses",
        "keywords": "Coordinate Transformer/measure",
        "properties": {
            "transformType": {
                "keyToolTip": "Transform the poses into another coordinate system.",
                "name": "Transformation Type",
                "valueToolTip": "CameraToRobot: Transform the pose from the camera coordinate to the robot coordinate.\nRobotToCamera: Transform the pose from the robot coordinate to the camera coordinate.\nAllWithFirst: Transform all the original poses with the first reference pose.\nFirstWithAll: Transform the first original pose using all the reference poses. \nUseCorrespondenceInput: Transform the original poses with the reference poses one to one."
            }
        }
    },
    "mmind::StepCopyImages": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Custom Settings": [
                "renameWhenCopy"
            ],
            "Directory Settings": [
                "saveDir",
                "inputDir"
            ],
            "Image Indexing Settings": [
                "maxImgNum",
                "startIndex",
                "savingIndex"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "inputDir": {
                "keyToolTip": "Absolute path of the directory in which the images will be copied.",
                "subtype": 1
            },
            "maxImgNum": {
                "keyToolTip": "No more than this number of images will be copied and saved into save directory."
            },
            "saveDir": {
                "keyToolTip": "Absolute path of the directory for saving the copied images.",
                "subtype": 1
            }
        },
        "subgroup": "Image"
    },
    "mmind::StepCornerDetector": {
        "groupInfos": {
            "Contour Settings": [
                "minContourAreaThres",
                "maxDistBetweenOriginCurveAndApprox"
            ],
            "Corner Settings": [
                "cornerMinAngleThres"
            ],
            "Detection Strategies": [
                "onlyDetectConvexConer",
                "onlyDetectConersOnOneContour"
            ]
        },
        "icon_name": "Detect Corners",
        "infrequentlyUsed": true,
        "keywords": "Corner Detector",
        "properties": {
            "cornerMinAngleThres": {
                "decimals": 0,
                "keyToolTip": "The angle between two directions from the corner should be larger than this threshold.\nOtherwise, the corner will be eliminated.\n80°- 90°is recommended for plane shape; 75°is recommended for the Inclined plane.",
                "maximum": 90,
                "minimum": 0,
                "name": "Min Angle Between Two Corner's Directions (0 ~ 90)",
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            },
            "maxDistBetweenOriginCurveAndApprox": {
                "decimals": 0,
                "keyToolTip": "This parameter specifies the approximation accuracy. \nThis is the maximum distance between the original curve and its approximation. \nBefore corner detection, the approximation of the curve will be conducted and this value will be used.",
                "minimum": 0,
                "name": "Max Distance Between Original Curve and Its Approximation",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "minContourAreaThres": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "If the area of the detected contour is less than this value, there will be no corner detection in this contour.",
                "minimum": 0,
                "name": "Min Contour Area Threshold",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "onlyDetectConersOnOneContour": {
                "keyToolTip": "If checked, only the corners in the first contour will be detected.",
                "name": "Only Detect Corners on First Contour"
            },
            "onlyDetectConvexConer": {
                "keyToolTip": "If checked, only convex corners will be detected."
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepCountBoxesNum": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "keywords": "Count Boxes Num",
        "properties": {
            "boxHeight": {
                "minimum": 0,
                "subtype": 2
            },
            "boxNumInSingleLayer": {
                "decimals": 3,
                "maximum": 100,
                "minimum": 0,
                "singleStep": 1
            },
            "groundHeight": {
                "maximum": 10,
                "minimum": -10,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepCountElementsInSpecifiedLevel": {
        "icon_name": "Count Elements in Specified Dimension in Data List",
        "keywords": "count",
        "properties": {
            "vectorLevel": {
                "decimals": 0,
                "keyToolTip": "If input is a list of elements, and dimension is 0, that means each [ element ] will be performed with a defined operation.",
                "maximum": 14,
                "minimum": 0,
                "name": "Nth Dimension of Processed Variables in Vector",
                "singleStep": 1
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepCountPointsNum": {
        "icon_name": "Count 3D Points",
        "keywords": "Count Points Num",
        "subgroup": "Others"
    },
    "mmind::StepCropImage": {
        "developingType": true,
        "icon_name": "Crop Image",
        "properties": {
            "roi": {
                "name": "ROI"
            }
        }
    },
    "mmind::StepDecomposeInput": {
        "groupInfos": {
            "Linear Operation": [
                "multiplier",
                "addend"
            ]
        },
        "icon_name": "Decompose Object Dimensions",
        "infrequentlyUsed": true,
        "subgroup": "Others"
    },
    "mmind::StepDecomposeVector3DToNumbers": {
        "icon_name": "Decompose Vector3D to Numbers",
        "infrequentlyUsed": true,
        "subgroup": "Vector3D Composition & Decomposition"
    },
    "mmind::StepDeepLearning": {
        "groupInfos": {
            "Model": [
                "configPath",
                "modelPath"
            ],
            "Preload Settings": [
                "preloadModelOnProjectOpen"
            ],
            "Server": [
                "serverIP",
                "serverPort"
            ]
        },
        "properties": {
            "configPath": {
                "keyToolTip": "Deep learning configuration file path. Configuration file extension: .py/.dlkcfg/.json.",
                "name": "Configuration File",
                "subtype": 2
            },
            "modelPath": {
                "keyToolTip": "Deep learning model file path. Model file extension: .pth/.dlkmp.",
                "name": "Model File",
                "subtype": 2
            },
            "preloadModelOnProjectOpen": {
                "keyState": false,
                "keyToolTip": "Preload the model if True is selected.",
                "name": "Preload Model on Project Open",
                "subtype": 0
            },
            "serverIP": {
                "keyToolTip": "The IP address of the deep learning server.",
                "name": "Server IP",
                "subtype": 0
            },
            "serverPort": {
                "keyToolTip": "The port number of the deep learning server (1 ~ 65535).",
                "maximum": 65535,
                "minimum": 1,
                "name": "Server Port (1 ~ 65535)",
                "singleStep": 1
            }
        }
    },
    "mmind::StepDeepLearningPack": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "ROI settings": [
                "startX",
                "startY",
                "width",
                "height",
                "resetRoi"
            ]
        },
        "icon_name": "Deep Learning Inference",
        "infrequentlyUsed": true,
        "properties": {
            "clsConfidenceThreshold": {
                "keyToolTip": "Results above this threshold are retained.",
                "maximum": 1,
                "minimum": 0,
                "name": "Classification Confidence Threshold (0.0~1.0)",
                "singleStep": 0.001
            },
            "clsResultsOutputFlags": {
                "name": "Classification Output Flags"
            },
            "detConfidenceThreshold": {
                "keyToolTip": "Results above this threshold are retained.",
                "maximum": 1,
                "minimum": 0,
                "name": "Object Detection Confidence Threshold (0.0~1.0)",
                "singleStep": 0.001
            },
            "detResultsOutputFlags": {
                "name": "Object Detection Output Flags"
            },
            "height": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            },
            "modelsPackagePath": {
                "keyToolTip": "Sets the path to the model pack file used for inference; model pack files are \".dlkpack\" files exported by Mech-DLK.",
                "stringFileFilter": "Models Package (*.dlkpack)",
                "subtype": 2
            },
            "needFilterSegResults": {
                "name": "Filter Semantic Segmentation Results"
            },
            "resetRoi": {
                "keyToolTip": "Whether to reset the input image Roi, if checked, the input image Roi will be reset. If not checked, the settings in the roi.json file in the deep learning model package will be used.",
                "name": "Reset ROI"
            },
            "segAreaLowerLimit": {
                "decimals": 0,
                "keyToolTip": "Results above the lower limit will be retained.",
                "minimum": 0,
                "name": "Segmentation contour area lower limit",
                "singleStep": 1
            },
            "segPerimeterLowerLimit": {
                "decimals": 1,
                "keyToolTip": "Results above the lower limit will be retained.",
                "minimum": 0,
                "name": "Segmentation contour perimeter lower limit",
                "singleStep": 0.1
            },
            "segResultsOutputFlags": {
                "name": "Semantic Segmentation Output Flags"
            },
            "startX": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1,
                "subtype": 0
            },
            "startY": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            },
            "useSegAreaFiltering": {
                "name": "Filter result by segmentation contour area"
            },
            "useSegPerimeterFiltering": {
                "name": "Filter result by segmentation contour perimeter"
            },
            "width": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::StepDeepLearningPackInfer": {
        "groupInfos": {
            "ROI settings": [
                "roiPath"
            ]
        },
        "icon_name": "Deep Learning Inference",
        "properties": {
            "clsConfidenceThreshold": {
                "keyToolTip": "Results with confidences above this threshold will be kept and output.",
                "maximum": 1,
                "minimum": 0,
                "name": "Classification Confidence Threshold (0.0–1.0)",
                "singleStep": 0.001
            },
            "clsResultsOutputFlags": {
                "name": "Classification Output Flags"
            },
            "fastPositioningResultsOutputFlags": {
                "name": "Fast Positioning Output Flags"
            },
            "instanceSegConfidenceThreshold": {
                "keyToolTip": "Results with confidences above this threshold will be kept and output.",
                "maximum": 1,
                "minimum": 0,
                "name": "Instance Segmentation Confidence Threshold (0.0–1.0)",
                "singleStep": 0.001
            },
            "instanceSegResultsOutputFlags": {
                "name": "Instance Segmentation Output Flags"
            },
            "modelPackagePath": {
                "keyToolTip": "Sets the path to the model pack file used for inference; model pack files are \".dlkpack\" files exported by Mech-DLK.",
                "stringFileFilter": "Models Package (*.dlkpack)",
                "subtype": 2
            },
			"modelType": {
                "name": "modelType"
            },
            "objConfidenceThreshold": {
                "keyToolTip": "Results with confidences above this threshold will be kept and output.",
                "maximum": 1,
                "minimum": 0,
                "name": "Object Detection Confidence Threshold (0.0–1.0)",
                "singleStep": 0.001
            },
            "objResultsOutputFlags": {
                "name": "Object Detection Output Flags"
            },
            "roiPath": {
                "name": "ROI File Name",
                "subtype": 4
            },
            "segResultsOutputFlags": {
                "name": "Defect Detection Output Flags"
            }
        }
    },
    "mmind::StepDefectDetector": {
        "deprecatedType": true,
        "groupInfos": {
            "Defect Classification": [
                "classificationModelFile",
                "classificationConfigFile",
                "useClassification"
            ],
            "Filter Settings": [
                "defectAreaThreshold",
                "detectionRegionRoiList"
            ],
            "Visualization Settings": [
                "drawDefectMaskOnImage",
                "drawDefectLabelOnImage",
                "manuallyFontScale",
                "fontScale"
            ]
        },
        "icon_name": "Defect Detection",
        "infrequentlyUsed": true,
        "keywords": "measure",
        "properties": {
            "classificationConfigFile": {
                "keyToolTip": "The file path of the defect classification config file.",
                "subtype": 2
            },
            "classificationModelFile": {
                "keyToolTip": "The file path of the defect classification model.",
                "subtype": 2
            },
            "defectAreaThreshold": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "Ignore the defect when the number of defect pixels is less than the set threshold. The threshold range is 0 to 50000.",
                "maximum": 50000,
                "minimum": 0,
                "name": "Threshold for filtering defect size",
                "singleStep": 1,
                "subtype": 0
            },
            "detectionRegionRoiList": {
                "keyToolTip": "Set the ROI area for defect detection. This step needs to be completed in the Measure Mode.",
                "name": "Detection Region ROI List",
                "subtype": 3
            },
            "drawDefectLabelOnImage": {
                "keyToolTip": "Draw defect categories on the picture."
            },
            "drawDefectMaskOnImage": {
                "keyToolTip": "Draw a defect mask on the picture."
            },
            "fontScale": {
                "decimals": 1,
                "keyToolTip": "Set font size.",
                "maximum": 10,
                "minimum": 0,
                "name": "Font Size（0~10）",
                "singleStep": 0.5
            },
            "manuallyFontScale": {
                "keyToolTip": "Selected to use custinuzed font size.",
                "name": "Customized Font Size"
            },
            "useClassification": {
                "keyToolTip": "If users need to classify defects, please check this option."
            }
        },
        "subgroup": "Defect Detection"
    },
    "mmind::StepDepthClusterAlongScanLines": {
        "developingType": true
    },
    "mmind::StepDepthEncoding": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Depth Clipping Range": [
                "upperBound",
                "lowerBound"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "lowerBound": {
                "keyToolTip": "set the lower bound.",
                "maximum": 100000,
                "singleStep": 10,
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "upperBound": {
                "keyToolTip": "set the upper bound.",
                "maximum": 100000,
                "singleStep": 10,
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            }
        }
    },
    "mmind::StepDepthImgValidation": {
        "developingType": true,
        "groupInfos": {
            "Depth Range Settings": [
                "minThre",
                "maxThre",
                "interval"
            ]
        },
        "keywords": "Depth Image Validation",
        "properties": {
            "clearPrevious": {
                "keyToolTip": "Clear the collected depth images.",
                "name": "Clear Previous Images"
            },
            "interval": {
                "minimum": 0
            },
            "maxThre": {
                "keyToolTip": "Please refer the tooltip of \"Lower Threshold\" .",
                "name": "Upper Threshold"
            },
            "minThre": {
                "keyToolTip": "From \"Lower Threshold\" to \"Upper Threshold\" several intervals are specified using \"Interval\". \nFor each pixel, the difference between its depth value and the average depth value at the same position falls into one of these intervals. \nThe percentage of points in each interval to all points will be shown as the final result.",
                "name": "Lower Threshold "
            }
        },
        "subgroup": "Image"
    },
    "mmind::StepDepthInRoi": {
        "groupInfos": {
            "Threshold Settings": [
                "minPointNum"
            ]
        },
        "icon_name": "Invalidate Depth Pixels Outside 3D ROI",
        "properties": {
            "minPointNum": {
                "decimals": 0,
                "keyToolTip": "The threshold for the size of points in 3D ROI. \nIf the size of points is less than the threshold, a warning message will be shown.",
                "minimum": 0,
                "name": "Min Points in ROI",
                "singleStep": 10
            }
        },
        "subgroup": "ROI"
    },
    "mmind::StepDetectBinFourSides": {
        "groupInfos": {
            "Bin Location Settings": [
                "centerAwayCamera"
            ],
            "Bin Size Settings": [
                "binLength",
                "binWidth",
                "binHeight"
            ],
            "Collision Model Settings": [
                "thickness",
                "margin"
            ],
            "Corner Detection Settings": [
                "qualityLevel",
                "minDistance",
                "maxCorners",
                "blockSize",
                "useHarrisDetector",
                "k"
            ]
        },
        "icon_name": "Detect Bin (Four Sides)",
        "infrequentlyUsed": true,
        "keywords": "Collision",
        "properties": {
            "binHeight": {
                "keyToolTip": "Accurate height value of real object",
                "minimum": 0,
                "singleStep": 0.1,
                "subtype": 2,
                "suffix": "m"
            },
            "binLength": {
                "keyToolTip": "Accurate length value of real object",
                "minimum": 0,
                "singleStep": 0.1,
                "subtype": 2,
                "suffix": "m"
            },
            "binWidth": {
                "keyToolTip": "Accurate width value of real object",
                "minimum": 0,
                "singleStep": 0.1,
                "subtype": 2,
                "suffix": "m"
            },
            "blockSize": {
                "decimals": 0,
                "keyToolTip": "Size of an average block for computing a derivative covariation matrix over each pixel neighborhood.",
                "minimum": 0,
                "singleStep": 1
            },
            "centerAwayCamera": {
                "keyToolTip": "The distance from center of box to the camera.",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "margin": {
                "keyToolTip": "Distance from inner contour of upper edge to the tank wall.",
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "maxCorners": {
                "decimals": 0,
                "keyToolTip": "Maximum number of corners to return.",
                "minimum": 0,
                "singleStep": 1
            },
            "minDistance": {
                "decimals": 0,
                "keyToolTip": "Minimum possible Euclidean distance between the returned corners.",
                "minimum": 0,
                "singleStep": 1,
                "suffix": "pixel"
            },
            "neighborDepthSearchSize": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            },
            "qualityLevel": {
                "infrequentlyUsed": false,
                "keyToolTip": "Parameter characterizing the minimally accepted quality of corners."
            },
            "thickness": {
                "keyToolTip": "Thickness of side box.",
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "useHarrisDetector": {
                "infrequentlyUsed": true,
                "keyToolTip": "Select only whne use Harris detector."
            }
        }
    },
    "mmind::StepDetectBinInscribedRectSides": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Bin Size Settings": [
                "binHeight",
                "binSideWallThickness"
            ]
        },
        "icon_name": "Detect Bin (Largest Inscribed Rect)",
        "infrequentlyUsed": true,
        "keywords": "Detect Bin (Inscribed Rect Sides)/Collision",
        "properties": {
            "binHeight": {
                "keyToolTip": "The height of the bin.",
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "binSideWallThickness": {
                "keyToolTip": "The thickness of the bin.",
                "minimum": 0,
                "name": "Bin Sidewall Thickness",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            }
        }
    },
    "mmind::StepDetectBinInscribedRectSidesDeprecated": {
        "deprecatedType": true,
        "infrequentlyUsed": true,
        "properties": {
            "neighborDepthSearchSize": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::StepDetectBinTwoSides": {
        "groupInfos": {
            "Bin Settings": [
                "edgeWidth"
            ],
            "Collision Model Settings": [
                "boxAlignType",
                "moveYDis",
                "boxLength",
                "boxWidth",
                "boxHeight"
            ]
        },
        "icon_name": "Detect Bin (Two Sides)",
        "infrequentlyUsed": true,
        "keywords": "Collision",
        "properties": {
            "boxAlignType": {
                "keyToolTip": "The type for aligning the collision model with the sidewall of the bin. \nInsideAlign: The sidewall of the bin is inside of the collision model.\nOutsideAlign: The sidewall of the bin is outside of the collision model.",
                "name": "Align Type"
            },
            "boxHeight": {
                "keyToolTip": "The height of the collision model.",
                "minimum": 0,
                "name": "Height",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "boxLength": {
                "keyToolTip": "The length of the collision model.",
                "minimum": 0,
                "name": "Length",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "boxWidth": {
                "keyToolTip": "The width of the collision model.",
                "minimum": 0,
                "name": "Width",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "edgeWidth": {
                "keyToolTip": "The width of bin's sidewall.",
                "minimum": 0,
                "name": "Width of Bin's Sidewall",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "moveYDis": {
                "keyToolTip": "The translation of the collision model along the y-axis of its own pose. After the side of the model is aligned with the sidewall of the bin, the model translates this distance.",
                "name": "Translation",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            }
        }
    },
    "mmind::StepDetectCircle": {
        "groupInfos": {
            "Visualization Settings": [
                "drawDetectedCircle",
                "drawEdgePoints",
                "drawROI",
                "drawEdgeDetectionFrames"
            ]
        },
        "icon_name": "Detect Circle Centers",
        "properties": {
            "edgeDetectionFrameHalfHeight": {
                "keyToolTip": "Half the height of the edge detection frames. On the premise that the edge detection frames can cover the edge, the value can be appropriately decreased.",
                "maximum": 1000,
                "minimum": 4,
                "singleStep": 1
            }
        }
    },
    "mmind::StepDetectFiducialMarker": {
        "icon_name": "Detect Fiducial Markers",
        "infrequentlyUsed": true,
        "properties": {
            "markerSize": {
                "decimals": 0,
                "minimum": 0,
                "name": "标记物尺寸",
                "storeUnit": 0,
                "subtype": 2
            },
            "markerType": {
                "name": "标记物类型",
                "sub_object_types": [
                    "mmind::ArucoDetector",
                    "mmind::CCTagDetector",
                    "mmind::StagDetector"
                ]
            },
            "parametersCompensationDirectory": {
                "name": "参数补偿文件夹",
                "subtype": 1
            },
            "refinementSearchSize": {
                "minimum": 0
            },
            "saveAsParametersCompensationFormat": {
                "name": "保存为参数补偿格式"
            },
            "targetReference": {
                "name": "参考目标",
                "subtype": 3
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepDetectLine": {
        "groupInfos": {
            "Visualization Settings": [
                "drawDetectedLineSegment",
                "drawEdgePoints",
                "drawEdgeDetectionFrames",
                "drawROI"
            ]
        },
        "icon_name": "Detect Line Segments"
    },
    "mmind::StepDetectNLargestRectanglesInMask": {
        "groupInfos": {
            "Rectangle NMS Settings ": [
                "topNLargestArea"
            ],
            "Rectangle Shape Settings": [
                "aspectThreshold",
                "minArea",
                "maxArea"
            ],
            "Traversation Settings": [
                "angleStep",
                "translationStep"
            ]
        },
        "icon_name": "Detect N Largest Rectangles in Mask",
        "infrequentlyUsed": true,
        "properties": {
            "angleStep": {
                "maximum": 360,
                "minimum": 0,
                "name": "Angle Step (0 ~ 360)",
                "singleStep": 1,
                "suffix": "°"
            },
            "aspectThreshold": {
                "decimals": 3,
                "minimum": 1,
                "singleStep": 0.1,
                "subtype": 0,
                "valueToolTip": "Maximum aspect ratio of Rectangles."
            },
            "maxArea": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1,
                "suffix": "pixel",
                "valueToolTip": "Maximum area of rectangle."
            },
            "minArea": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1,
                "suffix": "pixel",
                "valueToolTip": "Minimum area of Rectangles."
            },
            "topNLargestArea": {
                "decimals": 0,
                "minimum": 1,
                "singleStep": 1
            },
            "translationStep": {
                "minimum": 0,
                "singleStep": 1,
                "suffix": "pixel"
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepDetectObscuredObjects": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Obscured Object 2D Shape Settings": [
                "aspectThreshold",
                "minArea",
                "maxArea"
            ],
            "Obscured Object NMS Settings": [
                "topNLargestArea"
            ],
            "Obscured Object Pose Settings": [
                "useHighestNeighbor",
                "searchNeighborRadius",
                "distanceFromPalletToCamera",
                "ratioOfHighestNeighborHeight",
                "defaultObscuredObjectsPoseZ"
            ],
            "Orthographic Projection Settings": [
                "closingOperateSize",
                "borderSize"
            ],
            "Traversation Seetings": [
                "angleStep",
                "translationStep"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "angleStep": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1,
                "suffix": "°"
            },
            "aspectThreshold": {
                "decimals": 3,
                "minimum": 1,
                "singleStep": 0.1,
                "subtype": 0,
                "valueToolTip": "Maximum aspect ratio of Obscured objects."
            },
            "borderSize": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "minimum": 0,
                "singleStep": 1,
                "suffix": "pixel"
            },
            "closingOperateSize": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "minimum": 3,
                "singleStep": 2,
                "suffix": "pixel"
            },
            "distanceFromPalletToCamera": {
                "minimum": 0,
                "suffix": "m"
            },
            "maxArea": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1,
                "suffix": "pixel",
                "valueToolTip": "The maximum area of the obscured object."
            },
            "minArea": {
                "decimals": 0,
                "minimum": 0,
                "singleStep": 1,
                "suffix": "pixel",
                "valueToolTip": "The minimum area of the obscured object."
            },
            "ratioOfHighestNeighborHeight": {
                "minimum": 0,
                "singleStep": 0.5,
                "subtype": 1
            },
            "searchNeighborRadius": {
                "decimals": 0,
                "minimum": 1,
                "singleStep": 1,
                "suffix": "pixel",
                "valueToolTip": "Objects within this radius will be considered neighbor objects."
            },
            "topNLargestArea": {
                "decimals": 0,
                "minimum": 1,
                "singleStep": 1
            },
            "translationStep": {
                "minimum": 0,
                "singleStep": 1,
                "suffix": "pixel"
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepDetectShapeFeatureOfRegion": {
        "icon_name": "Detect Shape Feature of Region",
        "infrequentlyUsed": true,
        "properties": {
            "filledRegionFeature": {
                "valueToolTip": "Fill in the shape feature of the detected region, otherwise only the contour of the shape feature is obtained."
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepDetectTangent": {
        "developingType": true
    },
    "mmind::StepDeterminePixelSize": {
        "icon_name": "Determine Pixel Size",
        "infrequentlyUsed": true,
        "properties": {
            "physicalSize": {
                "minimum": 0,
                "singleStep": 0.01,
                "storeUnit": 2,
                "subtype": 2
            }
        }
    },
    "mmind::StepDirectionCalib": {
    },
    "mmind::StepDivideCloudIntoSmallerPartsEvenly": {
        "developingType": true
    },
    "mmind::StepDrawInfoOnImage": {
        "groupInfos": {
            "Information Settings": [
                "infoType"
            ],
            "Label": [
                "drawingLabels",
                "onlyDrawSpecificLabel"
            ],
            "Pattern Properties": [
                "drawArrow"
            ],
            "Visualization Settings": [
                "fontScale",
                "radius",
                "thickness",
                "poseColor"
            ]
        },
        "icon_name": "Visualize Information on Image",
        "infrequentlyUsed": true,
        "keywords": "Draw Infos On Image/label/pose/mask/visualization/draw mask/draw poses/draw text/draw labels",
        "properties": {
            "drawArrow": {
                "keyToolTip": "Draw the arrow from the start point to end point.",
                "name": "Draw Trajectory Direction"
            },
            "drawingLabels": {
                "keyToolTip": " A  file containing some specified labels.",
                "name": "Label File Name",
                "stringFileFilter": "*.json",
                "subtype": 2
            },
            "fontScale": {
                "keyToolTip": "The font size of the text.",
                "name": "Font Size",
                "singleStep": 1
            },
            "infoType": {
                "name": "Information Type",
                "valueToolTip": "Pose3D: Only draw the poses on the image.\nPose3DAndLabel: Only draw poses and the corresponding labels on the image.\nMasksAndCountNumber: Only draw the bounding box of the mask images and print the number of the masks on the image."
            },
            "onlyDrawSpecificLabel": {
                "keyToolTip": "Checked to only draw labels that are contained in the label file. Otherwise all input labels will be drawn on the image.",
                "name": "Only Draw Specified Labels"
            },
            "poseColor": {
                "keyToolTip": "The dots to mark the position of the poses.",
                "name": "Dot Color"
            },
            "radius": {
                "keyToolTip": "The dots to mark the position of the poses.",
                "minimum": 0,
                "name": "Dot Radius",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "thickness": {
                "keyToolTip": "The line thickness of the text.",
                "name": "Line Thickness",
                "singleStep": 1,
                "suffix": "pixel"
            }
        }
    },
    "mmind::StepDrawInfosOnImage": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "properties": {
            "B": {
                "decimals": 0,
                "maximum": 255,
                "minimum": 0,
                "singleStep": 1
            },
            "G": {
                "decimals": 0,
                "maximum": 255,
                "minimum": 0,
                "singleStep": 1
            },
            "R": {
                "decimals": 0,
                "maximum": 255,
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::StepDrawMinAreaRectOnImage": {
        "groupInfos": {
            "Display Settings": [
                "drawInfoWithSameColor",
                "drawIndex"
            ]
        },
        "icon_name": "Draw Min Circumscribed Rectangles of Masks",
        "infrequentlyUsed": true,
        "keywords": "Draw Min Area Rect On Image",
        "properties": {
            "drawIndex": {
                "keyToolTip": "True: Displays indices of rectangles.\nFalse: Do not displays indices of rectangles.",
                "name": "Displays Indices of Rectangles"
            },
            "drawInfoWithSameColor": {
                "keyToolTip": "True: Each circumscribed rectangle and its object information is displayed by the same color.\nFalse: Each circumscribed rectangle and its object information is displayed by random colors.",
                "name": "Display Information with Same Color as Corresponding Rectangle"
            }
        }
    },
    "mmind::StepDrawPolysVert": {
        "icon_name": "Draw Polygon Vertices",
        "keywords": "Draw PolysVert",
        "properties": {
            "outputSingleMask": {
                "name": "Merge Masks of Polygons into One"
            }
        }
    },
    "mmind::StepDynamicInputPorts": {
        "properties": {
            "inputSize": {
                "decimals": 0,
                "maximum": 16,
                "minimum": 1,
                "name": "Port Number (1–16)",
                "singleStep": 1
            },
            "vectorLevel": {
                "decimals": 0,
                "maximum": 14,
                "minimum": 0,
                "name": "N-th Dimension of Unpacked Variables in Vector",
                "singleStep": 1
            }
        }
    },
    "mmind::StepDynamicIoPorts": {
        "groupInfos": {
            "Ports Settings": [
                "vectorLevel",
                "dynamicIoSize"
            ]
        },
        "properties": {
            "dynamicIoSize": {
                "decimals": 0,
                "keyToolTip": "The custom number of ports.",
                "maximum": 15,
                "minimum": 1,
                "name": "Port Number (1–15)",
                "singleStep": 1
            },
            "vectorLevel": {
                "decimals": 0,
                "keyToolTip": "If the operation layer is 0, the operation will performed on every elements in the lists.",
                "maximum": 14,
                "minimum": 0,
                "name": "Operation Layer",
                "singleStep": 1,
                "valueToolTip": "The innnermost layer is 0."
            }
        }
    },
    "mmind::StepEasyCoordsTransform": {
        "groupInfos": {
            "Transform Settings": [
                "transformType"
            ]
        },
        "icon_name": "Easy Coordinate Transform",
        "infrequentlyUsed": true,
        "subgroup": "Coordination Transform"
    },
    "mmind::StepEasyCreateIndexList": {
        "icon_name": "Easy Create Index List",
        "infrequentlyUsed": true,
        "properties": {
            "n": {
                "keyToolTip": "Output would be 0, 1, ..., N-1, which can be used as the object indices.",
                "name": "Total Number N"
            }
        },
        "subgroup": "Convenient Helpers"
    },
    "mmind::StepEasyCreateNumberList": {
        "icon_name": "Easy Create Number List",
        "infrequentlyUsed": true,
        "subgroup": "Convenient Helpers"
    },
    "mmind::StepEasyCreatePoses": {
        "icon_name": "Easy Create Poses",
        "infrequentlyUsed": true,
        "keywords": "measure",
        "subgroup": "Convenient Helpers"
    },
    "mmind::StepEasyCreateQuaternions": {
        "icon_name": "Easy Create Quaternions",
        "infrequentlyUsed": true,
        "subgroup": "Convenient Helpers"
    },
    "mmind::StepEasyCreateStringList": {
        "icon_name": "Easy Create String List",
        "infrequentlyUsed": true,
        "subgroup": "Convenient Helpers"
    },
    "mmind::StepEasyCreateVector3ds": {
        "icon_name": "Easy Create Vector3Ds",
        "infrequentlyUsed": true,
        "subgroup": "Convenient Helpers"
    },
    "mmind::StepEasyPointTo": {
        "icon_name": "Easy Point to Reference Place",
        "infrequentlyUsed": true,
        "subgroup": "Pose Rotation"
    },
    "mmind::StepEdgeDetector": {
        "deprecatedType": true,
        "groupInfos": {
            "Edge Threshold": [
                "fuseEdgeThreshold",
                "averageEdgeThreshold"
            ]
        },
        "icon_name": "Detect Edges",
        "infrequentlyUsed": true,
        "keywords": "Edge Detector",
        "properties": {
            "averageEdgeThreshold": {
                "keyToolTip": "The higher the threshold, the less the detected edges.",
                "maximum": 254,
                "minimum": 1,
                "name": "Average Edge Threshold (0~255)",
                "singleStep": 1
            },
            "fuseEdgeThreshold": {
                "keyToolTip": "The higher the threshold, the less the detected edges.",
                "maximum": 254,
                "minimum": 1,
                "name": "Fused Edge Threshold (0~255)",
                "singleStep": 1
            }
        },
        "subgroup": "Detect Edges"
    },
    "mmind::StepExternalInterface": {
        "icon_name": "External Interface",
        "infrequentlyUsed": true
    },
    "mmind::StepExtrCaliOfStructuredLightSensor": {
        "developingType": true,
        "infrequentlyUsed": true
    },
    "mmind::StepFeatureDetector": {
        "icon_name": "Detect Edges",
        "infrequentlyUsed": true,
        "keywords": "Feature Detector",
        "subgroup": "Line"
    },
    "mmind::StepFilter": {
        "icon_name": "Filter",
        "properties": {
            "reverseBoolList": {
                "keyToolTip": "False: Filter those items with 'False' in input 'BoolList' and return items with 'True'.\nTrue: Filter items with 'True' in input 'BoolList' and return items with 'False'.",
                "valueToolTip": "Default is False."
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepFilterMasksByPoses": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "subgroup": "Validate Masks by Poses"
    },
    "mmind::StepFilterPosesOutsideBin": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Collision Box Size Settings": [
                "boxLength",
                "boxWidth",
                "boxHeight"
            ],
            "Collision Model Settings": [
                "alignType",
                "moveYDis"
            ],
            "Custom Settings": [
                "edgeWidth"
            ],
            "Filtering Settings": [
                "thresholdType",
                "removedNum",
                "removedRatio"
            ],
            "Out-of-bin Checking": [
                "useOutOfBinWeights",
                "weightsScale"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "alignType": {
                "keyToolTip": "Collision align type.",
                "valueToolTip": "inside edge / outside edge"
            },
            "boxHeight": {
                "keyToolTip": "Box height(z)",
                "subtype": 2,
                "suffix": "m"
            },
            "boxLength": {
                "keyToolTip": "Box length(x)",
                "subtype": 2,
                "suffix": "m"
            },
            "boxWidth": {
                "keyToolTip": "Box width(y)",
                "subtype": 2,
                "suffix": "m"
            },
            "edgeWidth": {
                "keyToolTip": "Real width of box edge (like Square steel) ",
                "subtype": 2,
                "suffix": "m"
            },
            "moveYDis": {
                "keyToolTip": "Collision move distance along Y dir.( Y point to center of bin and Z is upward.)",
                "valueToolTip": "0(No move), positive(Close to the center of box), negative(Away from the center of the box)"
            },
            "removedNum": {
                "keyToolTip": "Out of bin cloud num ",
                "valueToolTip": "Greater than this value will be treated as out of bin"
            },
            "removedRatio": {
                "keyToolTip": "Out of bin cloud ratio",
                "valueToolTip": "Greater than this value will be treated as out of bin"
            },
            "thresholdType": {
                "keyToolTip": "Filter threshold type",
                "valueToolTip": "RemovedNum / RemovedRatio "
            },
            "useOutOfBinWeights": {
                "keyToolTip": "Use out of bin weights.",
                "valueToolTip": "The more vertical of the object and box side, the greater the weights"
            },
            "weightsScale": {
                "keyToolTip": "Weights scale",
                "valueToolTip": "default:1.0"
            }
        }
    },
    "mmind::StepFind2DContour": {
        "groupInfos": {
            "Contours Drawing Settings": [
                "lineSize"
            ],
            "Contours Retrieval Settings": [
                "contourRetrievalMode",
                "hierarchyLevel",
                "minContourSize",
                "maxContourSize",
                "sortContourBySizeAscending",
                "mergeContours"
            ]
        },
        "icon_name": "Find 2D Contour at Specified Hierarchical Level",
        "properties": {
            "contourRetrievalMode": {
                "valueToolTip": "CV_RETR_EXTERNAL: Retrieves only the extreme outer contours.\nCV_RETR_LIST: Retrieves all of the contours without establishing any hierarchical relationships.\nCV_RETR_CCOMP: Retrieves all of the contours and organizes them into a two-level hierarchy. \nCV_RETR_TREE: Retrieves all of the contours and reconstructs a full hierarchy of nested contours."
            },
            "hierarchyLevel": {
                "decimals": 0,
                "keyToolTip": "Set the required contour of the specified hierarchy levels.",
                "minimum": -1,
                "name": "Specified Hierarchy",
                "singleStep": 1,
                "valueToolTip": "The hierarchy increases from the outer layer to the inner layer.\nThe outermost layer hierarchy is 1.\nBesides, there are special values to be noticed: 0 means all the contours and -1 means the innermost layer."
            },
            "lineSize": {
                "decimals": 0,
                "keyToolTip": "Thickness of lines the contours are drawn with.\nIf it is negative, the contour interiors will be filled.",
                "minimum": -1,
                "name": "Line Thickness",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "maxContourSize": {
                "decimals": 0,
                "keyToolTip": "Contour with a pixel size larger than this value will be discarded.",
                "minimum": 1,
                "singleStep": 1,
                "suffix": "pixel"
            },
            "mergeContours": {
                "infrequentlyUsed": false,
                "keyToolTip": "Draw all contours into one mask."
            },
            "minContourSize": {
                "decimals": 0,
                "keyToolTip": "Contour with a pixel size smaller than this value will be discarded.",
                "minimum": 1,
                "singleStep": 1,
                "suffix": "pixel"
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepFindAccurateBoxRect": {
        "groupInfos": {
            "Rectangle Settings": [
                "maxVertexDeviationThres"
            ]
        },
        "infrequentlyUsed": true,
        "keywords": "Find Accurate Box Rect",
        "properties": {
            "maxVertexDeviationThres": {
                "keyToolTip": "if the distance between the input vertex and the estimated vertex of the rectangle is smaller than this value, the detected rectangle is considered valid.",
                "minimum": 1e-06,
                "name": "Vertices Deviation Threshold",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepFindCorners": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "properties": {
            "drawCornerRadius": {
                "infrequentlyUsed": true,
                "minimum": 0,
                "suffix": "pixel"
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepFindCorrespondingOffsetPoses": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "keywords": "Find Corresponding Offset Poses",
        "properties": {
            "expandRatioForOriginRange": {
                "keyToolTip": "The original search radius is the object dimension, and it can be expanded by this ratio.",
                "name": "Search Radius Expansion Ratio"
            },
            "rectifyPose": {
                "keyToolTip": "Checked to adjust the orientation of the object poses. The x-axis and y-axis of object pose will be parallel with those of the offset poses.",
                "name": "Adjust Object Poses"
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepFindHole2d": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Circularity": [
                "minCircularity",
                "maxCircularity"
            ],
            "Convexity": [
                "minConvexity",
                "maxConvexity"
            ],
            "Custom Settings": [
                "dilateSize",
                "holeDilateSize",
                "holeAreaRadius",
                "contourPointsNumThre"
            ],
            "Hole Area Settings": [
                "minAreaThreshold",
                "maxAreaThreshold"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "contourPointsNumThre": {
                "minimum": 0,
                "singleStep": 1,
                "valueToolTip": "Boundary point number in set hole area."
            },
            "dilateSize": {
                "minimum": 0,
                "singleStep": 1,
                "valueToolTip": "Dilate size of contours."
            },
            "holeAreaRadius": {
                "minimum": 0,
                "singleStep": 1
            },
            "holeDilateSize": {
                "minimum": 0,
                "singleStep": 1
            },
            "maxAreaThreshold": {
                "minimum": 0,
                "singleStep": 10
            },
            "maxCircularity": {
                "minimum": 0,
                "singleStep": 0.1
            },
            "maxConvexity": {
                "minimum": 0,
                "singleStep": 0.1
            },
            "minAreaThreshold": {
                "minimum": 0,
                "singleStep": 10
            },
            "minCircularity": {
                "minimum": 0,
                "singleStep": 0.1
            },
            "minConvexity": {
                "minimum": 0,
                "singleStep": 0.1
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepFindMinGraspableRects": {
        "developingType": true,
        "groupInfos": {
            "Line Clustering Settings": [
                "parallelLinesMaxAngleThres",
                "distThresForClusters",
                "lengthThresForClusters",
                "clusterContinuityRatio"
            ],
            "Parallel Lines Settings": [
                "pairupMaxAngleThres",
                "clusterEndPtToCornerThres",
                "clusterEndPtToCrossptThres",
                "clusterCenterToCornerThres",
                "acceptanceCostRatio",
                "strategyForSearchingRects"
            ],
            "Sucker & Box Size Settings": [
                "minLength",
                "maxLength"
            ],
            "Visualization Settings": [
                "showParallelLines",
                "showLineClusters",
                "showPairupClusters"
            ]
        },
        "keywords": "Find Graspable Rects",
        "properties": {
            "acceptanceCostRatio": {
                "infrequentlyUsed": true,
                "keyToolTip": "The acceptable ratio between a rectangle candidate cost to the lowest rectangle candidate cost.\nThe smaller the value is, the fewer candidates are output, but the more accurate the result is."
            },
            "clusterCenterToCornerThres": {
                "infrequentlyUsed": true,
                "keyToolTip": "It is used to check if the line segment is close enough to the corner point.\nThis threshold is related to the error between the detected corner point and the actual corner point.\nThe larger the value is, the fewer candidates are output, but the more accurate the result is.",
                "name": "Cluster Center to Corner Point Threshold",
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "clusterContinuityRatio": {
                "keyToolTip": "If the clustered line segments are not connected, these line segments will be finely divided into n small line segment clusters. \nThe larger the ratio is, the harder the clustered line segments are considered to belong to a side of the rectangle by the algorithm."
            },
            "clusterEndPtToCornerThres": {
                "infrequentlyUsed": true,
                "keyToolTip": "It is used to check if the line segment is close enough to the corner point.\nThis threshold is used to check whether the detected small line segments can completely cover the edges of the object.\nThe larger the value is, the fewer candidates are output, but the more precise the result is.",
                "name": "Cluster Endpoint to Corner Point Threshold",
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "clusterEndPtToCrossptThres": {
                "infrequentlyUsed": true,
                "keyToolTip": "It is used to check if those line segments can be combined to make a closed rectangle.\nThis threshold is used to check whether the detected small line segments can completely cover the edges of the object.\nThe larger the value is, the fewer candidates are output, but the more precise the result is.",
                "name": "Cluster Endpoint to Cross Point Threshold",
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "distThresForClusters": {
                "keyToolTip": "If the distance between the center of the two parallel line segments and each line segment is less than the threshold, these two parallel line segments are considered belong to one cluster.\nThe smaller the threshold, the closer the distance between these two line segments. As a result, the cluster result of line segments tends to be more fragmented.",
                "maximum": 1000,
                "name": "Distance Threshold of Parallel Lines",
                "singleStep": 1,
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "lengthThresForClusters": {
                "keyToolTip": "For clustered line segments, a larger length threshold can be used to filter out the pattern on the box.",
                "maximum": 1000,
                "name": "Length Threshold for Clulstered Lines",
                "singleStep": 1,
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "maxLength": {
                "keyToolTip": "The maximum length of a box item in the scene.",
                "minimum": 0,
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "minLength": {
                "keyToolTip": "The minimum length of a box item in the scene.\nIt should not be smaller than the diameter of the suction cup.",
                "minimum": 0,
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "pairupMaxAngleThres": {
                "decimals": 4,
                "keyToolTip": "The max angle between opposite sides of rectangle candidates.",
                "maximum": 90,
                "name": "Max Angle Between Opposite Sides of Rectangle",
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            },
            "parallelLinesMaxAngleThres": {
                "decimals": 4,
                "keyToolTip": "The max angle between parallel lines in one cluster.",
                "maximum": 90,
                "name": "Max Angle Between Parallel Lines",
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            },
            "showLineClusters": {
                "keyToolTip": "Show line clusters."
            },
            "showPairupClusters": {
                "keyToolTip": "Show the opposite sides of rectangle candidates.",
                "name": "Show Opposite Sides of Rectangle"
            },
            "showParallelLines": {
                "keyState": false,
                "keyToolTip": "Show lines which are parallel to the corners's direction."
            },
            "strategyForSearchingRects": {
                "infrequentlyUsed": true,
                "keyState": false,
                "keyToolTip": "The strategies for searching rectangles.",
                "name": "Strategies for Searching Rectangles"
            }
        }
    },
    "mmind::StepFineClassifier": {
        "deprecatedType": true,
        "icon_name": "Image Classification",
        "infrequentlyUsed": true,
        "keywords": "FineClassifier",
        "properties": {
            "confidenceThreshold": {
                "keyToolTip": "The higher the value, the more reliable the predicted classification.",
                "maximum": 1,
                "minimum": 0,
                "name": "Confidence Threshold (0 ~ 1.0)",
                "valueToolTip": "A value between 0 and 1."
            }
        },
        "subgroup": "Image Classification"
    },
    "mmind::StepFineRegistration": {
        "groupInfos": {
            "Matching Field": [
                "wholeScene"
            ],
            "Model Weight in Validation": [
                "fileOfModelFragmentsWithHighWeight",
                "weightOfEachPoint",
                "searchRadiusWhenSetWeight"
            ],
            "Output Settings": [
                "candidateTopNum"
            ],
            "Results Visualization": [
                "showSampledModelCloud",
                "showSampledSceneCloud",
                "showValidationPointCorrespondences",
                "showOutputModelAndSceneCloud"
            ],
            "Sample Settings": [
                "leafSize",
                "searchNum",
                "edgeSearchRadius",
                "angleThreshold",
                "searchWithRadius",
                "sampler"
            ],
            "Symmetry Settings": [
                "rotationStrategy",
                "angleStep",
                "minAngle",
                "maxAngle"
            ],
            "Translation Settings": [
                "tranRangeX",
                "tranRangeY",
                "tranStep",
                "fullConnect"
            ],
            "Validation Settings": [
                "confidenceThreshold",
                "validationSearchRadius",
                "applyAngleDeviationInValidation"
            ]
        },
        "icon_name": "3D Fine Matching",
        "keywords": "Fine Registration/Local Matching",
        "properties": {
            "angleStep": {
                "decimals": 1,
                "keyToolTip": "The angle step is used for changing the initial orientation from \"Min Rotation Angle\" to \"Max Rotation Angle\".",
                "maximum": 360,
                "minimum": 0,
                "name": "Angle Step (0 ~ 360)",
                "singleStep": 0.1,
                "subtype": 3,
                "suffix": "°"
            },
            "angleThreshold": {
                "infrequentlyUsed": true,
                "keyToolTip": "This parameter is kept for compatibility with old versions."
            },
            "applyAngleDeviationInValidation": {
                "keyToolTip": "Consider the angle difference of normal vectors of corresponding point pairs when the pose is being validated.\nIf it is checked, it tends to have less but more accurate output."
            },
            "candidateTopNum": {
                "decimals": 0,
                "keyToolTip": "The number of output poses for each point cloud.",
                "minimum": 1,
                "name": "Maximum Number of Detected Poses in Each Point Cloud",
                "singleStep": 1
            },
            "confidenceThreshold": {
                "decimals": 3,
                "keyToolTip": "If the validation score of the result is larger than this threshold, the result is regarded as valid.\nThe higher the value is, the more accurate the result tends to be.",
                "minimum": 0
            },
            "correspondenceType": {
                "name": "Correspondence Settings"
            },
            "edgeSearchRadius": {
                "infrequentlyUsed": true,
                "keyToolTip": "This parameter is kept for compatibility with old versions.",
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "fileOfModelFragmentsWithHighWeight": {
                "keyToolTip": "The file of the model fragments, the points in which will have a high weight set by \"Weight of Each Point\".",
                "stringFileFilter": "*.ply",
                "subtype": 2
            },
            "fullConnect": {
                "infrequentlyUsed": true,
                "keyToolTip": "If checked, \"Translation Range on X Direction\" * \"Translation Range on Y Direction\" coarse poses are generated and will be input to the registration algorithm.\nThe higher the value is, the better the matching result tends to be found."
            },
            "leafSize": {
                "decimals": 6,
                "keyToolTip": "The sampling interval used for the downsampling of the model and scene point cloud.\nThe bigger the value, the less the point number of the sampled point cloud. Thus, the estimated poses become less precise.",
                "minimum": 0,
                "name": "Sampling Interval",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "maxAngle": {
                "decimals": 1,
                "infrequentlyUsed": true,
                "keyToolTip": "Please refer the tooltip of \"Angle Step\".",
                "maximum": 180,
                "minimum": -180,
                "name": "Max Rotation Angle (-180 ~ 180)",
                "subtype": 3,
                "suffix": "°"
            },
            "minAngle": {
                "decimals": 1,
                "infrequentlyUsed": true,
                "keyToolTip": "Please refer the tooltip of \"Angle Step\".",
                "maximum": 180,
                "minimum": -180,
                "name": "Min Rotation Angle (-180 ~ 180)",
                "subtype": 3,
                "suffix": "°"
            },
            "multiplyCorrespondingPointsRatioInScene": {
                "infrequentlyUsed": true,
                "keyToolTip": "If checked, the matching score will be multiplied by the proportional coefficient of the corresponding point to the scene point. Not suitable for the case of estimating poses of multiple objects in one point cloud."
            },
            "rotationStrategy": {
                "infrequentlyUsed": false,
                "keyToolTip": "The symmetry axis, around which the initial pose is changed.",
                "name": "Symmetry Axis"
            },
            "sampler": {
                "keyToolTip": "The sampling method.\nThis parameter is kept for compatibility with old versions."
            },
            "searchNum": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "This parameter is kept for compatibility with old versions.",
                "minimum": 1,
                "name": "Search Points Number",
                "singleStep": 1
            },
            "searchRadiusWhenSetWeight": {
                "keyToolTip": "The radius for setting weights.\nThe bigger the value is, the more points in the model will have the set weight.",
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "searchWithRadius": {
                "infrequentlyUsed": true,
                "keyToolTip": "This parameter is kept for compatibility with old versions."
            },
            "showOutputModelAndSceneCloud": {
                "keyToolTip": "Show the estimated pose of objects by rendering the transformed model and the scene point cloud.",
                "name": "Show Matching Results"
            },
            "showSampledModelCloud": {
                "keyToolTip": "Show the sampled model point cloud."
            },
            "showSampledSceneCloud": {
                "keyToolTip": "Show the sampled scene point cloud."
            },
            "showValidationPointCorrespondences": {
                "keyToolTip": "Display the corresponding relationship between the model point cloud and the scene point cloud."
            },
            "tranRangeX": {
                "infrequentlyUsed": true,
                "keyToolTip": "Translate initial poses within a certain range along the x-axis direction in the object coordinate frame.",
                "maximum": 100000,
                "minimum": 0,
                "name": "Translation Range on X Direction",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m",
                "valueToolTip": "The range is ±tranRangeX."
            },
            "tranRangeY": {
                "infrequentlyUsed": true,
                "keyToolTip": "Translate initial poses within a certain range along the y-axis direction in the object coordinate frame.",
                "maximum": 100000,
                "minimum": 0,
                "name": "Translation Range on Y Direction",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m",
                "valueToolTip": "The range is ±tranRangeY."
            },
            "tranStep": {
                "infrequentlyUsed": true,
                "keyToolTip": "The translation distance for the single step.",
                "maximum": 100000,
                "minimum": 0,
                "name": "Translation Step",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "validationSearchRadius": {
                "keyToolTip": "The searching radius is used to calculate the confidence.",
                "minimum": 0,
                "name": "Search Radius",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "weightOfEachPoint": {
                "keyToolTip": "The weight of each point in the weight file.\nThe higher the value is, the better the matching result of the model fragments tends to be."
            },
            "wholeScene": {
                "infrequentlyUsed": true,
                "keyToolTip": "Estimate poses of multiple objects existing in each input point cloud."
            }
        }
    },
    "mmind::StepFineRegistrationMultiTemplate": {
        "icon_name": "3D Fine Matching",
        "keywords": "Fine Registration Multi Template"
    },
    "mmind::StepFlipAxisDirection": {
        "groupInfos": {
            "Axis Settings": [
                "axisType",
                "directionType",
                "rotateByAxis"
            ]
        },
        "icon_name": "Flip Poses' Axes",
        "keywords": "Flip Axis Direction",
        "properties": {
            "axisType": {
                "keyToolTip": "Choose the axis to flip.",
                "name": "Axis to Flip"
            },
            "directionType": {
                "keyToolTip": "Positive means adjusting an axis of the pose to the positive direction on an axis of the world reference frame. Only axes whose included angle with the positive direction of the world reference frame’s axis is greater than 90° will be adjusted.\nNegative means adjusting an axis of the pose to the negative direction on an axis of the world reference frame. Only axes whose included angle with the negative direction of the world reference frame’s axis is greater than 90° will be adjusted.\nFor example if Axis to Flip is set to Z and Direction is set to Negative in the parameters, poses whose Z axes have included angles less than 90° with the Z-axis of the world reference frame will not be adjusted, those with such included angles greater than 90° will be flipped 180° around the reference axis set by the parameter Reference Axis to Rotate Around."
            },
            "rotateByAxis": {
                "keyToolTip": "Choose the axis to rotate around.",
                "name": "Reference Axis to Rotate Around"
            }
        },
        "subgroup": "Adjust Orientation"
    },
    "mmind::StepGeneralReadImage": {
        "icon_name": "Read Images",
        "keywords": "measure",
        "properties": {
            "filePathType": {
                "keyToolTip": "Image name as string.",
                "name": "Image Name Type",
                "valueToolTip": "Complete Path: the absolute path to the file;\nFile Name: the full name of the file, including extension;\nBase Name: the base name consists of all characters in the file up to (but not including) the first '.' character.\n\nExample: \"D:/data/project.tar.gz\"\nComplete Path: \"D:/data/project.tar.gz\"\nFile Name: \"project.tar.gz\" \nBase Name: \"project\""
            },
            "imageFilePath": {
                "keyToolTip": "Image file path.",
                "stringFileFilter": "Images (*.png *.jpg *.bmp)",
                "subtype": 2,
                "valueToolTip": "image file path"
            },
            "imageFolderPath": {
                "keyToolTip": "Image folder path.",
                "subtype": 1,
                "valueToolTip": "This is a directory path."
            },
            "imageFormat": {
                "keyToolTip": "Only applicable when \"fromFile\" is false.\nLoad images of selected image format from image directory.",
                "valueToolTip": "Supported image formats."
            },
            "imageSource": {
                "keyToolTip": "Load one image from file, or load all the images in a folder.",
                "valueToolTip": "File: image from file;\nDir: image from directory."
            },
            "parseAsDepthImage": {
                "keyToolTip": "Only applicable when \"imageFormat\" is \"PNG\".\nSome of the image formats can be parsed as depth image, \"PNG\" in Mech-Vision case.",
                "valueToolTip": "true: parse images as depth image;\nfalse: parse images as regular image."
            },
            "playMode": {
                "keyToolTip": "Only applicable when \"fromFile\" is false, and \"readAll\" is false.\nThis property manages the way to load images from folder.",
                "valueToolTip": "Normal: load image ordered by file name, and end on last image;\nRepeatOne: load current image repeatedly;\nRepeatAll: load image ordered by file name repeatedly, and never end;\nShuffle: load image by random order."
            },
            "readAll": {
                "keyToolTip": "Only applicable when \"fromFile\" is false.\nLoad all the images of selected image format from image directory.",
                "valueToolTip": "true: load all the supported images from image directory, and output as a bundle;\nfalse: load all the supported image one by one from image directory, and output as a single image."
            }
        },
        "subgroup": "Read"
    },
    "mmind::StepGeneralReadPointCloud": {
        "icon_name": "Read Point Cloud",
        "keywords": "measure",
        "properties": {
            "fileName": {
                "subtype": 2,
                "valueToolTip": "The file path of the point cloud"
            },
            "folderPath": {
                "subtype": 1,
                "valueToolTip": "The directory containing point clouds."
            },
            "pointCloudSource": {
                "valueToolTip": "File: point cloud from file;\nDir: point cloud from directory."
            }
        },
        "subgroup": "Read"
    },
    "mmind::StepGenerateAndCheckOffsetPoses": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Object Dimensions Settings": [
                "yParallelToLongSide",
                "objectLength",
                "objectWidth",
                "diffThre",
                "expandRatioForOriginRange"
            ],
            "Offset Translation Settings": [
                "offsetX",
                "offsetY",
                "offsetZ"
            ]
        },
        "infrequentlyUsed": true,
        "keywords": "Generate And Check Offset Poses",
        "properties": {
            "diffThre": {
                "name": "Max Dimension Difference"
            },
            "expandRatioForOriginRange": {
                "keyToolTip": "The range of expansion ratio, and the final range is: original range * (1 + expansion ratio)."
            },
            "objectLength": {
                "keyToolTip": "The length of object.",
                "minimum": 0,
                "subtype": 2,
                "suffix": "m"
            },
            "objectWidth": {
                "keyToolTip": "The width of object.",
                "minimum": 0,
                "subtype": 2,
                "suffix": "m"
            },
            "offsetX": {
                "keyToolTip": "The offset along the X-axis.",
                "name": "X",
                "subtype": 2,
                "suffix": "m"
            },
            "offsetY": {
                "keyToolTip": "The offset along the Y-axis.",
                "name": "Y",
                "subtype": 2,
                "suffix": "m"
            },
            "offsetZ": {
                "keyToolTip": "The offset along the Z-axis.",
                "name": "Z",
                "subtype": 2,
                "suffix": "m"
            },
            "symmetry": {
                "keyToolTip": "When generating an offset pose, the symmetry of the object pose.",
                "maximum": 360,
                "minimum": 0,
                "suffix": "°"
            }
        },
        "subgroup": "Generate Pose / Offset"
    },
    "mmind::StepGenerateCloud": {
        "groupInfos": {
            "Background Removal Settings": [
                "removeBackgroundByDepth",
                "depthBackgroundFileName",
                "backgroundDepthThres"
            ]
        },
        "icon_name": "From Depth Map to Point Cloud",
        "keywords": "Generate Cloud/measure",
        "properties": {
            "backgroundDepthThres": {
                "keyToolTip": "The background depth fluctuation threshold. Points with a depth difference from the background lower than this value will be eliminated",
                "minimum": 0,
                "name": "Variation of Background Depth",
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "depthBackgroundFileName": {
                "keyToolTip": "Background depth map file. Please click the edit button on the right side of the parameter to obtain the background depth map through the camera. Please remove the objects before taking pictures.",
                "name": "Depth Background Filename",
                "subtype": 4,
                "valueToolTip": "Set 2D Background"
            },
            "depthRoiFileName": {
                "keyToolTip": "ROI file of depth map. Please click the edit button to the right of the parameter to manually select the ROI.",
                "subtype": 4,
                "valueToolTip": "Set 2D ROI"
            },
            "removeBackgroundByDepth": {
                "keyToolTip": "Remove background. If selected, the input depth map will be compared with the background depth map, and the background with the depth difference within the fluctuation range will be removed.",
                "name": "Remove Background by Depth Image"
            }
        },
        "subgroup": "Supplement"
    },
    "mmind::StepGenerateCloudWall": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Cloud Wall Property": [
                "leafSize",
                "height"
            ],
            "Direction": [
                "x",
                "y",
                "z"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "height": {
                "maximum": 10,
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "leafSize": {
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            }
        }
    },
    "mmind::StepGenerateCylinderModel": {
        "groupInfos": {
            "Cylindrical Properties": [
                "diameter",
                "length",
                "leafSize"
            ]
        },
        "icon_name": "Generate Cylinder Point Cloud Model",
        "infrequentlyUsed": true,
        "keywords": "Generate Cylinder Model",
        "properties": {
            "diameter": {
                "keyToolTip": "The diameter of the created cylinders.",
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "leafSize": {
                "keyToolTip": "The distance between the points of the generated model.",
                "minimum": 0,
                "name": "Sampling Interval",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "length": {
                "keyToolTip": "The length of the created cylinders.",
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            }
        }
    },
    "mmind::StepGenerateDepthFromDisparity": {
        "developingType": true,
        "keywords": "convert/map",
        "subgroup": "Supplement"
    },
    "mmind::StepGenerateDepthROIZeroMask": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "subgroup": "ROI"
    },
    "mmind::StepGenerateEndFaceModel": {
        "groupInfos": {
            "Geometric Settings": [
                "innerRadius",
                "outerRadius",
                "startAngle",
                "endAngle"
            ],
            "Point Cloud Settings": [
                "normalVectorDirection",
                "centerZValue",
                "samplingInterval"
            ]
        },
        "icon_name": "Generate Point Cloud of Ring",
        "infrequentlyUsed": true,
        "keywords": "Create model/Generate End Face Model",
        "properties": {
            "centerZValue": {
                "keyToolTip": "The z-value of the generated point cloud.",
                "name": "Z-Value of Point Cloud",
                "singleStep": 0.01,
                "subtype": 2
            },
            "endAngle": {
                "decimals": 0,
                "keyToolTip": "The end angle of the ring.",
                "maximum": 360,
                "minimum": -360,
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            },
            "innerRadius": {
                "keyToolTip": "The inner radius of the ring.",
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "normalVectorDirection": {
                "keyToolTip": "The normal direction of the point cloud. \nPositive: The same direction as the positive direction of the Z-axis of the world coordinate system.\nNegative: The same direction as the direction of the Z-axis of the world coordinate system."
            },
            "outerRadius": {
                "keyToolTip": "The outer radius of the ring.",
                "maximum": 10,
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "samplingInterval": {
                "keyToolTip": "The distance between points in the point cloud.",
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "startAngle": {
                "decimals": 0,
                "keyToolTip": "The start angle of the ring.",
                "maximum": 360,
                "minimum": -360,
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            }
        }
    },
    "mmind::StepGenerateEndPointAndSendMotionParams": {
        "developingType": true,
        "groupInfos": {
            "Communication Settings": [
                "isSendMotionParams"
            ],
            "Custom Movement Settings": [
                "specialMotionType",
                "specialVel",
                "specialAcc",
                "specialBlendRadius"
            ],
            "End of Trajectory Points Setting": [
                "endPointMoveDis"
            ],
            "General Movement Settings": [
                "generalMotionType",
                "generalVel",
                "generalAcc",
                "generalBlendRadius"
            ],
            "Innermost Movement Settings": [
                "innermostMotionType",
                "innermostVel",
                "innermostAcc",
                "innermostBlendRadius"
            ],
            "Switching Contours Operation": [
                "isAccEarlier"
            ]
        },
        "subgroup": "Adjust Trajectory"
    },
    "mmind::StepGenerateModelCloud": {
        "groupInfos": {
            "Model Cloud Settings": [
                "useBoundary",
                "scale"
            ],
            "Template Image Property": [
                "horizontalFlipTemplateImage"
            ]
        },
        "icon_name": "Generate Point Cloud Model",
        "infrequentlyUsed": true,
        "keywords": "Generate Model Cloud/Create model",
        "properties": {
            "scale": {
                "keyToolTip": "The scaling ratio of input points.",
                "minimum": 0
            },
            "useBoundary": {
                "keyToolTip": "True: output boundary point clouds;\nFalse: output all points."
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepGeneratePickPoint": {
        "groupInfos": {
            "Image Settings": [
                "horizontalFlipTemplateImage"
            ],
            "Max Overlapping Area Search Settings": [
                "translateStep",
                "rotateStep"
            ],
            "Output Settins": [
                "candidateTopNum"
            ],
            "Pick Point Generation Settings": [
                "pickPointType"
            ],
            "Pick Point Settings": [
                "offsetAngle",
                "centerX",
                "centerY"
            ],
            "Scale Settings": [
                "scale"
            ],
            "Sucker Settings": [
                "suckerWidth",
                "suckerLength"
            ],
            "Threshold Settings": [
                "overlapRatioThresh"
            ]
        },
        "icon_name": "Generate Pick Points",
        "infrequentlyUsed": true,
        "properties": {
            "candidateTopNum": {
                "decimals": 0,
                "keyToolTip": "The max number of pick points.",
                "name": "Max Number of Pick Points",
                "singleStep": 1
            },
            "centerX": {
                "keyToolTip": "The x-coordinate of the pick point on the image.",
                "name": "X-Coordinate of Pick Point"
            },
            "centerY": {
                "keyToolTip": "The y-coordinate of the pick point on the image.",
                "name": "Y-Coordinate of Pick Point"
            },
            "horizontalFlipTemplateImage": {
                "keyToolTip": "Flip the template image horizontally.",
                "name": "Flip Template Image Horizontally"
            },
            "offsetAngle": {
                "decimals": 0,
                "keyToolTip": "The angle offset around the Z-axis of the image coordinate system.",
                "name": "Angle Offset of Pick Point",
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            },
            "overlapRatioThresh": {
                "keyToolTip": "The threshold of the overlap area ratio between the object mask and the effective area of the sucker mask. \nIf the overlap area ratio is less than this value, no pick point will be generated.",
                "name": "Overlap Ratio Threshold"
            },
            "pickPointType": {
                "keyToolTip": "The method for generating pick points.",
                "name": "Pick Point Generation Method",
                "valueToolTip": "InputByHand: Input the pick point by settings.\nMinimumBoundingRect: Calculate the pick points according to the bounding box of the template.\nMaximumOverlappingArea: Calculate the pick points according to the overlapping area of the template and the sucker."
            },
            "rotateStep": {
                "decimals": 4,
                "keyToolTip": "The step for rotating the sucker mask to find the maximum overlapping area between it and the object mask.",
                "name": "Rotation Step",
                "singleStep": 0.5,
                "subtype": 3,
                "suffix": "°"
            },
            "scale": {
                "keyToolTip": "The scaling ratio from the length in pixels to the actual length.",
                "minimum": 0
            },
            "suckerLength": {
                "keyToolTip": "The length of the rectangular sucker. This value is used to create a simulated sucker mask.",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "suckerWidth": {
                "keyToolTip": "The width of the rectangular sucker. This value is used to create a simulated sucker mask.",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "translateStep": {
                "keyToolTip": "The step for translating the sucker mask to find the maximum overlapping area between it and the object mask.",
                "name": "Translation Step",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            }
        },
        "subgroup": "Generate Pose / Offset"
    },
    "mmind::StepGenerateRectCandidates": {
        "icon_name": "Generate Rectangle Candidates",
        "infrequentlyUsed": true,
        "keywords": "Generate Rect Candidates",
        "subgroup": "Others"
    },
    "mmind::StepGenerateRectTraj": {
        "groupInfos": {
            "Accurate Corner Detection": [
                "calcAccurateCornerMethod",
                "fitLineDistType"
            ],
            "Corner Point Adjustment Settings": [
                "clockwiseTypeInRobotView"
            ],
            "Erosion Settings": [
                "leftSideErodeDis",
                "bottomSideErodeDis",
                "rightSideErodeDis",
                "topSideErodeDis"
            ],
            "Reliable Contour Points Settings": [
                "pointToLineMaxDis",
                "pointToCornerMaxDis",
                "onlyRectNearestContour",
                "incrementOfClosestToLineDis"
            ],
            "Robot Movement Settings": [
                "isSendMPsToViz",
                "cornerMotionType",
                "cornerVel",
                "cornerAcc",
                "cornerBlendRadius",
                "lineMotionType",
                "lineVel",
                "lineAcc",
                "lineBlendRadius"
            ],
            "Smoothing Settings": [
                "useContourSmooth",
                "contourSmoothGaussianFilterRadius",
                "contourSmoothGaussianFilterSigma"
            ],
            "Start Point Adjustment Settings": [
                "adjustStartPointByInputPose"
            ],
            "Trajectory Points (2D) Settings": [
                "allPointsInterval",
                "finalPointDisRedundanceRatio",
                "indentationNum",
                "linePointsInterval"
            ],
            "Trajectory Points (3D) Settings": [
                "neighbourDepthSearchSize",
                "usePointNormal"
            ]
        },
        "icon_name": "Generate Rect Traj",
        "infrequentlyUsed": true,
        "properties": {
            "adjustStartPointByInputPose": {
                "keyToolTip": "Adjust the position of the starting trajectory pose to the middle of the corresponding edge of the input reference point."
            },
            "allPointsInterval": {
                "keyToolTip": "The initial pix interval of all traj 2d points.",
                "suffix": "pixel"
            },
            "bottomSideErodeDis": {
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "clockwiseTypeInRobotView": {
                "keyToolTip": "Adjust the corner point clockwise."
            },
            "contourSmoothGaussianFilterRadius": {
                "singleStep": 1
            },
            "finalPointDisRedundanceRatio": {
                "keyToolTip": "Ratio of last two points interval redundancy to the \"allPointsInterval\"."
            },
            "fitLineDistType": {
                "keyToolTip": "Fit straight line to each side, and then find the intersection point between the straight lines as the accurate corner point."
            },
            "incrementOfClosestToLineDis": {
                "suffix": "pixel"
            },
            "indentationNum": {
                "keyToolTip": "The number of traj points between the end point of the line and the corner point."
            },
            "isSendMPsToViz": {
                "name": "Is Send M Ps to Mech-Viz"
            },
            "leftSideErodeDis": {
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "lineBlendRadius": {
                "infrequentlyUsed": false
            },
            "linePointsInterval": {
                "keyToolTip": "Use this value to regenerate line traj points.",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "pointToCornerMaxDis": {
                "keyToolTip": "Get contour points within this pixel distance from the approx rectangle corner.",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "pointToLineMaxDis": {
                "keyToolTip": "Get contour points within this pixel distance from the approx rectangle line.",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "rightSideErodeDis": {
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "topSideErodeDis": {
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "useContourSmooth": {
                "keyToolTip": "Smooth the good contour points."
            },
            "usePointNormal": {
                "keyToolTip": "Use point cloud normal as pose rotation."
            }
        },
        "subgroup": "Generate Trajectory"
    },
    "mmind::StepGenerateRingModel": {
        "developingType": true,
        "groupInfos": {
            "Circle Properties": [
                "radius"
            ],
            "Height Difference between Rings Properties": [
                "heightDif1",
                "heightDif2"
            ],
            "Ring 1 Properties": [
                "innerRadius1",
                "outerRadius1"
            ],
            "Ring 2 Properties": [
                "innerRadius2",
                "outerRadius2"
            ],
            "Ring 3 Properties": [
                "innerRadius3",
                "outerRadius3"
            ],
            "Ring Properties": [
                "innerRadius",
                "outerRadius"
            ]
        },
        "icon_name": "Create Object Model",
        "properties": {
            "heightDif1": {
                "keyToolTip": "The height difference between the 1st ring and the 2nd ring.",
                "minimum": 0,
                "name": "Difference between Ring 1 and Ring 2",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "heightDif2": {
                "keyToolTip": "The height difference between the 2nd ring and the 3rd ring.",
                "minimum": 0,
                "name": "Difference between Ring 2 and Ring 3",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "innerRadius": {
                "keyToolTip": "The radius of the inner circle in a ring.",
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "innerRadius1": {
                "keyToolTip": "The radius of the inner circle in the 1st ring.",
                "minimum": 0,
                "name": "Inner Radius",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "innerRadius2": {
                "keyToolTip": "The radius of the inner circle in the 2nd ring.",
                "minimum": 0,
                "name": "Inner Radius",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "innerRadius3": {
                "keyToolTip": "The radius of the inner circle in the 3rd ring.",
                "minimum": 0,
                "name": "Inner Radius",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "leafSize": {
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "outerRadius": {
                "keyToolTip": "The radius of the outer circle in a ring.",
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "outerRadius1": {
                "keyToolTip": "The radius of the outer circle in the 1st ring.",
                "minimum": 0,
                "name": "Outer Radius",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "outerRadius2": {
                "keyToolTip": "The radius of the outer circle in the 2nd ring.",
                "minimum": 0,
                "name": "Outer Radius",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "outerRadius3": {
                "keyToolTip": "The radius of the outer circle in the 3rd ring.",
                "minimum": 0,
                "name": "Outer Radius",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "radius": {
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            }
        }
    },
    "mmind::StepGenerateSpiralTraj": {
        "developingType": true,
        "groupInfos": {
            "Common Settings": [
                "contourRetrievalMode",
                "stopPixAreaThre",
                "nearestDistThreshold",
                "searchKernelSize",
                "sampleDis",
                "rotAngleAroundTrackDirection",
                "moveDisAlongZAxis",
                "lessRotAroundZAxis",
                "isOnlyGenerateOutermostTraj"
            ],
            "Inner Contour (1 to N)": [
                "innerContourErodeSize"
            ],
            "Innermost Contour (N)": [
                "innermostContourSlideOffset",
                "innermostPointsNum",
                "innermostStartPointMoveDis",
                "innermostEndPointMoveDis"
            ],
            "Middle Contour (1 to N-1)": [
                "middleContourSlideOffset"
            ],
            "Outermost Contour (0)": [
                "clockwiseType",
                "isLastJointAngleIncreasingWhenClockwise",
                "priorMoveLastJointAngle",
                "robotType"
            ],
            "outermost contour (0)": [
                "outermostContourDilateSize",
                "outermostContourErodeSize"
            ]
        },
        "properties": {
            "innermostEndPointMoveDis": {
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "innermostStartPointMoveDis": {
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "priorMoveLastJointAngle": {
                "decimals": 4,
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            },
            "sampleDis": {
                "singleStep": 1,
                "suffix": "pixel"
            }
        },
        "subgroup": "Generate Trajectory"
    },
    "mmind::StepGenerateTestCloud": {
        "developingType": true,
        "infrequentlyUsed": true
    },
    "mmind::StepGenerateTestImage": {
        "developingType": true,
        "infrequentlyUsed": true,
        "properties": {
            "height": {
                "minimum": 0,
                "suffix": "pixel"
            },
            "width": {
                "minimum": 0,
                "suffix": "pixel"
            }
        }
    },
    "mmind::StepGenerateTrackPointsInDepthImg": {
        "developingType": true,
        "groupInfos": {
            "Blending Settings": [
                "useBlend"
            ],
            "Corner Detection": [
                "qualityLevel",
                "minDistance",
                "maxCorners",
                "blockSize",
                "useHarrisDetector",
                "k",
                "cornerSubPixWinSize",
                "cornerSubPixMaxCount",
                "cornerSubPixEpsilon"
            ],
            "Corner Sorting Settings": [
                "StartPointStrategy",
                "ascend"
            ],
            "Depth Validation Settings": [
                "searchKernelSize"
            ],
            "Point Validation Settings": [
                "nearestDistThreshold"
            ],
            "Smoothing Settings": [
                "gaussianFilterRadius",
                "gaussianFilterSigma"
            ],
            "Trajectory Settings": [
                "erodeSize",
                "sampleDis",
                "finalPointDisRedundanceRatio",
                "usePointNormal",
                "erodeScale"
            ]
        },
        "keywords": "Generate Track Points In DepthImg",
        "properties": {
            "StartPointStrategy": {
                "name": "Pose Sorting Strategy",
                "valueToolTip": "SORT_BY_X: Sort the corners according to the X value of the corners.\nSORT_BY_Y: Sort the corners according to the Y value of the corners.\nSORT_BY_DIS2ORIGIN: Sort the corners according to the distance between the corners and the origin.\nNONE: No operation."
            },
            "ascend": {
                "name": "Ascending"
            },
            "blockSize": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "minimum": 2,
                "singleStep": 1
            },
            "cornerSubPixEpsilon": {
                "infrequentlyUsed": true,
                "minimum": 0,
                "name": "Sub-pixel Corner Accuracy"
            },
            "cornerSubPixMaxCount": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "minimum": 0,
                "name": "Sub-pixel Corner Extraction Iteration Num",
                "singleStep": 1
            },
            "cornerSubPixWinSize": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "minimum": 1,
                "name": "Sub-pixel Corner Extraction Window Size",
                "singleStep": 1
            },
            "erodeScale": {
                "infrequentlyUsed": true,
                "minimum": 0.0001,
                "name": "Erosion Scale"
            },
            "erodeSize": {
                "infrequentlyUsed": true,
                "keyToolTip": "Erode Size from outside contours.",
                "minimum": 0,
                "name": "Erosion Kernel Size",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "finalPointDisRedundanceRatio": {
                "infrequentlyUsed": true,
                "minimum": 0,
                "name": "Final Point Distance Redundancy Ratio"
            },
            "gaussianFilterRadius": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "minimum": 1,
                "name": "Filter Radius",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "gaussianFilterSigma": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "minimum": 1,
                "name": "Filter Standard Deviation",
                "singleStep": 1
            },
            "generatePointsMethod": {
                "name": "Trajectory Generation Method",
                "valueToolTip": "ByCorners: Detect the corners of the objects, and generate straight line trajectory passing by the corners.\nByContours: Detect the contours of the obeject and generate the trajectory along the contour.\nByContourAndCorner: Detcet both contours and corners, then, generate the trajectory along the contour and pass by the corners at the same time."
            },
            "k": {
                "infrequentlyUsed": true,
                "minimum": 0
            },
            "maxCorners": {
                "decimals": 0,
                "infrequentlyUsed": false,
                "keyToolTip": "Max corner number.",
                "minimum": 1,
                "name": "Max Corner Num",
                "singleStep": 1
            },
            "minDistance": {
                "minimum": 0,
                "name": "Min Corner Distance"
            },
            "nearestDistThreshold": {
                "infrequentlyUsed": true,
                "keyToolTip": "The distance threshold of searching adjacent point clouds.",
                "minimum": 0,
                "name": "Max Points Distance",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "qualityLevel": {
                "infrequentlyUsed": true,
                "minimum": 0.0001,
                "name": "Confidence"
            },
            "sampleDis": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "Sampling distance between track points.",
                "minimum": 1,
                "name": "Sample Distance",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "searchKernelSize": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The kernel size to search adjacent depth image.",
                "minimum": 1,
                "name": "Depth Search Radius",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "useBlend": {
                "infrequentlyUsed": true,
                "keyToolTip": "Use blend to make sure the corner will be arrived precisely .",
                "name": "Blend Trajectory"
            },
            "useHarrisDetector": {
                "infrequentlyUsed": true
            },
            "usePointNormal": {
                "infrequentlyUsed": true,
                "name": "Use Clouds Normals"
            }
        },
        "subgroup": "Generate Trajectory"
    },
    "mmind::StepGenerateTrajByContour": {
        "groupInfos": {
            "Find Corners": [
                "sampleSizeForCorner",
                "qualityLevel",
                "minDistance",
                "maxCorners",
                "blockSize",
                "useHarrisDetector",
                "k"
            ],
            "General Params": [
                "maskClosingKernalSize",
                "pointsSampleSize",
                "edgeZoomType",
                "erodeKernalSize",
                "verticalMoveRealDis"
            ],
            "Smooth Points": [
                "useGaussianFilter",
                "gaussianFilterRadius",
                "gaussianFilterSigma"
            ],
            "Special Side Erode": [
                "useSpecialSideErode",
                "intervalCalcTangent",
                "specialSideErodeRealDis"
            ]
        },
        "icon_name": "Generate Traj By Contour",
        "infrequentlyUsed": true,
        "properties": {
            "erodeKernalSize": {
                "suffix": "pixel"
            },
            "intervalCalcTangent": {
                "maximum": 100,
                "minimum": 1,
                "singleStep": 1
            },
            "maskClosingKernalSize": {
                "maximum": 99999,
                "minimum": 1,
                "singleStep": 1,
                "suffix": "pixel"
            },
            "specialSideErodeRealDis": {
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "verticalMoveRealDis": {
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            }
        },
        "subgroup": "Generate Trajectory"
    },
    "mmind::StepGenerateZigzagTraj": {
        "developingType": true,
        "groupInfos": {
            "Depth Searching Settings": [
                "nearestDistThreshold",
                "searchKernelSize"
            ],
            "First & Last Segment Operations": [
                "firstAndLastSegmentContourPointsNum",
                "startAndEndPointOffset"
            ],
            "Line Mid-point Settings": [
                "lineMiddlePointsNum"
            ],
            "Lines Interval Settings": [
                "intervalBetweenLines",
                "ratioThreOfRemainderDisToInterval"
            ],
            "Major Direction Setting": [
                "isLongSideAsMain"
            ],
            "Outermost Two Sides": [
                "outermostTwoSidesLineMoveDis",
                "outermostTwoSidesPointsMoveRatio"
            ],
            "Two Special Points": [
                "generateSpecialPointFromPriorPointDis"
            ],
            "Visualization Settings": [
                "fontScale"
            ]
        },
        "subgroup": "Generate Trajectory"
    },
    "mmind::StepGetFirstImg": {
        "deprecatedType": true,
        "infrequentlyUsed": true
    },
    "mmind::StepGetFlangePose": {
        "icon_name": "Get Flange Pose List",
        "infrequentlyUsed": true,
        "subgroup": "Pose"
    },
    "mmind::StepGetHighestDepth": {
        "groupInfos": {
            "Highest Layer Settings": [
                "layerHeightTolerance"
            ]
        },
        "icon_name": "Get Highest Areas in Depth Image",
        "properties": {
            "layerHeightTolerance": {
                "decimals": 6,
                "keyToolTip": "The height of the top layer.",
                "maximum": 2,
                "minimum": 1e-06,
                "name": "Layer Height",
                "singleStep": 0.01,
                "subtype": 2
            }
        },
        "subgroup": "Segment Area"
    },
    "mmind::StepGetHighestLayer": {
        "groupInfos": {
            "Layer Settings": [
                "onlyGetHighestOne",
                "layerHeight",
                "layerDiffTolerance"
            ],
            "Reference Direction": [
                "x",
                "y",
                "z"
            ]
        },
        "properties": {
            "layerDiffTolerance": {
                "keyToolTip": "if the distance from item to highest item smaller than Layer Height * Layer  Tolerance, it belong to highest layer.",
                "maximum": 1,
                "minimum": 0,
                "name": "Layer Tolerance (0.0 ~ 1.0)"
            },
            "layerHeight": {
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "onlyGetHighestOne": {
                "keyToolTip": "If true, get highest item in descending order along reference direction, otherwise get items in highest layer."
            },
            "x": {
                "keyToolTip": "X value of reference direction"
            },
            "y": {
                "keyToolTip": "Y value of reference direction"
            },
            "z": {
                "keyToolTip": "Z value of reference direction"
            }
        }
    },
    "mmind::StepGetHighestLayerClouds": {
        "groupInfos": {
            "Cloud Settings": [
                "useMaxSizeCloudNormal",
                "maxSizeCloudNormalZDir"
            ]
        },
        "icon_name": "Get Highest Layer Clouds",
        "properties": {
            "maxSizeCloudNormalZDir": {
                "infrequentlyUsed": true,
                "keyToolTip": "Specified maxSizeCloudNormalZDir to the positive or negative direction in the current coordinate."
            },
            "useMaxSizeCloudNormal": {
                "keyToolTip": "Use max size cloud normal as the reference direction."
            }
        },
        "subgroup": "Validate and Get Clouds"
    },
    "mmind::StepGetHighestLayerPoints": {
        "icon_name": "Get Highest Layer Points",
        "infrequentlyUsed": true,
        "subgroup": "Validate and Get Clouds"
    },
    "mmind::StepGetHighestLayerPoses": {
        "groupInfos": {
            "Visualization Settings": [
                "showCloudInSceneType",
                "showPosesType"
            ]
        },
        "icon_name": "Get Highest Layer Poses",
        "infrequentlyUsed": true,
        "properties": {
            "showCloudInSceneType": {
                "name": "Show Cloud Under Chosen Coordinate"
            },
            "showPosesType": {
                "infrequentlyUsed": true,
                "name": "Pose Visuals Setting"
            }
        },
        "subgroup": "Collect / Remove"
    },
    "mmind::StepGetHighestScoreResult": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "properties": {
            "scoreThre": {
                "keyToolTip": "Out put result only when the score of result greater than scoreThre."
            }
        }
    },
    "mmind::StepGetNRandomPoses": {
        "developingType": true,
        "infrequentlyUsed": true,
        "keywords": "Get N Random Poses",
        "properties": {
            "depthSearchRadius": {
                "keyToolTip": "Calculate the average depth around the random pick point.",
                "maximum": 999,
                "minimum": 1,
                "singleStep": 1,
                "suffix": "mm"
            },
            "numOfPoses": {
                "maximum": 100000,
                "minimum": 1,
                "singleStep": 1
            },
            "useCache": {
                "keyToolTip": "Usually set to true when user want to check the visualization. Set to false by default."
            }
        },
        "subgroup": "Generate Pose / Offset"
    },
    "mmind::StepGetValidClouds": {
        "groupInfos": {
            "Clustering Settings": [
                "clusterTolerance",
                "minClusterNum",
                "mainCloudRatio"
            ]
        },
        "icon_name": "Cluster Point Clouds and Output Eligible Point Clouds",
        "keywords": "Get Valid Clouds/filter",
        "properties": {
            "clusterTolerance": {
                "keyToolTip": "The maximum distance between the points in the same cluster.",
                "minimum": 0,
                "name": "Max Distance of Neighbouring Points",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "mainCloudRatio": {
                "keyToolTip": "Fro a point cloud, if the ratio of points in largest cluster to all points is bigger than this value, the point cloud will be cocnsidered as valid.",
                "maximum": 1,
                "minimum": 0,
                "name": "Min Ratio of Points in Largest Cluster to All Points (0 ~ 1.0)",
                "singleStep": 0.1
            },
            "minClusterNum": {
                "decimals": 0,
                "keyToolTip": "The minimum number of points number for a valid cluster.",
                "minimum": 0,
                "name": "Minimum Number of Points",
                "singleStep": 10
            }
        },
        "subgroup": "Cluster"
    },
    "mmind::StepGetValidRingClouds": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Clustering": [
                "clusterTolerance",
                "minClusterNum",
                "maxClusterNum"
            ],
            "Distance Thresholding": [
                "distanceFromHighestZ"
            ],
            "Reference Direction": [
                "useAutoMainNormal",
                "main_normal_x",
                "main_normal_y",
                "main_normal_z"
            ],
            "Ring Mask Processing Settings": [
                "dilateSize",
                "erodeSize"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "clusterTolerance": {
                "keyToolTip": "The spatial cluster tolerance as a measure in the L2 Euclidean space."
            },
            "dilateSize": {
                "minimum": 0,
                "singleStep": 1
            },
            "distanceFromHighestZ": {
                "keyToolTip": "Points are considiered valid if distance to the highest point along the set main direction is smaller than this value."
            },
            "erodeSize": {
                "minimum": 0,
                "singleStep": 1
            },
            "maxClusterNum": {
                "keyToolTip": "The maximum number of points that a cluster needs to contain in order to be considered valid.",
                "minimum": 0,
                "singleStep": 10
            },
            "minClusterNum": {
                "keyToolTip": "The minimum number of points that a cluster needs to contain in order to be considered valid.",
                "minimum": 0,
                "singleStep": 10
            }
        },
        "subgroup": "Validate and Get Clouds"
    },
    "mmind::StepGraspPlaceEstimation": {
        "groupInfos": {
            "Advanced Settings": [
                "collisionThresh",
                "samplePoints"
            ],
            "Bin Settings": [
                "binLength",
                "binWidth",
                "binHeight",
                "useBinSetting"
            ],
            "Placement Method": [
                "offsetZ",
                "safetyGap",
                "placeByDrop"
            ],
            "Visualization": [
                "developerMode"
            ],
            "Working Distance": [
                "cameraToPickAreaMin",
                "cameraToPickAreaMax"
            ]
        },
        "icon_name": "Placement Estimation",
        "properties": {
            "binHeight": {
                "decimals": 0,
                "maximum": 1500,
                "minimum": 30,
                "name": "Height",
                "singleStep": 1,
                "suffix": "mm"
            },
            "binLength": {
                "decimals": 0,
                "maximum": 1500,
                "minimum": 30,
                "name": "Length",
                "singleStep": 1,
                "suffix": "mm"
            },
            "binWidth": {
                "decimals": 0,
                "maximum": 1500,
                "minimum": 30,
                "name": "Width",
                "singleStep": 1,
                "suffix": "mm"
            },
            "cameraToPickAreaMax": {
                "decimals": 0,
                "maximum": 3000,
                "minimum": 0,
                "name": "Maximum Working Distance",
                "showSlider": false,
                "singleStep": 1,
                "suffix": "mm",
                "valueToolTip": "The longest distance between the camera and the object(s) in the scene. If using a bin, please set this parameter to the distance between the camera bottom to the bottom sides of the bin."
            },
            "cameraToPickAreaMin": {
                "decimals": 0,
                "maximum": 3000,
                "minimum": 0,
                "name": "Minimum Working Distance",
                "showSlider": false,
                "singleStep": 1,
                "suffix": "mm",
                "valueToolTip": "The shortest distance between the camera and the object(s) in the scene. If using a bin, please set this parameter to the distance between the camera bottom to the top sides of the bin."
            },
            "collisionThresh": {
                "decimals": 3,
                "infrequentlyUsed": true,
                "maximum": 0.02,
                "minimum": 0.001,
                "name": "Collision Threshold",
                "notEditable": false,
                "singleStep": 0.001
            },
            "developerMode": {
                "name": "Enable",
                "valueToolTip": "Enabling the visualization will reduce the project’s running speed."
            },
            "offsetZ": {
                "decimals": 1,
                "maximum": 500,
                "minimum": 0,
                "name": "Upward Offset along Z-Axis",
                "singleStep": 1,
                "suffix": "mm",
                "valueToolTip": "Add an upward offset to the planned poses at placement to prevent squeezing."
            },
            "placeByDrop": {
                "name": "Allow Placing by Dropping",
                "valueToolTip": "If this parameter is checked, the output poses will be planned on the bin’s top plane, and will be offset upward depending on the setting of the parameter \\\"Upward Offset along Z-Axis\\\"."
            },
            "safetyGap": {
                "decimals": 1,
                "maximum": 50,
                "minimum": 0,
                "name": "Object Safety Gap",
                "singleStep": 1,
                "suffix": "mm",
                "valueToolTip": "Safety Gap between Objects"
            },
            "samplePoints": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "maximum": 20480,
                "minimum": 5120,
                "notEditable": false,
                "singleStep": 1
            },
            "useBinSetting": {
                "infrequentlyUsed": true,
                "notEditable": false
            }
        },
        "subgroup": "Novel Objects Picking"
    },
    "mmind::StepGraspPointPredictor": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Depth Normalization Settings": [
                "depthRefPercentile",
                "globalMean"
            ],
            "Gripper Settings": [
                "gripperType"
            ],
            "Output Settings": [
                "outputWidth",
                "outputHeight",
                "gaussianKSize",
                "gaussianSigma"
            ],
            "Parallel Jaw Settings": [
                "visArrowThre",
                "rotationClassNum"
            ],
            "Prediction Method Settings": [
                "methodType"
            ],
            "Visualization Settings": [
                "showProcessedDepth"
            ]
        },
        "infrequentlyUsed": true,
        "keywords": "Grasp Point Predictor",
        "properties": {
            "depthRefPercentile": {
                "infrequentlyUsed": true,
                "keyToolTip": "Manipulate the preprocess parameter this value in the deep learning server.",
                "maximum": 100,
                "minimum": 0,
                "suffix": "th"
            },
            "gaussianKSize": {
                "infrequentlyUsed": true,
                "keyToolTip": "The gaussian filter's kernel size used to smooth heat map.",
                "maximum": 999,
                "minimum": 3,
                "name": "Gaussion Kernel Size",
                "singleStep": 2
            },
            "gaussianSigma": {
                "decimals": 2,
                "infrequentlyUsed": true,
                "keyToolTip": "The gaussian filter's standard deviation used to smooth the heat map.",
                "minimum": 0,
                "name": "Gaussian Standard Deviation",
                "singleStep": 0.1
            },
            "globalMean": {
                "infrequentlyUsed": true,
                "keyToolTip": "Manipulate the preprocess parameter this value in the deep learning server.",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "gripperType": {
                "valueToolTip": "SuctionCup: The suction cup.\nParallelJaw:  The parallel jaw."
            },
            "methodType": {
                "infrequentlyUsed": true,
                "name": "Prediction Method"
            },
            "outputHeight": {
                "keyToolTip": "The height of the output heat map.",
                "minimum": 1,
                "name": "Height",
                "suffix": "pixel"
            },
            "outputWidth": {
                "keyToolTip": "The width of the output heat map.",
                "minimum": 1,
                "name": "Width",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "rotationClassNum": {
                "keyToolTip": "The number of classes of the rotation in the deep learning model.",
                "name": "Rotation Class Number"
            },
            "showProcessedDepth": {
                "infrequentlyUsed": true,
                "keyToolTip": "Checked to command the deep learning server to visualize the processed depth image. \nOnly effective in Debug mode."
            },
            "visArrowThre": {
                "keyToolTip": "Only works when the gripper type is ParallelJaw. Grasp orientaion about Z axis will be visualized at positions where the probability of success is higher than this threshold.",
                "name": "Visualization Threshold"
            }
        },
        "subgroup": "Novel Objects Picking"
    },
    "mmind::StepGraspPoseEstimation": {
        "groupInfos": {
            "Bin Settings": [
                "useBinSetting",
                "binLength",
                "binWidth"
            ],
            "Contour Detection (Smart Placement, Special Shape)": [
                "objectSizePath",
                "estimateSingleObjectSize",
                "contourPrior",
                "contourModelPath",
                "contourDetection"
            ],
            "Grasp-Pose Estimation": [
                "poseModelPath",
                "usePoseEstimator"
            ],
            "Mask Pre-process": [
                "useSmartFilter",
                "maskPointCluster"
            ],
            "Overlap Detection": [
                "overlapModelPath",
                "overlapDetection",
                "maxOverlapInstance"
            ],
            "Picking Settings": [
                "pickingMethod"
            ],
            "Pose Post-process": [
                "adjustZ",
                "adjustPose",
                "maxPoses"
            ],
            "Pose Sort Logic": [
                "objectDiagonalLen",
                "poseDirection",
                "suctionCupDiameter",
                "poseHeight"
            ],
            "Special Shape Filter": [
                "shortestFilter",
                "shortestBound",
                "longestFilter",
                "longestBound"
            ],
            "Sucker Configuration": [
                "sizeSegmentOne",
                "lengthSegmentOne",
                "objectSizeSegment",
                "objectLengthSegment",
                "sizeSegmentTwo",
                "usePositionInfo"
            ],
            "Visualization": [
                "developerMode",
                "showType",
                "showGraspType"
            ],
            "Working Distance": [
                "cameraToPickAreaMin",
                "cameraToPickAreaMax"
            ]
        },
        "icon_name": "Grasp Pose Estimation",
        "properties": {
            "adjustPose": {
                "infrequentlyUsed": true,
                "name": "Adjust Pose by Object Size",
                "notEditable": false,
                "required": false,
                "valueToolTip": "Enable this will make the pose's x-axis points to the long side of the object."
            },
            "adjustZ": {
                "decimals": 1,
                "infrequentlyUsed": true,
                "maximum": 10,
                "minimum": 0,
                "name": "Raise Place Z-axis",
                "notEditable": false,
                "required": false,
                "showSlider": true,
                "singleStep": 0.1,
                "subtype": 0,
                "suffix": "mm",
                "valueToolTip": "Add an upward offset to the grasp poses to prevent squeezing products."
            },
            "binLength": {
                "decimals": 0,
                "maximum": 1500,
                "minimum": 100,
                "name": "Length",
                "singleStep": 1,
                "subtype": 0,
                "suffix": "mm"
            },
            "binWidth": {
                "decimals": 0,
                "maximum": 1500,
                "minimum": 100,
                "name": "Width",
                "singleStep": 1,
                "subtype": 0,
                "suffix": "mm"
            },
            "cameraToPickAreaMax": {
                "decimals": 0,
                "maximum": 3000,
                "minimum": 0,
                "name": "Maximum Working Distance",
                "showSlider": false,
                "singleStep": 1,
                "subtype": 0,
                "suffix": "mm",
                "valueToolTip": "The longest distance between the camera and the object(s) in the scene. If using a bin, please set this parameter to the distance between the camera bottom to the bottom sides of the bin."
            },
            "cameraToPickAreaMin": {
                "decimals": 0,
                "maximum": 3000,
                "minimum": 0,
                "name": "Minimum Working Distance",
                "showSlider": false,
                "singleStep": 1,
                "subtype": 0,
                "suffix": "mm",
                "valueToolTip": "The shortest distance between the camera and the object(s) in the scene. If using a bin, please set this parameter to the distance between the camera bottom to the top sides of the bin."
            },
            "contourDetection": {
                "valueToolTip": "Object contour detection."
            },
            "contourModelPath": {
                "stringFileFilter": "(*.pth;*.engine)",
                "subtype": 2
            },
            "contourPrior": {
                "infrequentlyUsed": true,
                "notEditable": false,
                "required": false
            },
            "developerMode": {
                "name": "Enable",
                "valueToolTip": "Enabling the visualization will reduce the project’s running speed."
            },
            "lengthSegmentOne": {
                "decimals": 1,
                "maximum": 200,
                "minimum": 0,
                "name": "Short/Long",
                "showSlider": true,
                "singleStep": 0.1,
                "subtype": 0,
                "suffix": "mm",
                "valueToolTip": "When the length of the detected object is greater than this value, the suction cup label is given as <Long>, otherwise it is <Short>."
            },
            "longestBound": {
                "decimals": 0,
                "maximum": 1500,
                "minimum": 0,
                "name": "Object Longest Side >",
                "showSlider": true,
                "singleStep": 1,
                "suffix": "mm",
                "valueToolTip": "Object the longest side longer than this value will be eliminated."
            },
            "longestFilter": {
                "name": "Object Long Side Filter",
                "valueToolTip": "Filter according to the longest side of the object"
            },
            "maskPointCluster": {
                "infrequentlyUsed": true,
                "name": "Mask Point Cloud Cluster",
                "notEditable": false,
                "required": false,
                "valueToolTip": "When set as 'True' improves the accuracy of the object's detection poses but reduces the project efficiency."
            },
            "maxOverlapInstance": {
                "decimals": 0,
                "maximum": 10,
                "minimum": 1,
                "showSlider": true,
                "singleStep": 1
            },
            "maxPoses": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "maximum": 20,
                "minimum": 3,
                "notEditable": false,
                "required": false,
                "showSlider": true,
                "singleStep": 0,
                "valueToolTip": "Mech-Vision software outputs the maximum number of poses."
            },
            "objectDiagonalLen": {
                "decimals": 0,
                "infrequentlyUsed": false,
                "maximum": 3,
                "minimum": 0,
                "name": "Object Length Weight",
                "singleStep": 1
            },
            "objectLengthSegment": {
                "singleStep": 0
            },
            "objectSizePath": {
                "stringFileFilter": "(*.json)",
                "subtype": 2
            },
            "objectSizeSegment": {
                "singleStep": 0
            },
            "overlapModelPath": {
                "name": "Overlap Detection Model Path",
                "stringFileFilter": "(*.pth;*.engine)",
                "subtype": 2
            },
            "pickingMethod": {
                "infrequentlyUsed": true,
                "singleStep": 0
            },
            "poseDirection": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "maximum": 3,
                "minimum": 0,
                "name": "Pose Direction Weight",
                "notEditable": false,
                "required": false,
                "singleStep": 1
            },
            "poseHeight": {
                "decimals": 0,
                "infrequentlyUsed": false,
                "maximum": 3,
                "minimum": 1,
                "name": "Pose Height Weight",
                "singleStep": 1
            },
            "poseModelPath": {
                "name": "Grasp Pose Estimation Model Path",
                "stringFileFilter": "(*.pth)",
                "subtype": 2
            },
            "shortestBound": {
                "decimals": 0,
                "maximum": 1500,
                "minimum": 0,
                "name": "Object Shortest Side <",
                "showSlider": true,
                "singleStep": 1,
                "suffix": "mm",
                "valueToolTip": "Object the shortest side shorter than this value will be eliminated."
            },
            "shortestFilter": {
                "name": "Object Short Side Filter",
                "valueToolTip": "Filter according to the shortest side of the object"
            },
            "showType": {
                "name": "Visualization Type",
                "valueToolTip": "The red number indicates the first sort object."
            },
            "sizeSegmentOne": {
                "decimals": 1,
                "maximum": 200,
                "minimum": 0,
                "name": "small",
                "showSlider": true,
                "singleStep": 0.1,
                "subtype": 0,
                "suffix": "mm"
            },
            "sizeSegmentTwo": {
                "decimals": 1,
                "maximum": 200,
                "minimum": 0,
                "name": "large",
                "showSlider": true,
                "singleStep": 0.1,
                "subtype": 0,
                "suffix": "mm"
            },
            "suctionCupDiameter": {
                "decimals": 0,
                "maximum": 3,
                "minimum": 0,
                "name": "Suction Cup Size Weight",
                "singleStep": 1
            },
            "useBinSetting": {
                "name": "Use Bin",
                "valueToolTip": "(Enable) The position of the object in the bin can be identified."
            },
            "usePoseEstimator": {
                "infrequentlyUsed": true,
                "name": "Deep Learning Method",
                "notEditable": false,
                "required": false,
                "valueToolTip": "If True, enable deep learning pose estimator, otherwise enable traditional method."
            },
            "usePositionInfo": {
                "infrequentlyUsed": true,
                "notEditable": false,
                "required": false
            },
            "useSmartFilter": {
                "infrequentlyUsed": true,
                "name": "Mask Smart Filter",
                "notEditable": false,
                "required": false,
                "valueToolTip": "Smart mask filtering is recommended when there are more objects in the scene. (The number of objects is greater than 15)."
            }
        },
        "subgroup": "Novel Objects Picking"
    },
    "mmind::StepGroup": {
        "icon_name": "Group Data",
        "infrequentlyUsed": true,
        "keywords": "convert/map",
        "subgroup": "Arrange by Index"
    },
    "mmind::StepGroupPose2d": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "keywords": "convert/map/Group Pose2d/",
        "subgroup": "2D Pose"
    },
    "mmind::StepHasPoseWithinMask": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "subgroup": "Validate Masks by Poses"
    },
    "mmind::StepHdevEngine": {
        "groupInfos": {
            "Debugging Settings": [
                "onlineDebugging"
            ],
            "Input Settings": [
                "inputPortsDesc",
                "inputCtrlVarNames",
                "inputIconicVarNames"
            ],
            "Output Settings": [
                "outputCtrlVarNames",
                "outputIconicVarNames",
                "outputPortsDesc"
            ],
            "Program Settings": [
                "hDevProgramPath",
                "extProcedurePath",
                "procedureName"
            ]
        },
        "infrequentlyUsed": true,
        "keywords": "hdev/halcon/engine",
        "properties": {
            "extProcedurePath": {
                "name": "External Procedure Folder",
                "subtype": 1
            },
            "hDevProgramPath": {
                "name": "hDev Program Path",
                "stringFileFilter": "*.hdev",
                "subtype": 2
            },
            "procedureName": {
                "name": "Procedure Name",
                "subtype": 3
            }
        },
        "subgroup": "Script Engine"
    },
    "mmind::StepHistogramMatcher": {
        "deprecatedType": true,
        "developingType": true
    },
    "mmind::StepImageShow": {
        "icon_name": "Show Images",
        "keywords": "image show/measure/",
        "properties": {
            "displayType": {
                "valueToolTip": "MultiImges: Show images.\nImgAndPolyVerts: Show images and polygon candidates."
            }
        }
    },
    "mmind::StepImageTypeConvert": {
        "icon_name": "Convert Image Type",
        "infrequentlyUsed": true,
        "keywords": "Image Type Convert",
        "properties": {
            "scaleFactor": {
                "infrequentlyUsed": true,
                "keyToolTip": "Currently only applied to heatmap related conversions."
            }
        },
        "subgroup": "Color Image Processing"
    },
    "mmind::StepImgBalancer": {
        "groupInfos": {
            "Balancer Settings": [
                "balancerType"
            ]
        },
        "icon_name": "Image Brightness and Color Balancer",
        "keywords": "img balancer/balancing",
        "properties": {
            "balancerType": {
                "keyToolTip": "Choose the type of the balancer.",
                "valueToolTip": "AdaptiveColorBalancer: Balance the RGB color automatically.\nCLAHE: Increase the contrast the image.\nColorBalancer: Adjust the image color from Lab space. L* for the lightness from black to white, a* from green to red, and b* from blue to yellow.\nGammaCorrection: Increase or decrease the brighness of the image.\nIllumination Normalization: Normalize the illuminarion of the image."
            }
        },
        "subgroup": "Color Image Processing"
    },
    "mmind::StepImgFilter": {
        "icon_name": "Image Filtering",
        "infrequentlyUsed": true,
        "keywords": "Img Filter",
        "properties": {
            "filterType": {
                "keyToolTip": "Choose a filter to smooth the image and remove the noise.",
                "valueToolTip": "ConditionalMeanFilter: Usually used to smooth the depth image to get a better point clouds.\nGaussianFilter: Usually used to remove the background noise in color images."
            }
        },
        "subgroup": "Color Image Processing"
    },
    "mmind::StepImgLogicalOperator": {
        "groupInfos": {
            "Operation Settings": [
                "logicalOperator"
            ],
            "Usage Settings of Input Masks": [
                "mappingType"
            ]
        },
        "icon_name": "Mask Logical Operation",
        "keywords": "and/or/not/xor",
        "properties": {
            "logicalOperator": {
                "keyToolTip": "Choose the bitwise logical operator for the mask. If Not is selected, the operation is only performed on masks0. Otherwise, the operation is performed on both mask vectors.",
                "name": "Logical Operation"
            },
            "mappingType": {
                "name": "Correspondence Type",
                "valueToolTip": "OneToOne: Use all the mask of the second input.\nFirstToAll: Only use the first mask of the second input."
            }
        },
        "subgroup": "Mask Logical Operation"
    },
    "mmind::StepImgSegment": {
        "icon_name": "Binarize Image",
        "keywords": "Img Segment/Segment Color Image/Gray/measure",
        "properties": {
            "segmentType": {
                "keyToolTip": "“AdaptiveThreshold”: global adaptive threshold “Threshold”: global fixed threshold"
            }
        },
        "subgroup": "Segment Area"
    },
    "mmind::StepImgTransformer": {
        "icon_name": "Image Transform",
        "infrequentlyUsed": true,
        "keywords": "Img Transformer",
        "properties": {
            "transformerType": {
                "name": "Transform Type",
                "valueToolTip": "ImgRectify: Rectify the image with the camera intrinsic parameters.\nImgResize: Resize the image."
            }
        },
        "subgroup": "Image Transform"
    },
    "mmind::StepInputSplitter": {
        "icon_name": "Allocator",
        "keywords": "Input Splitter/measure",
        "subgroup": "Step IO"
    },
    "mmind::StepInscribedCircleDetector": {
        "groupInfos": {
            "Detection Settings": [
                "maxNumberOfDetectedCircles",
                "expandedRatioOfCircleRadius",
                "ratioOfFirstCircleRadius",
                "minInscribedCircleRadius"
            ]
        },
        "icon_name": "Detect Inscribed Circles",
        "infrequentlyUsed": true,
        "keywords": "Inscribed Circle Detector",
        "properties": {
            "expandedRatioOfCircleRadius": {
                "keyToolTip": "When a contour contains more than one circle, the area of the detected inscribed circle needs to be reduced from the mask for detecting others.\nTo do so, the size of the detected inscribed circle needs to be slightly enlarged using this value.",
                "maximum": 1,
                "minimum": 0,
                "name": "Expanded Ratio of Circle Radius (0 ~1.0)",
                "singleStep": 0.1
            },
            "maxNumberOfDetectedCircles": {
                "keyToolTip": "The maximum number of detected circles.",
                "minimum": 0
            },
            "minInscribedCircleRadius": {
                "keyToolTip": "The minimum radius of detected circles.",
                "minimum": 0,
                "suffix": "pixel"
            },
            "ratioOfFirstCircleRadius": {
                "keyToolTip": "When a contour contains more than one circle, this value will be used. \nIf the radius ratio of an inscribed circle to the biggest inscribed circle is smaller than this value, this inscribed circle will be eliminated.",
                "maximum": 10,
                "minimum": 0,
                "singleStep": 0.1
            }
        },
        "subgroup": "Circle"
    },
    "mmind::StepInstanceSegmentator": {
        "deprecatedType": true,
        "groupInfos": {
            "Acceptable Mean for Gray-scaled Input": [
                "minAverageGrayValue",
                "maxAverageGrayValue"
            ],
            "Filtering Settings": [
                "filterEdgeWorkpiece",
                "widthThres",
                "heightThres",
                "displayBoundingBox",
                "filterOverlappingObjectInstances",
                "maxOverlapRatio"
            ],
            "Visualization Settings": [
                "drawInstanceOnImage",
                "colorScheme"
            ]
        },
        "icon_name": "Instance Segmentation",
        "infrequentlyUsed": true,
        "keywords": "mask/measure",
        "properties": {
            "colorScheme": {
                "infrequentlyUsed": false,
                "keyToolTip": "Select the color scheme.",
                "name": "Way of Object Visualization",
                "valueToolTip": "Threshold: According to the confidence. If the calculated threshold is larger than the threshold, the corresponding instance  will be  in green. Otherwise, it wll be in red.\nInstances: Each instances have unique color. \nClasses: The instances with the same labels are in the same color."
            },
            "displayBoundingBox": {
                "infrequentlyUsed": true,
                "name": "Display Predefined ROI"
            },
            "drawInstanceOnImage": {
                "keyToolTip": "Draw the instance mask and the bounding box on image.",
                "name": "Draw Instances on Image"
            },
            "filterEdgeWorkpiece": {
                "infrequentlyUsed": true,
                "keyToolTip": "True: enable filter workpiece;\nFalse: don't filter workpiece.",
                "name": "Filter Objects Near Image Border"
            },
            "filterOverlappingObjectInstances": {
                "keyState": false
            },
            "heightThres": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The closest distance of the workpiece from the edge in the direction of height",
                "minimum": 0,
                "name": "Height of Border",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "maxAverageGrayValue": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "If the average gray value of the input image is greater than the maximum average gray threshold, no recognition is performed.",
                "maximum": 255,
                "minimum": 0,
                "name": "Max Average Image Gray Value (0–255)",
                "singleStep": 1
            },
            "maxOverlapRatio": {
                "keyToolTip": "If the overlap ratio of the two masks exceeds the maximum threshold, the mask with low confidence will be filtered out.",
                "maximum": 100,
                "minimum": 0,
                "singleStep": 5,
                "subtype": 1
            },
            "minAverageGrayValue": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "If the average gray value of the input image is less than the minimum average gray threshold, no recognition is performed.",
                "maximum": 255,
                "minimum": 0,
                "name": "Min Average Image Gray Value (0–255)",
                "singleStep": 1
            },
            "widthThres": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The closest distance of the workpiece to the edge in the direction of width",
                "minimum": 0,
                "name": "Width of Border",
                "singleStep": 1,
                "suffix": "pixel"
            }
        },
        "subgroup": "Instance Segmentation"
    },
    "mmind::StepInstanceSegmentatorCPU": {
        "groupInfos": {
            "Confidence Settings": [
                "confidenceThreshold"
            ],
            "Visualization Settings": [
                "drawBbox",
                "drawMask",
                "colorScheme"
            ]
        },
        "icon_name": "Instance Segmentation",
        "infrequentlyUsed": true,
		"keywords": "mask/measure",
        "properties": {
            "colorScheme": {
                "infrequentlyUsed": false,
                "keyToolTip": "Select the color scheme.",
                "name": "Way of Object Visualization",
                "valueToolTip": "Threshold: According to the confidence. If the calculated confidence is larger than the threshold set by users, the corresponding instance will be set in green.\nInstances: Each instance has an unique color. \nClasses: The instances with the same labels are in the same color."
            },
            "confidenceThreshold": {
                "maximum": 1,
                "minimum": 0,
                "name": "Confidence Threshold (0 ~1.0)"
            },
            "drawBbox": {
                "name": "Draw Bbox on Image"
            },
            "drawMask": {
                "name": "Draw Mask on Image"
            },
            "maxInstancesPerImage": {
                "decimals": 0,
                "maximum": 500,
                "minimum": 1,
                "name": "Max of Detected Objects",
                "singleStep": 1
            }
        },
        "subgroup": "Instance Segmentation"
    },
    "mmind::StepIsGreaterThanZThreshold": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "keywords": "Is Greater Than Z Threshold",
        "properties": {
            "zThreshold": {
                "keyToolTip": "Output True if there exists a Z value of the poses is greater than or equal to the threshold. Otherwaise, output False.",
                "name": "Threshold",
                "subtype": 2,
                "suffix": "m"
            }
        },
        "subgroup": "Validate"
    },
    "mmind::StepIsPoseWithinMask": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "subgroup": "Validate"
    },
    "mmind::StepJoinLabels": {
        "icon_name": "Join Labels"
    },
    "mmind::StepJsEngine": {
        "groupInfos": {
            "Input & Output Settings": [
                "inputs",
                "outputs"
            ],
            "Run-time Settings": [
                "checkInputSizeEqual",
                "predVarsFilePath"
            ],
            "Script Settings": [
                "scriptFilePath",
                "funcName",
                "importModules"
            ]
        },
        "icon_name": "Evaluate Results by JavaScript Engine",
        "infrequentlyUsed": true,
        "keywords": "js/javaScript/engine",
        "properties": {
            "funcName": {
                "subtype": 3
            },
            "importModules": {
                "infrequentlyUsed": true,
                "notEditable": true,
                "subtype": 3
            },
            "predVarsFilePath": {
                "stringFileFilter": "*.json",
                "subtype": 2
            },
            "scriptFilePath": {
                "stringFileFilter": "*.js",
                "subtype": 2
            }
        },
        "subgroup": "Script Engine"
    },
    "mmind::StepKeepPosesDistributedInRegularPolygon": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "properties": {
            "angleDiffThre": {
                "keyToolTip": "The larger the value, the greater the tolerance for the regular polygon shape.",
                "name": "Max Angle Difference",
                "suffix": "°"
            },
            "disThreRatio": {
                "keyToolTip": "The larger the value, the greater the tolerance for the regular polygon shape.",
                "name": "Max Distance Ratio"
            },
            "sidesNum": {
                "decimals": 1,
                "keyToolTip": "The number of the sides of the polygon.",
                "maximum": 100,
                "minimum": 3,
                "name": "Side Number",
                "singleStep": 1
            }
        },
        "subgroup": "Collect / Remove"
    },
    "mmind::StepLabelFilter": {
        "deprecatedType": true,
        "groupInfos": {
            "File Settings": [
                "labelFile"
            ],
            "Input Type": [
                "predInputType"
            ]
        },
        "icon_name": "Filter by Labels",
        "properties": {
            "labelFile": {
                "keyToolTip": "Label file directory."
            },
            "predInputType": {
                "keyToolTip": "Choose filtered object type."
            }
        }
    },
    "mmind::StepLabelFilterFlag": {
        "icon_name": "Validate Labels and Output Flags",
        "keywords": "Filter Flag by Labels/threshold/Bool",
        "properties": {
            "labelFile": {
                "keyToolTip": "Label file, as the reference label list.",
                "name": "Label File Name",
                "subtype": 4,
                "valueToolTip": "Set reference labels"
            }
        }
    },
    "mmind::StepLabelMapping": {
        "groupInfos": {
            "File Settings": [
                "labelFile"
            ],
            "Ports Settings": [
                "inputPortNum"
            ]
        },
        "icon_name": "Label Mapping",
        "properties": {
            "inputPortNum": {
                "decimals": 0,
                "keyToolTip": "The number of the Input ports. When it equals to 1, the mapping is 'one to one'.\nWhen it is greater than 1, the mapping is 'label combination to one'.",
                "maximum": 8,
                "minimum": 1,
                "name": "Size of Input Ports (1–8)",
                "singleStep": 1
            },
            "labelFile": {
                "keyToolTip": "The corresponding mapping file.",
                "subtype": 4,
                "valueToolTip": "Set label mapping"
            }
        }
    },
    "mmind::StepLaserProfiler": {
        "icon_name": "Laser Profiler",
        "keywords": "measure/sszn"
    },
    "mmind::StepLineDetector": {
        "groupInfos": {
            "FastLineDetetor Settings": [
                "distanceThres",
                "cannyTh1",
                "cannyTh2"
            ],
            "Line Detector Setting": [
                "lineDetectorType"
            ],
            "Line Properties": [
                "preserveColorContrast",
                "minLineLength",
                "filterLinesByMask"
            ],
            "LineSegmentDetector Settings": [
                "gradientQuant",
                "angleTolerance",
                "scale",
                "sigma_scale"
            ]
        },
        "icon_name": "Detect Line Segments",
        "keywords": "Line Detector",
        "properties": {
            "angleTolerance": {
                "decimals": 4,
                "infrequentlyUsed": true,
                "keyToolTip": "Gradient angle tolerance in degrees.",
                "maximum": 180,
                "minimum": 1,
                "name": "Gradient Angle Tolerance (1 ~ 180)",
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            },
            "cannyTh1": {
                "infrequentlyUsed": true,
                "keyToolTip": "The pixel is rejected for not being an edge pixel if its gradient is below this value.",
                "maximum": 255,
                "minimum": 1,
                "name": "Low Threshold (1 ~ 255)",
                "singleStep": 1,
                "valueToolTip": "The default setting is recommended."
            },
            "cannyTh2": {
                "infrequentlyUsed": true,
                "keyToolTip": "The pixel is kept for being an edge pixel if its gradient is larger this value.",
                "maximum": 255,
                "minimum": 1,
                "name": "High Threshold (1 ~ 255)",
                "singleStep": 1,
                "valueToolTip": "The default setting is recommended."
            },
            "distanceThres": {
                "infrequentlyUsed": true,
                "keyToolTip": "A point placed from a hypothesis line segment farther than this will be regarded as an outlier.",
                "minimum": 0.0001,
                "name": "Distance Threhold",
                "valueToolTip": "The default setting is recommended."
            },
            "filterLinesByMask": {
                "infrequentlyUsed": false,
                "keyToolTip": "Checked to save only the segments in the ROI.",
                "name": "Filter Out Lines Outside Masks"
            },
            "gradientQuant": {
                "infrequentlyUsed": true,
                "keyToolTip": "Bound to the quantization error on the gradient norm.",
                "maximum": 10,
                "minimum": 1,
                "name": "Gradient Quantization (1 ~ 10)",
                "singleStep": 1,
                "valueToolTip": "Reference value:1 or 2"
            },
            "lineDetectorType": {
                "keyToolTip": "test",
                "valueToolTip": "LineSegmentDetector: A normal detection method.\nFastLineDetetor: Similar to the other one but faster."
            },
            "minLineLength": {
                "keyToolTip": "The minmum segment length.\nSegments shorter than this will be discarded.",
                "minimum": 0,
                "name": "Min Line Length",
                "singleStep": 1,
                "suffix": "pixel"
            },
            "preserveColorContrast": {
                "infrequentlyUsed": true,
                "keyToolTip": "Preserve the color contrast  of the image."
            },
            "scale": {
                "infrequentlyUsed": true,
                "keyToolTip": "The scale of the image that will be used to find the lines.",
                "maximum": 1,
                "minimum": 0,
                "name": "Scale (0 ~ 1.0)"
            },
            "sigma_scale": {
                "infrequentlyUsed": true,
                "keyToolTip": "The larger the value, the more obvious the smoothing effect.",
                "minimum": 0.0001,
                "name": "Sigma for Gaussian Filter"
            }
        },
        "subgroup": "Line"
    },
    "mmind::StepLoad2dTrajectory": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Depth Validation Settings": [
                "searchKernelSize"
            ],
            "Point Validation Settings": [
                "nearestDistThreshold"
            ],
            "Trajectory Settings": [
                "useOffsetTrajs",
                "traj2dJsonPath"
            ],
            "Visualization Settings": [
                "showTrajImagScale"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "nearestDistThreshold": {
                "keyToolTip": "The distance threshold to searching neighboring point cloud.",
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "searchKernelSize": {
                "decimals": 4,
                "keyToolTip": "The kernel size to search neighboring depth image.",
                "minimum": 0,
                "singleStep": 1,
                "suffix": "pixel"
            },
            "showTrajImagScale": {
                "keyToolTip": "Scale ration of trajectory image."
            },
            "traj2dJsonPath": {
                "keyToolTip": "Path of 2d trajectory json file.",
                "stringFileFilter": "*.json",
                "subtype": 2
            },
            "useOffsetTrajs": {
                "keyToolTip": "If use cloud offset to calibrate the trajectory poses."
            }
        },
        "subgroup": "Load Trajectory"
    },
    "mmind::StepLoadAndCalcTrackPoints": {
        "developingType": true,
        "groupInfos": {
            "File Settings": [
                "trackPointsFilePath"
            ],
            "Refinement Settings": [
                "isRefineZ",
                "maxRefineDis"
            ],
            "Transformation Settings": [
                "transformType"
            ]
        },
        "icon_name": "Load Poses in Trajectory and Apply Affine Transform",
        "keywords": "Load And Calc Track Points",
        "properties": {
            "isRefineZ": {
                "keyToolTip": "Checked to use the input point clouds to refine the Z value of the poses.",
                "name": "Refine Poses"
            },
            "maxRefineDis": {
                "keyToolTip": "If the Z value of the the pose is bigger than this value, the original value will be used without any refinement.",
                "minimum": 0,
                "name": "Max Refine Z Value",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "trackPointsFilePath": {
                "keyToolTip": "The file contains the poses of the  trajectory.",
                "name": "Trajectory File Name",
                "stringFileFilter": "*.json",
                "subtype": 2,
                "valueToolTip": "motion path file storage path"
            },
            "transformType": {
                "valueToolTip": "RigidTransform: Rigid transform.\nAffineTransform: Select when the input matrix is not a rigid transform."
            }
        },
        "subgroup": "Load Trajectory"
    },
    "mmind::StepLoadTemplates": {
        "icon_name": "Load 2D Templates",
        "infrequentlyUsed": true,
        "keywords": "Templates Loader",
        "properties": {
            "angleTolerance": {
                "keyToolTip": "A pixel will be accepted if the angle error of less than the tolerance.",
                "maximum": 180,
                "minimum": 0,
                "name": "Angle Tolerance (0 ~ 180)",
                "subtype": 3
            },
            "gradientQuant": {
                "keyToolTip": "A proper gradient quantization can smooth the line.",
                "minimum": 0,
                "name": "Gradient Quantization",
                "singleStep": 0.1
            },
            "minLineLength": {
                "keyToolTip": "Line segments shorter than this value will be ignored.",
                "minimum": 0,
                "singleStep": 1
            },
            "symmetry": {
                "keyToolTip": "Checked if the template is symmetrical."
            },
            "templateDiagonalQuantization": {
                "keyToolTip": "Quantization the diagonals of the polygons.",
                "minimum": 0
            }
        },
        "subgroup": "Generate Template"
    },
    "mmind::StepMakePosePointToRefPlace": {
        "groupInfos": {
            "Input Check Settings": [
                "ignoreZeroNormDirection"
            ],
            "Reference Translation Settings": [
                "x",
                "relativeFlags",
                "coordinateType",
                "y",
                "z"
            ],
            "Rotation Settings": [
                "rotatedAxis",
                "fixedAxis"
            ],
            "Symmetry Settings": [
                "considerRotationalSymmetry",
                "symmetryAngle"
            ],
            "When Reference Points Came From Input": [
                "pointSourceType"
            ]
        },
        "icon_name": "Make Poses Point to Reference Place",
        "properties": {
            "ignoreZeroNormDirection": {
                "name": "Ignore When Pose Center Same as Reference Point"
            },
            "pointSourceType": {
                "name": "Data Type of Reference Point"
            },
            "relativeFlags": {
                "name": "Are Translations Relative to Object Coordinate"
            },
            "symmetryAngle": {
                "decimals": 0,
                "keyToolTip": "The smallest non-zero angle for which the object can be rotated (around the fixed axis) to conincide with itself.",
                "maximum": 360,
                "minimum": 0,
                "name": "Symmetry Angle (0 ~ 360)",
                "subtype": 3
            },
            "x": {
                "singleStep": 0.01,
                "subtype": 2
            },
            "y": {
                "singleStep": 0.01,
                "subtype": 2
            },
            "z": {
                "singleStep": 0.01,
                "subtype": 2
            }
        },
        "subgroup": "Pose Rotation"
    },
    "mmind::StepMakeTemplate": {
        "icon_name": "Make Template"
    },
    "mmind::StepMapColorCloudToImg": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "keywords": "Map Color Cloud To Image",
        "subgroup": "Image - Point Cloud"
    },
    "mmind::StepMapDepthToRgb": {
        "deprecatedType": true,
        "developingType": true,
        "icon_name": "Map Depth To Rgb",
        "infrequentlyUsed": true,
        "keywords": "measure",
        "subgroup": "Image - Image"
    },
    "mmind::StepMapMultiPickpoints": {
        "groupInfos": {
            "Import Labels (Optional）": [
                "labelFilePath"
            ],
            "Poses Files Path": [
                "geoCenterPointPath",
                "objPlacePointPath",
                "pickpointsPath"
            ]
        },
        "icon_name": "Map to Multi Pick Points",
        "keywords": "pickpoint/map multi",
        "properties": {
            "geoCenterPointPath": {
                "keyToolTip": "The file contains the poses on the geometric center from the matching model.",
                "name": "Geometric Center File",
                "stringFileFilter": "*.json",
                "subtype": 2
            },
            "labelFilePath": {
                "keyToolTip": "The label file of poses.",
                "name": "Pose Label File",
                "stringFileFilter": "*.json",
                "subtype": 2
            },
            "objPlacePointPath": {
                "keyToolTip": "The file contains the poses on the placing spots. \nIt is usually the same as the geometric center file.\nThis parameter is not frequently used. It is used to define the point at which the object touches the ground or touches other carriers (such as hooks) when it is placed. It needs to be set according to the specific application scenario.",
                "name": "Placing Point File",
                "stringFileFilter": "*.json",
                "subtype": 2
            },
            "pickpointsPath": {
                "keyToolTip": "The file contains pick points from the matching model.",
                "name": "Pick Points File",
                "stringFileFilter": "*.json",
                "subtype": 2
            }
        },
        "subgroup": "Generate Pose / Offset"
    },
    "mmind::StepMapNonZeroMask": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "subgroup": "Image - Image"
    },
    "mmind::StepMaskCluster": {
        "icon_name": "Mask Cluster",
        "infrequentlyUsed": true,
        "subgroup": "Others"
    },
    "mmind::StepMaskFilter": {
        "groupInfos": {
            "Threshold Settings": [
                "maskAreaLowerThreshold",
                "maskAreaUpperThreshold"
            ]
        },
        "icon_name": "Mask Filter",
        "infrequentlyUsed": true,
        "properties": {
            "maskAreaLowerThreshold": {
                "minimum": 0,
                "singleStep": 100,
                "suffix": "pixel"
            },
            "maskAreaUpperThreshold": {
                "minimum": 0,
                "singleStep": 100,
                "suffix": "pixel"
            }
        },
        "subgroup": "Add / Remove Areas in Masks"
    },
    "mmind::StepMaskGridding": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "properties": {
            "grideSize": {
                "decimals": 0,
                "keyToolTip": "The size of the grid.",
                "minimum": 0,
                "name": "Grid Size",
                "singleStep": 1
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepMaskImg": {
        "icon_name": "Apply Masks to Image",
        "keywords": "Mask Image/measure",
        "subgroup": "Image - Image"
    },
    "mmind::StepMaskToMinAreaRect": {
        "developingType": true,
        "groupInfos": {
            "Gradient Mask Settings": [
                "grayDirection",
                "sizeOffset",
                "grayOffset"
            ]
        },
        "keywords": "Mask to Minimun Area Rect/minarea/min area",
        "properties": {
            "grayDirection": {
                "name": "Output Image Type",
                "valueToolTip": "AllWhite: Output uniform white mask images.\nLeftToRight: Output masks with gradient colors. The intensity increases from the right to the left.\nRightToLeft: Output masks with gradient colors. The intensity increases from the left to the right."
            },
            "grayOffset": {
                "keyToolTip": "The greater the value, the brighter the image.",
                "maximum": 255,
                "minimum": 0,
                "name": "Min Gray Value",
                "valueToolTip": "The defaul setting is recommended."
            },
            "sizeOffset": {
                "keyToolTip": "The offset of the mask boarder which is used to adjust the output mask intensity.",
                "name": "Border Offset",
                "suffix": "pixel",
                "valueToolTip": "The defaul setting is recommended."
            }
        },
        "subgroup": "Calc Mask Property"
    },
    "mmind::StepMeasureCircle": {
        "groupInfos": {
            "Fitting Constraints": [
                "maxRadius",
                "minContourRatio",
                "minRadius"
            ]
        },
        "icon_name": "measure_circle",
        "keywords": "measure",
        "outportMapping": "[[1,2]]",
        "properties": {
            "maxRadius": {
                "infrequentlyUsed": true,
                "maximum": 100000,
                "minimum": 0,
                "valueToolTip": "The detected circle is filtered by the radius range [ Min Radius, Max Radius ].\nThis value is related to the real dimension of the target. For example, if the real dimension of the object is 10mm, the corresponding range can be set to [8, 15]. The dimension conversion from the image to the physical is done by the scale ratio."
            },
            "minContourRatio": {
                "infrequentlyUsed": true,
                "maximum": 1,
                "minimum": 0,
                "valueToolTip": "If the point number is smaller than the ratio, the fit circle will be discarded."
            },
            "minRadius": {
                "infrequentlyUsed": true,
                "maximum": 10000,
                "minimum": 0,
                "valueToolTip": "The detected circle is filtered by the radius range [ Min Radius, Max Radius ].\nThis value is related to the real dimension of the target. For example, if the real dimension of the object is 10mm, the corresponding range can be set to [8, 15]. The dimension conversion from the image to the physical is done by the scale ratio."
            }
        },
        "subgroup": "2D Measuring"
    },
    "mmind::StepMeasureFlatness": {
        "properties": {
            "rois": {
                "subtype": 4
            }
        }
    },
    "mmind::StepMeasureGapWidth": {
        "developingType": true,
        "icon_name": "measure_flatness",
        "infrequentlyUsed": true,
        "keywords": "measure"
    },
    "mmind::StepMeasureHeightDifferencePointToPoint": {
        "icon_name": "Measure Height Difference Point to Point",
        "keywords": "measure",
        "properties": {
            "positionAndOrientationCorrection": {
                "keyToolTip": "If this parameter is checked, the points in the parameters set in the earlier execution\n will be converted to the position and orientation that fits the object in the image input \nin the current execution according to the input 2D transformation.",
                "name": "Position and Orientation Correction"
            }
        },
        "subgroup": "2.5D Measuring"
    },
    "mmind::StepMeasureHeightDifferences": {
        "groupInfos": {
            "Height Computation Settings": [
                "maxClusterHeightDiff",
                "maxSearchRadius",
                "maxSearchCount"
            ]
        },
        "properties": {
            "maxClusterHeightDiff": {
                "decimals": 5,
                "maximum": 1000,
                "minimum": 0,
                "name": "Max Cluster Height Difference",
                "singleStep": 0.01,
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm",
                "valueToolTip": "The depth value of a point is calculated by the average depth of local points. This property specifies the max depth difference between the used points."
            },
            "maxSearchCount": {
                "maximum": 500,
                "minimum": 1,
                "name": "Max Search Points Number",
                "valueToolTip": "The depth value of a point is calculated by the average depth of local points. This property specifies the max point number to calculate the depth value.\nThe number of points used to calculate the depth is constrained by both max search radius and max search count."
            },
            "maxSearchRadius": {
                "maximum": 500,
                "minimum": 0,
                "valueToolTip": "The depth value of a point is calculated by the average depth of local points. This property specifies the max region radius (in pixel) to calculate the depth value. \nThe number of points used to calculate the depth is constrained by both max search radius and max search count."
            }
        }
    },
    "mmind::StepMeasureHeightDifferencesPointsToBaseline": {
        "icon_name": "Measure Height Differences Points To Baseline",
        "keywords": "measure",
        "properties": {
            "detectPoints": {
                "subtype": 1
            },
            "pointConstraint": {
                "valueToolTip": "Use the adsorption mode if the detect points are desired to be on the baseline."
            },
            "positionAndOrientationCorrection": {
                "keyToolTip": "If this parameter is checked, the points and line in the parameters set in the earlier execution\n will be converted to the position and orientation that fits the object in the image input\n in the current execution according to the input 2D transformation.",
                "name": "Position and Orientation Correction"
            }
        },
        "subgroup": "2.5D Measuring"
    },
    "mmind::StepMeasureHeightDifferencesPointsToPlane": {
        "icon_name": "Measure Height Differences Points to Plane",
        "keywords": "measure",
        "properties": {
            "basePoints": {
                "subtype": 1
            },
            "detectPoints": {
                "subtype": 1
            },
            "positionAndOrientationCorrection": {
                "keyToolTip": "If this parameter is checked, the points in the parameters set in the earlier execution\n will be converted to the position and orientation that fits the object in the image input \nin the current execution according to the input 2D transformation.",
                "name": "Position and Orientation Correction"
            }
        },
        "subgroup": "2.5D Measuring"
    },
    "mmind::StepMeasureLongestLine": {
        "groupInfos": {
            "Fitting Constraints": [
                "minLineLength",
                "maxLineLength"
            ]
        },
        "icon_name": "measure_line",
        "keywords": "measure",
        "outportMapping": "[[1,2]]",
        "properties": {
            "maxLineLength": {
                "infrequentlyUsed": true,
                "maximum": 100000,
                "minimum": 0,
                "valueToolTip": "The detected line segment is filtered by the length range [ Min Segment Length, Max Segment Length ].\nThis value is related to the real dimension of the target. For example, if the real dimension of the object is 10mm, the corresponding range can be set to [8, 15]. The dimension conversion from the image to the physical is done by the scale ratio."
            },
            "minLineLength": {
                "infrequentlyUsed": true,
                "maximum": 100000,
                "minimum": 0,
                "valueToolTip": "The detected line segment is filtered by the length range [ Min Segment Length, Max Segment Length ].\nThis value is related to the real dimension of the target. For example, if the real dimension of the object is 10mm, the corresponding range can be set to [8, 15]. The dimension conversion from the image to the physical is done by the scale ratio."
            }
        },
        "subgroup": "2D Measuring"
    },
    "mmind::StepMeasureMultiPointsPlaneHeightDiff": {
        "icon_name": "Measure Point Height Difference",
        "keywords": "measure",
        "outportMapping": "[[0,1]]",
        "properties": {
            "basePoints": {
                "subtype": 2,
                "valueToolTip": "The points used to fit a plane."
            },
            "detectPoints": {
                "subtype": 2
            },
            "maxSearchCount": {
                "name": "Max Point Number",
                "valueToolTip": "The depth value of a point is calculated by the average depth of local points. This property specifies the max point number to calculate the depth value."
            },
            "minClusterDist": {
                "name": "Max Cluster Distance",
                "valueToolTip": "The depth value of a point is calculated by the average depth of local points. This property specifies the max depth difference between the used points."
            },
            "searchRadius": {
                "valueToolTip": "The depth value of a point is calculated by the average depth of local points. This property specifies the max region radius to calculate the depth value."
            }
        }
    },
    "mmind::StepMeasurePlaneHeightDiff": {
        "icon_name": "measure_flatness",
        "properties": {
            "rois": {
                "subtype": 4
            }
        }
    },
    "mmind::StepMeasurePlaneHeightDiffAlongDirectionParallelToAxes": {
        "developingType": true,
        "infrequentlyUsed": true,
        "properties": {
            "minClusterDist": {
                "name": "Minimum Cluster Distance"
            },
            "rois": {
                "name": "ROI Set"
            }
        },
        "subgroup": "2.5D Measuring"
    },
    "mmind::StepMeasurePointPairHeightDiff": {
        "icon_name": "Measure Height Difference To Base Line",
        "keywords": "measure",
        "properties": {
            "baseLines": {
                "name": "Baselines",
                "subtype": 5
            },
            "detectPoints": {
                "subtype": 1
            },
            "maxSearchCount": {
                "name": "Max Point Number",
                "valueToolTip": "The depth value of a point is calculated by the average depth of local points. This property specifies the max point number to calculate the depth value."
            },
            "minClusterDist": {
                "name": "Max Cluster Distance"
            },
            "searchRadius": {
                "valueToolTip": "The depth value of a point is calculated by the average depth of local points. This property specifies the max region radius to calculate the depth value."
            }
        }
    },
    "mmind::StepMeasurePointsHeightDiff": {
        "icon_name": "measure_height_diffs_points_to_points",
        "keywords": "measure",
        "properties": {
            "heightDiffLines": {
                "name": "Height Difference Lines",
                "subtype": 5,
                "valueToolTip": "The endpoints of the line segments are used to represent the points."
            },
            "maxSearchCount": {
                "name": "Max Point Count",
                "valueToolTip": "The depth value of a point is calculated by the average depth of local points. This property specifies the max point number to calculate the depth value."
            },
            "minClusterDist": {
                "name": "Max Cluster Distance",
                "valueToolTip": "The depth value of a point is calculated by the average depth of local points. This property specifies the max depth difference between the used points."
            },
            "searchRadius": {
                "valueToolTip": "The depth value of a point is calculated by the average depth of local points. This property specifies the max region radius to calculate the depth value."
            }
        }
    },
    "mmind::StepMeasurePrimitives": {
        "groupInfos": {
            "Contour Extration Settings": [
                "subPixelAlgo",
                "cannyLowThreshold",
                "edgeThickness",
                "cannyHighThreshold"
            ]
        },
        "properties": {
            "cannyHighThreshold": {
                "decimals": 0,
                "maximum": 255,
                "minimum": 0,
                "name": "High Threshold (0 ~ 255)",
                "singleStep": 1
            },
            "cannyLowThreshold": {
                "decimals": 0,
                "maximum": 255,
                "minimum": 0,
                "name": "Low Threshold (0 ~ 255)",
                "singleStep": 1
            },
            "edgeThickness": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "maximum": 10,
                "minimum": 1,
                "singleStep": 1,
                "suffix": "pixel"
            },
            "maxFitError": {
                "maximum": 20,
                "minimum": 0,
                "valueToolTip": "This is the mean fit error of the points. A smaller value means the fit points are more close to the fit feature, while a larger value means robust to noise."
            },
            "subPixelAlgo": {
                "infrequentlyUsed": true,
                "name": "Contour Extraction Algorithm"
            }
        }
    },
    "mmind::StepMeasureResult": {
        "deprecatedType": true,
        "developingType": true,
        "icon_name": "Measure Result",
        "infrequentlyUsed": true,
        "subgroup": "Pose"
    },
    "mmind::StepMeasurementWithAlignment": {
        "properties": {
            "positionAndOrientationCorrection": {
                "keyToolTip": "If this parameter is checked, the ROI set in the earlier execution will be converted to the \nposition and orientation that fits the object in the image input in the current execution\n according to the input 2D transformation.",
                "name": "Position and Orientation Correction"
            }
        }
    },
    "mmind::StepMerge": {
        "icon_name": "Merge Data",
        "keywords": "measure",
        "subgroup": "Others"
    },
    "mmind::StepMergeCloudVec": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true
    },
    "mmind::StepMergeDepthImages": {
        "icon_name": "Merge depth images",
        "infrequentlyUsed": true,
        "subgroup": "Supplement"
    },
    "mmind::StepMergeLabelList": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true
    },
    "mmind::StepMergeLineSegmentVec": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true
    },
    "mmind::StepMergeMasks": {
        "icon_name": "Merge Mask Images",
        "keywords": "vector/list/measure",
        "subgroup": "Mask Logical Operation"
    },
    "mmind::StepMergePoseVec": {
        "deprecatedType": true,
        "icon_name": "Merge Pose Lists",
        "keywords": "Merge Pose Vector/pose list/poses"
    },
    "mmind::StepMergeSameHeightClouds": {
        "groupInfos": {
            "Calc Height Settings": [
                "cloudDirectionType",
                "cloudHeightErrorTolerance"
            ],
            "Customized Direction": [
                "x",
                "y",
                "z"
            ],
            "Direction of Calculating Height": [
                "maxSizeCloudNormalZDir"
            ]
        },
        "icon_name": "Merge Point Clouds with Similar Height",
        "infrequentlyUsed": true,
        "keywords": "Merge Same Height Clouds",
        "properties": {
            "cloudDirectionType": {
                "name": "Reference Direction Type",
                "valueToolTip": "CustomizedDir: Use the customized direction.\nNormalDirOfMaxSizeCloud: Use the Z direction of the largest point cloud."
            },
            "cloudHeightErrorTolerance": {
                "keyToolTip": "Points with height differences smaller  than the tolerance can be considered at the same height.",
                "minimum": 0,
                "name": "Tolerance in Height",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "maxSizeCloudNormalZDir": {
                "name": "Custom Direction along Normal's Z Axis",
                "valueToolTip": "Positive: The same direction as the largest point cloud.\nNegative: The opposite direction of the largest point cloud."
            },
            "x": {
                "keyToolTip": "Used to calculate the height.",
                "name": "X"
            },
            "y": {
                "keyToolTip": "Used to calculate the height."
            },
            "z": {
                "keyToolTip": "Used to calculate the height."
            }
        },
        "subgroup": "Merge"
    },
    "mmind::StepMorphOperator": {
        "icon_name": "Morphological Transformations",
        "keywords": "Morph Operator/measure",
        "properties": {
            "morphOperatorType": {
                "name": "Morphological Transformations",
                "valueToolTip": "OpeningOperator: Another name of erosion followed by dilation. It is useful in removing noise.\nDilateOperator: Increase the area of the object and join broken parts of an object.\nErodeOperator: Remove small white noises and detach two connected objects.\nClosingOperator: Another name of dilation followed by Erosion. It is useful in closing small holes inside the foreground objects, or small black points on the object.\nSkeleton: Extract the outline of the object."
            }
        },
        "subgroup": "Add / Remove Areas in Masks"
    },
    "mmind::StepMoveCloudAlongSetDir": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Coordinate Setting": [
                "coordinateType",
                "axisTypeOfObjectCoordinate",
                "x",
                "y",
                "z"
            ],
            "Mapping Method Setting": [
                "mappingType"
            ],
            "Translation Setting": [
                "moveDis"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "moveDis": {
                "maximum": 1,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            }
        },
        "subgroup": "Reshape / Transform / Move"
    },
    "mmind::StepMovePoseAlongSetDir": {
        "groupInfos": {
            "Customized Direction": [
                "x",
                "y",
                "z"
            ],
            "Input Usage Settings": [
                "mappingType"
            ],
            "Translation Direction Settings": [
                "moveDis",
                "axisTypeOfObjectCoordinate",
                "referenceDirection"
            ]
        },
        "icon_name": "Translate Poses along Given Direction",
        "keywords": "Move Pose Along Set Dir",
        "properties": {
            "axisTypeOfObjectCoordinate": {
                "keyToolTip": "The specified axis of the pose which will be used as the reference direction.",
                "name": "Specified Axis"
            },
            "mappingType": {
                "name": "Correspondence Type",
                "valueToolTip": "FirstToAll: Use only the first input distance to translate the original poses.\nOneToOne: Use all the input distances to translate the original poses one to one."
            },
            "moveDis": {
                "keyToolTip": "The translation distance along the customized direction.\nThis value will be used only if there is no input translation.",
                "name": "Translation Distance",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "referenceDirection": {
                "name": "Translation Direction Source",
                "valueToolTip": "CustomizedDirection: Translate along the customized direction.\nObjectAxis:  Translate along the direction of the specified axis of the  pose."
            },
            "x": {
                "keyToolTip": "The X value which is used to compose the reference direction."
            },
            "y": {
                "keyToolTip": "The Y value which is used to compose the reference direction."
            },
            "z": {
                "keyToolTip": "The Z value which is used to compose the reference direction."
            }
        },
        "subgroup": "Adjust Translation"
    },
    "mmind::StepNormalCalGPU": {
        "deprecatedType": true,
        "groupInfos": {
            "Calculation Settings": [
                "isBatched",
                "calNormRadius"
            ],
            "Concave & Convex": [
                "removeConvexAndConcave",
                "concaveRadius",
                "concaveThreshold",
                "convexThreshold"
            ],
            "Removal of Sparse Points": [
                "removeSparse",
                "sparseRadius",
                "sparseThreshold",
                "sparseCircleTime"
            ]
        },
        "icon_name": "Cloud Processing (GPU)",
        "properties": {
            "calNormRadius": {
                "keyToolTip": "The search radius used to calculate normals.",
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "concaveRadius": {
                "infrequentlyUsed": true,
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "concaveThreshold": {
                "decimals": 4,
                "infrequentlyUsed": true,
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.001
            },
            "convexThreshold": {
                "decimals": 4,
                "infrequentlyUsed": true,
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.001
            },
            "isBatched": {
                "keyToolTip": "Check this option when there are too many point clouds and the video memory is too small."
            },
            "removeConvexAndConcave": {
                "infrequentlyUsed": true
            },
            "sparseCircleTime": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "maximum": 1000,
                "minimum": 0,
                "singleStep": 1
            },
            "sparseRadius": {
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "sparseThreshold": {
                "keyToolTip": "For every point in the cloud, when the number of neighbors within search radius is less than this value, this point will be filtered out.",
                "maximum": 1000,
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::StepNormalEstimation": {
        "deprecatedType": true,
        "groupInfos": {
            "Radius": [
                "searchRadius"
            ]
        },
        "properties": {
            "searchRadius": {
                "keyToolTip": "Points within the search radius will be used to calculate normal.",
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            }
        }
    },
    "mmind::StepNotify": {
        "icon_name": "Notify",
        "infrequentlyUsed": true,
        "keywords": "server/Mech-Viz/measure",
        "properties": {
            "actionWhenFailed": {
                "keyToolTip": "The message type when sending failed.",
                "name": "Message Type When Failed "
            },
            "message": {
                "keyToolTip": "The sent content."
            },
            "serviceName": {
                "keyToolTip": "Where to send the notification.",
                "name": "Service Name"
            },
            "timeout": {
                "keyToolTip": "The timeout."
            }
        }
    },
    "mmind::StepNumberComparison": {
        "icon_name": "Compare Values",
        "infrequentlyUsed": true,
        "properties": {
            "operation": {
                "name": "Operation Type"
            },
            "predefined": {
                "name": "Predefined Operand"
            }
        }
    },
    "mmind::StepNumberLimit": {
        "icon_name": "Trim Input List",
        "keywords": "Number Limit",
        "properties": {
            "numberLimit": {
                "keyToolTip": "The number limit of the output.",
                "minimum": 0,
                "name": "Ouput Size"
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepNumberOperations": {
        "icon_name": "Numeric Operation",
        "properties": {
            "operand": {
                "decimals": 4,
                "keyToolTip": "If user wants to add one constant number to all numbers in the first input, user should set the constant here and leave the second port unconnected.",
                "name": "Predefined Operand",
                "singleStep": 0.01
            },
            "operationType": {
                "keyToolTip": "Add / Minus / Multiply / Divide:\nResult will be the first input （add / minus / multiply / divide）the second input.\n\nCalcAbsValue: \nCalculate absolute value for each number in the list of first input.",
                "name": "Operation Type"
            }
        }
    },
    "mmind::StepNumberSubtraction": {
        "deprecatedType": true,
        "icon_name": "Subtract Real Numbers",
        "infrequentlyUsed": true,
        "keywords": "Number Subtraction"
    },
    "mmind::StepOCR": {
        "developingType": true,
        "properties": {
            "confidenceThreshold": {
                "decimals": 2,
                "maximum": 1,
                "minimum": 0,
                "name": "Confidence Threshold (0 ~ 1.0)"
            },
            "runningMode": {
                "keyToolTip": "The highspeed mode increase the running speed at the cost of a small reduction in accuracy and recall."
            }
        }
    },
    "mmind::StepObjectDetector": {
        "deprecatedType": true,
        "groupInfos": {
            "Visualization Settings": [
                "showBoundingBox",
                "boundingBoxMode",
                "showConfidence"
            ]
        },
        "icon_name": "Object Detection",
        "infrequentlyUsed": true,
        "properties": {
            "boundingBoxMode": {
                "name": "Method to Visualize Objects"
            },
            "showBoundingBox": {
                "name": "Draw Objects on Image"
            },
            "showConfidence": {
                "name": "Show Confidences on Image"
            }
        },
        "subgroup": "Object Detection"
    },
    "mmind::StepOpenVino": {
        "groupInfos": {
            "Model Settings": [
                "modelPath"
            ]
        },
        "properties": {
            "modelPath": {
                "infrequentlyUsed": false,
                "name": "Model File",
                "stringFileFilter": "*.xml",
                "subtype": 2
            }
        }
    },
    "mmind::StepOrthographicProjection": {
        "groupInfos": {
            "Orthographic Projection Seetings": [
                "orthographicScaleRatio",
                "orthographicBorderSize"
            ]
        },
        "icon_name": "Orthographic Projection",
        "infrequentlyUsed": true,
        "keywords": "measure",
        "properties": {
            "maxPtX": {
                "infrequentlyUsed": true,
                "name": "X of Maximum Point",
                "subtype": 2
            },
            "maxPtY": {
                "infrequentlyUsed": true,
                "name": "Y of Maximum Point",
                "subtype": 2
            },
            "minPtX": {
                "infrequentlyUsed": true,
                "name": "X of Minimum Point",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "minPtY": {
                "infrequentlyUsed": true,
                "name": "Y of Minimum Point",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "orthographicBorderSize": {
                "infrequentlyUsed": true,
                "maximum": 10000,
                "minimum": 0,
                "singleStep": 10,
                "suffix": "pix"
            },
            "orthographicScaleRatio": {
                "infrequentlyUsed": true,
                "minimum": 1,
                "singleStep": 100
            },
            "useSpecifiedMaxPt": {
                "infrequentlyUsed": true,
                "name": "Use Specified Maximum Point",
                "valueToolTip": "If the box is checked, the user can specify the maximum point by properties. Otherwise, the maximum point is computed depending on the input point cloud.\nThe specified value can refer to the information output of the step."
            },
            "useSpecifiedMinPt": {
                "infrequentlyUsed": true,
                "name": "Use Specified Minimum Point",
                "valueToolTip": "If the box is checked, the user can specify the minimum point by properties. Otherwise, the minimum point is computed depending on the input point cloud.\nThe specified value can refer to the information output of the step."
            }
        },
        "subgroup": "Image - Point Cloud"
    },
    "mmind::StepOrthographicProjectionInverse": {
        "icon_name": "Orthographic Projection Inverse",
        "infrequentlyUsed": true,
        "keywords": "measure",
        "subgroup": "Image - Point Cloud"
    },
    "mmind::StepPack": {
        "icon_name": "Pack",
        "subgroup": "Change Data Dimension"
    },
    "mmind::StepPalletInfoRecognition": {
        "developingType": true,
        "groupInfos": {
            "Pallet Setting": [
                "overlapRatioBetweenObjectAndHighestLayerMask"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "overlapRatioBetweenObjectAndHighestLayerMask": {
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.1
            }
        }
    },
    "mmind::StepParamsCompensation": {
        "icon_name": "Validate and Calc Parameter Compensation",
        "infrequentlyUsed": true,
        "properties": {
            "maxDistanceBetweenPointPair": {
                "minimum": 0,
                "singleStep": 0.01,
                "storeUnit": 0,
                "subtype": 2
            },
            "parametersCompensationDirectory": {
                "subtype": 1
            },
            "targetReference": {
                "subtype": 3
            }
        },
        "subgroup": "Supplement"
    },
    "mmind::StepPeriodicTrigger": {
        "groupInfos": {
            "Interval Time": [
                "intervalMs"
            ],
            "Trigger Counts": [
                "maxTriggerConuts",
                "currentCount"
            ]
        },
        "icon_name": "periodic_trigger",
        "infrequentlyUsed": true,
        "properties": {
            "currentCount": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "minimum": 0,
                "singleStep": 1
            },
            "intervalMs": {
                "decimals": 0,
                "keyToolTip": "Trigger a signal every invervalMs.",
                "minimum": 0,
                "singleStep": 10,
                "suffix": "ms"
            },
            "maxTriggerConuts": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "When this value is set to -1, the trigger will only stop until user click 'Stop' button in UI.",
                "minimum": -1,
                "singleStep": 1
            }
        },
        "subgroup": "Trigger"
    },
    "mmind::StepPerspectiveTransform": {
        "icon_name": "Perspective Transform",
        "infrequentlyUsed": true,
        "subgroup": "Image Transform"
    },
    "mmind::StepPickPointVerification": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "File Settings": [
                "pickpointSettingJsonFile"
            ]
        },
        "infrequentlyUsed": true,
        "keywords": "Pick Point Verification",
        "properties": {
            "pickpointSettingJsonFile": {
                "keyToolTip": "The file contains the pick points.",
                "name": "Pick Points File Name",
                "stringFileFilter": "*.json",
                "subtype": 2
            }
        },
        "subgroup": "Pose"
    },
    "mmind::StepPlacePolygons": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Placement Setting": [
                "firstPolygonPosition",
                "ifNewRectangle"
            ],
            "Polygon Setting": [
                "polygonResizeFactor",
                "safeBoundaryOffset",
                "minChamferDis"
            ],
            "Rectangle Size": [
                "rectangleWidth",
                "rectangleHeight"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "firstPolygonPosition": {
                "keyToolTip": "The position type of the polygon which is first placed."
            },
            "ifNewRectangle": {
                "keyToolTip": "This value determines if the polygon is going to be placed on a new rectangle. Before we check it, we need to make sure that it is unchecked.Otherwise, we need to uncheck it manually  before we check it."
            },
            "minChamferDis": {
                "keyToolTip": "The minimum of the chamfer distance of the polygon.",
                "maximum": 9999,
                "minimum": 3,
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "polygonResizeFactor": {
                "keyToolTip": "The scale factor used for enlarging the polygon."
            },
            "rectangleHeight": {
                "keyToolTip": "The width of the rectangle which polygons will be placed on.",
                "maximum": 9999,
                "minimum": 2,
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "rectangleWidth": {
                "keyToolTip": "The width of the rectangle which polygons will be placed on.",
                "maximum": 9999,
                "minimum": 2,
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            },
            "safeBoundaryOffset": {
                "keyToolTip": "The boundary offset used for enlarging the polygon for safety reason.",
                "maximum": 9999,
                "minimum": 2,
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepPoint2PlaneProjection": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "subgroup": "Reshape / Transform / Move"
    },
    "mmind::StepPointsFilter": {
        "icon_name": "Point Filter",
        "keywords": "measure",
        "properties": {
            "pointsFilterType": {
                "keyToolTip": "StatisticalOutlierFilter: It can remove points that deviate from the point group beyond a certain range. It is recommended to use it when there are obvious outliers in the point clouds.\nNormalsFilter: It can remove the points whose normals deviate from the reference direction beyond the set range. It is recommended to use it when the point clouds need to be stratified."
            }
        },
        "subgroup": "Remove Points"
    },
    "mmind::StepPolarUnwrap": {
        "properties": {
            "angleSpan": {
                "maximum": 720,
                "minimum": 0,
                "singleStep": 1
            },
            "angleStart": {
                "maximum": 360,
                "minimum": -360,
                "singleStep": 1
            },
            "centerX": {
                "singleStep": 1
            },
            "centerY": {
                "singleStep": 1
            },
            "radialScale": {
                "decimals": 2,
                "maximum": 100,
                "minimum": 0,
                "singleStep": 0.1
            },
            "radius": {
                "decimals": 1,
                "maximum": 10000,
                "minimum": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::StepPose2DEvaluation": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Evaluation Criteria": [
                "maxCenterPointDist",
                "maxDegError"
            ],
            "Ground Truth Settings": [
                "gtInputType"
            ],
            "Saving Settings": [
                "isSaveImg",
                "imgSavePath"
            ],
            "Visualization Settings": [
                "lineLength",
                "dotRadius",
                "lineWidth",
                "backgroundImage"
            ]
        },
        "infrequentlyUsed": true,
        "keywords": "Pose2D Evaluation",
        "properties": {
            "backgroundImage": {
                "valueToolTip": "BlackImage: Use a balck image as the background.\nInputImage: Use the input image as the background."
            },
            "dotRadius": {
                "decimals": 4,
                "keyToolTip": "The dot radius of the pose center drawn on the image.",
                "minimum": 1,
                "singleStep": 1,
                "suffix": "pixel"
            },
            "gtInputType": {
                "name": "Ground Truth Source",
                "valueToolTip": "GtPose2D: Get the ground Truth from the input.\nGtJsonInfo: Get the ground Truth from the file."
            },
            "imgSavePath": {
                "keyToolTip": "The path to save the the visualization image.",
                "name": "Saved Image File Name",
                "subtype": 1
            },
            "isSaveImg": {
                "keyToolTip": "Checked to save the visualization image.",
                "name": "Save Image"
            },
            "jsonPath": {
                "keyToolTip": "The file contains the ground truth poses.",
                "name": "Groud Truth File",
                "stringFileFilter": "*.json",
                "subtype": 2
            },
            "lineLength": {
                "decimals": 4,
                "keyToolTip": "The line length of the pose drawn on the image.",
                "minimum": 1,
                "name": "Line Length",
                "singleStep": 1
            },
            "lineWidth": {
                "decimals": 4,
                "keyToolTip": "The line width of the pose drawn on the image.",
                "minimum": 1,
                "singleStep": 1,
                "suffix": "pixel"
            },
            "maxCenterPointDist": {
                "decimals": 4,
                "keyToolTip": "If the distance between the pose and the ground truth is smaller than this value, it can be considered as precise.",
                "minimum": 0,
                "name": "Distance Threshold",
                "singleStep": 1
            },
            "maxDegError": {
                "decimals": 4,
                "keyToolTip": "If the angle between the pose and the ground truth is smaller than this value, it can be considered as precise.",
                "minimum": 0,
                "name": "Angle Threshold",
                "singleStep": 1
            }
        },
        "subgroup": "2D Pose"
    },
    "mmind::StepPose2DToPose3DBaseOrthographicProjection": {
        "icon_name": "2D Poses To 3D Poses Base Orthographic Projection",
        "infrequentlyUsed": true,
        "properties": {
            "neighborDepthSearchKernelSize": {
                "decimals": 0,
                "minimum": 1,
                "singleStep": 1
            }
        },
        "subgroup": "Conversion"
    },
    "mmind::StepPose2EulerAngles": {
        "groupInfos": {
            "Angle Settings": [
                "eulerAnglesType"
            ],
            "Reference Coordinate System Settings": [
                "coordSysType"
            ],
            "Rotation Axis Settings": [
                "axis0",
                "axis1",
                "axis2"
            ]
        },
        "icon_name": "From Poses to Euler Angles",
        "properties": {
            "axis0": {
                "keyState": false,
                "keyToolTip": "The first axis to rotate.",
                "name": "Axis 1"
            },
            "axis1": {
                "keyToolTip": "The second axis to rotate.",
                "name": "Axis 2"
            },
            "axis2": {
                "keyToolTip": "The third axis to rotate.",
                "name": "Axis 3"
            },
            "coordSysType": {
                "keyToolTip": "Roated: The axis of the pose is used as the rotation axis.\nStatic: The axis of the world coordinate system is used as the rotation axis.",
                "name": "Rotation Reference Coordinate System"
            },
            "eulerAnglesType": {
                "keyToolTip": "The unit of angles.",
                "name": "Angle Unit"
            }
        },
        "subgroup": "Conversion"
    },
    "mmind::StepPose3dToPose2d": {
        "icon_name": "From 3D Poses to 2D Poses",
        "infrequentlyUsed": true,
        "keywords": "Pose3d To Pose2d/convert/map",
        "subgroup": "Conversion"
    },
    "mmind::StepPoseAdjustmentCollection": {
        "icon_name": "Pose Adjustment Collection",
        "properties": {
            "advOperations": {
                "infrequentlyUsed": true,
                "keyToolTip": "Configuration of high level functionality.",
                "name": "Advanced Operations"
            },
            "configPath": {
                "infrequentlyUsed": true,
                "name": "Config File Path",
                "stringFileFilter": "*json",
                "subtype": 3,
                "valueToolTip": "If candidates are emptt, it means there isn't any saved configuration.\n\nHint:\nUser can open the editor of property 'Operations' to save current settings to a configuration file."
            },
            "entryPortsDesc": {
                "keyToolTip": "User can open the editor of property 'Operations' to edit this property.",
                "name": "Entry Ports Description",
                "valueToolTip": "If user want to input from property,\nthen the format would be concatenation of the name of data type, and separated by (;)\ne.g：\nPose;Index -> can matched with \"PoseList;IndexList\" as description of input ports."
            },
            "exitPortsDesc": {
                "keyToolTip": "User can open the editor of property 'Operations' to edit this property.\n\nAdvice:\nUser can skip editing output ports in editor.\nCurrent step will try to find the lastest output from internal sub-steps as the final output.",
                "name": "Exit Ports Description",
                "valueToolTip": "If user want to input from property,\nthen the format would be concatenation of the name of data type, and separated by (;)\ne.g：\nPose;Index -> can matched with \"PoseList;IndexList\" as description of output ports."
            },
            "operations": {
                "keyToolTip": "User can open an editor to adjust the poses.\n\nBefore entering the editor:\n1) Please run the current project once.\nIf project contains step 'Send Point Cloud to Mech-Viz',\nthen editor can have the scene cloud as adjustment reference.\n\n2) After the input data flow is activated,\nrun current step once. Input poses are then set.",
                "subtype": 4,
                "valueToolTip": "Open pose editing tool"
            },
            "stepsCompactDescs": {
                "name": "Complete Description for Internal Sub-Steps"
            },
            "stepsIODescs": {
                "name": "Complete Descriptions for Sub-Steps IO Connections"
            }
        }
    },
    "mmind::StepPoseCombine": {
        "icon_name": "Compose New Poses by Combining Parts of Input Poses",
        "keywords": "Pose Combine/Compose a New Pose by Taking Parts of Each Input",
        "properties": {
            "translationStrategy": {
                "keyToolTip": "Specifiy the axes of the fourth input pose's position to use.",
                "name": "The Axes of Fourth Input Pose to Use"
            }
        },
        "subgroup": "Generate Pose / Offset"
    },
    "mmind::StepPoseCompositionFromQuatAndTrans": {
        "icon_name": "Compose Pose From Quaternion and Translation",
        "infrequentlyUsed": true,
        "subgroup": "Pose Composition & Decomposition"
    },
    "mmind::StepPoseDecompositionToQuatAndTrans": {
        "icon_name": "Decompose Poses to Quaternions and Translations",
        "infrequentlyUsed": true,
        "subgroup": "Pose Composition & Decomposition"
    },
    "mmind::StepPoseDisAlongAxis": {
        "icon_name": "Calc Distance between Two Poses along Specified Direction",
        "keywords": "Poses Dis Along Axis",
        "properties": {
            "axisCombinationStrategy": {
                "keyToolTip": "Calculate the distance in the direction of the specified axis or axis combination in world coordinate.",
                "name": "Specified Axis or Axis Combination",
                "valueToolTip": "Calculate the distance in the direction of the specified axis or axis combination in world coordinate."
            }
        },
        "subgroup": "3D Length / Distance"
    },
    "mmind::StepPoseDistortionCorrection": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "keywords": "Pose Distortion Correction",
        "subgroup": "Adjust Translation & Orientation"
    },
    "mmind::StepPoseFilter": {
        "deprecatedType": true,
        "groupInfos": {
            "Custum Property": [
                "filterOutAllPoses"
            ],
            "Reference Direction": [
                "dirX",
                "dirY",
                "dirZ"
            ],
            "Threshold Setting": [
                "angleThreshold"
            ]
        },
        "icon_name": "Pose Filter",
        "keywords": "poses",
        "properties": {
            "angleThreshold": {
                "decimals": 1,
                "keyToolTip": "Pose will be filterd if the angle between reference dir and Z axis of pose is larger than angleThreshold.",
                "maximum": 180,
                "minimum": -180,
                "singleStep": 1,
                "suffix": "°"
            },
            "dirX": {
                "name": "X"
            },
            "dirY": {
                "name": "Y"
            },
            "dirZ": {
                "name": "Z"
            },
            "filterOutAllPoses": {
                "keyToolTip": "If one of poses' angle is larger than angleThreshold,all poses will be filtered."
            }
        }
    },
    "mmind::StepPoseInROI": {
        "deprecatedType": true,
        "icon_name": "Collect Poses in 3D ROI",
        "properties": {
            "inputPosesCoordType": {
                "name": "Input Poses Coordinate Type"
            }
        },
        "subgroup": "Collect / Remove"
    },
    "mmind::StepPoseInversion": {
        "icon_name": "Inverse Poses",
        "infrequentlyUsed": true,
        "keywords": "Pose Inverse",
        "subgroup": "Inversion"
    },
    "mmind::StepPoseMultiplyPose": {
        "icon_name": "Pose Transformed by Pose2 in Object Coordinate",
        "infrequentlyUsed": true,
        "properties": {
            "predefined": {
                "name": "Predefined Transform"
            }
        },
        "subgroup": "Pose Transformation"
    },
    "mmind::StepPoseMultiplyQuaternion": {
        "icon_name": "Pose Transformed by Quaternion in Object Coordinate",
        "infrequentlyUsed": true,
        "properties": {
            "predefined": {
                "name": "Predefined Transform"
            }
        },
        "subgroup": "Pose Transformation"
    },
    "mmind::StepPoseNMS": {
        "deprecatedType": true,
        "groupInfos": {
            "Neighboring Poses Search Settings": [
                "searchRadiusNMS"
            ],
            "Threshold Settings": [
                "scoreRatioThreshold"
            ]
        },
        "icon_name": "Suppress Neighboring Poses with Low Scores (NMS)",
        "properties": {
            "scoreRatioThreshold": {
                "decimals": 3,
                "keyToolTip": "Poses of which normalized scores are lareger than this threshold will be considered to perform Non Maxium Suppression(NMS). \nThe normalized score is equal to the squared socre of the current pose divided by the sum of squared socres of all poses.",
                "maximum": 1,
                "minimum": 0,
                "name": "Score Ratio Threshold (0 ~ 1)"
            },
            "searchRadiusNMS": {
                "keyToolTip": "The radius used to search for the local pose with maximum score.",
                "minimum": 0,
                "name": "Local Search Radius",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            }
        },
        "subgroup": "Collect / Remove"
    },
    "mmind::StepPoseNumLimit": {
        "deprecatedType": true,
        "keywords": "Pose Num Limit",
        "properties": {
            "poseNumLimit": {
                "decimals": 0,
                "keyToolTip": "The number limit of the output pose.",
                "minimum": 0,
                "name": "Ouput Poses Size",
                "singleStep": 1
            }
        }
    },
    "mmind::StepPoseOffsetInCylinder": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Cylinder Properties": [
                "zDisMinThre",
                "zDisMaxThre",
                "xoyDisMinThre",
                "xoyDisMaxThre"
            ],
            "Pose Compensation Method": [
                "useLocalZAxis"
            ],
            "Usage Settings for Input Clouds": [
                "useCenter",
                "allUseFirstCloud"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "allUseFirstCloud": {
                "keyToolTip": "Selected when only using the first cloud in the input vector.",
                "name": "Extract Points from First Cloud in Input List"
            },
            "useCenter": {
                "infrequentlyUsed": true,
                "keyToolTip": "Selected to only check whether the center point is close to the pose center, otherwise check every points in the cloud.",
                "name": "Judge If Points in Cylinder by Their Center"
            },
            "xoyDisMaxThre": {
                "keyToolTip": "The maximum distance threshsod on XOY plane.",
                "minimum": 0,
                "name": "Outer Radius",
                "subtype": 2,
                "suffix": "m"
            },
            "xoyDisMinThre": {
                "keyToolTip": "The minimum distance threshold on XOY plane.",
                "minimum": 0,
                "name": "Inner RadIus",
                "subtype": 2,
                "suffix": "m"
            },
            "zDisMaxThre": {
                "keyToolTip": "The maximum distance threshold along Z direction.",
                "name": "Max Z Value in Cylinder's Coordinate",
                "subtype": 2,
                "suffix": "m"
            },
            "zDisMinThre": {
                "keyToolTip": "The minimum distance threshold along Z direction.",
                "name": "Min Z Value in Cylinder's Coordinate",
                "subtype": 2,
                "suffix": "m"
            }
        },
        "subgroup": "Adjust Translation"
    },
    "mmind::StepPoseRectify": {
        "subgroup": "Adjust Orientation"
    },
    "mmind::StepPoseRevolve": {
        "groupInfos": {
            "Revolution Settings": [
                "angleInterval"
            ],
            "Threshold Settings": [
                "minRevolveThreshold",
                "maxRevolveThreshold"
            ]
        },
        "icon_name": "Generate Discrete Poses Revolving Around Reference Pose",
        "infrequentlyUsed": true,
        "keywords": "Pose Revolve",
        "properties": {
            "angleInterval": {
                "decimals": 0,
                "keyToolTip": "A new pose is generated every time the original pose has revolved through this angle.",
                "maximum": 360,
                "minimum": 0,
                "name": "Angle Interval (0 ~ 360)",
                "singleStep": 1,
                "suffix": "°"
            },
            "maxRevolveThreshold": {
                "decimals": 0,
                "keyToolTip": "If the angle between the x-axis of the original pose and the x-axis of the reference pose is larger than this value, the original pose is not revolved.",
                "maximum": 360,
                "name": "Max Start Angle",
                "singleStep": 1,
                "suffix": "°"
            },
            "minRevolveThreshold": {
                "decimals": 0,
                "keyToolTip": "If the angle between the x-axis of the original pose and the x-axis of the reference pose is smaller than this value, the original pose is not revolved.",
                "maximum": 360,
                "name": "Min Start Angle",
                "singleStep": 1,
                "suffix": "°"
            }
        },
        "subgroup": "Generate Pose / Offset"
    },
    "mmind::StepPoseRotation": {
        "groupInfos": {
            "Reference Direction": [
                "x",
                "y",
                "z"
            ],
            "Rotation Angle Settings": [
                "rotAngle"
            ]
        },
        "icon_name": "Rotate Poses around Given Axis",
        "keywords": "Pose Rotation",
        "properties": {
            "rotAngle": {
                "decimals": 0,
                "keyToolTip": "Rotation around the reference direction in self coodination.",
                "singleStep": 1,
                "subtype": 3,
                "suffix": "°"
            }
        },
        "subgroup": "Adjust Orientation"
    },
    "mmind::StepPoseSmooth": {
        "developingType": true,
        "groupInfos": {
            "Gaussian Filter Settings": [
                "gaussianFilterRadius",
                "gaussianFilterSigma"
            ]
        },
        "icon_name": "Smooth Trajectory",
        "keywords": "Pose Smooth",
        "properties": {
            "SmoothType": {
                "keyToolTip": "The translation along the specified axis will be smoothed.",
                "name": "Smoothed Axis"
            },
            "gaussianFilterRadius": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "Gaussian kernel size for smoothing operation.",
                "minimum": 0,
                "name": "Kernal Size",
                "singleStep": 1,
                "valueToolTip": "The final kernel size is 2 * Kernel Size + 1"
            },
            "gaussianFilterSigma": {
                "infrequentlyUsed": true,
                "keyToolTip": "Gaussian kernel standard deviation in X and Y direction.",
                "minimum": 0,
                "name": "Standard Deviation"
            }
        },
        "subgroup": "Adjust Trajectory"
    },
    "mmind::StepPoseSortByNumList": {
        "icon_name": "Sort Poses by Input Scores",
        "subgroup": "Pose Sorting"
    },
    "mmind::StepPoseSortBySelfInfo": {
        "icon_name": "Sort Poses by XYZ Values",
        "properties": {
            "axisType": {
                "name": "Value for Sorting"
            }
        },
        "subgroup": "Pose Sorting"
    },
    "mmind::StepPoseToAffine3d": {
        "icon_name": "From PoseList to Matrix4D",
        "infrequentlyUsed": true,
        "keywords": "Pose To Affine3d",
        "subgroup": "Conversion"
    },
    "mmind::StepPoseVisualizer": {
        "groupInfos": {
            "Visualization Settings": [
                "showCloudInSceneType",
                "showPosesType"
            ]
        },
        "properties": {
            "showCloudInSceneType": {
                "name": "Show Cloud Under Chosen Coordinate"
            },
            "showPosesType": {
                "infrequentlyUsed": true,
                "keyToolTip": "Poses to visualize: processed poses (default). unprocessed poses, processed and unprocessed poses.",
                "name": "Pose Visuals Setting"
            }
        }
    },
    "mmind::StepProbabilityTrigger": {
        "developingType": true,
        "groupInfos": {
            "Testing Configurations": [
                "testMode",
                "testNum"
            ]
        },
        "properties": {
            "probabilities": {
                "keyToolTip": "Input probabilities as a string: 0.5/0.5 or 0.4/0.3/0.2\nInput is valid as long as the probabilities are splited by '/'."
            },
            "testMode": {
                "infrequentlyUsed": true,
                "keyToolTip": "Flag for execution or test mode. If set true, the step will perform a test for the current input probabilities."
            },
            "testNum": {
                "infrequentlyUsed": true,
                "keyToolTip": "The total rounds of generating random number under test mode.",
                "maximum": 999999,
                "minimum": 100,
                "singleStep": 100
            }
        },
        "subgroup": "Trigger"
    },
    "mmind::StepProcedureOut": {
        "icon_name": "Procedure Out",
        "properties": {
            "outputKeysJoined": {
                "keyToolTip": "Output keys joined by \";\" (half-width semicolon). Enabled when \"outputType\" is \"Dynamic\".",
                "name": "Customized Ports Name",
                "subtype": 4,
                "valueToolTip": "Set data type output to external communication\n\nThe key to communicate with Viz:\nposes: Recognized object pose array. Example: [[1,1,0.5,1,0,0,0]]. Required.\nlabels: Object label (string) array. Example: [\"big\", \"small\"]. Length: equal to poses, or 0. Optional.\nsizes (old name sizeVec): Object 3D size array. Example: [[0.4,0.2,0.1]]. Length: equal to poses, or 0. Optional.\noffsets: Object picking point offset pose array. Defined in the object coordinate system. Length: equal to poses, or 0. Optional.\nobjectIndexes (old name boxIdx): Object index array. Example: [0,1,0,2]. Length: equal to poses, or 0. Optional.\npickBoxPoses: Pickbox pose array. 1st is pickbox, and the following are box faces (named as boxface-1, etc.), pickBoxSizes similar. Optional.\npickBoxSizes: Pickbox 3D size array. If less than the length of pickBoxPoses, the sizes of these are not updated. Optional."
            },
            "outputType": {
                "name": "Port Type",
                "valueToolTip": "Predefined: Use the ports predefined by the developer.\nDynamic: Customize the ports by settings."
            }
        },
        "subgroup": "Procedure Out"
    },
    "mmind::StepProcessCollectedData": {
        "developingType": true,
        "properties": {
            "additionalInfo": {
                "keyToolTip": "Additional infos to add to the dataset, such as suction cup configuration. Type in the info as json object format.",
                "stringFileFilter": "*.json",
                "subtype": 2
            },
            "cameraParaDir": {
                "keyToolTip": "Directory containing camera parameter .json files.",
                "subtype": 1
            },
            "collectionDir": {
                "keyToolTip": "Directory containing grasp result log files.",
                "subtype": 1
            }
        },
        "subgroup": "Image"
    },
    "mmind::StepPyEngine": {
        "icon_name": "Calc Results by Python",
        "properties": {
            "funcName": {
                "subtype": 3
            },
            "inputs": {
                "name": "Input Port(s)",
                "valueToolTip": "This parameter is for defining the input port(s).\nPlease separate port names with semicolons.\nFor example, to define an image port and a number list port, please enter Image;NumberList."
            },
            "outputs": {
                "name": "Output Port(s)",
                "valueToolTip": "This parameter is for defining the output port(s).\nPlease separate port names with semicolons.\nFor example, to define an image port and a number list port, please enter Image;NumberList."
            },
            "scriptFilePath": {
                "stringFileFilter": "Python(*.py)",
                "subtype": 2
            }
        },
        "subgroup": "Script Engine"
    },
    "mmind::StepQuaternionCompositionFromAxisAngle": {
        "icon_name": "Compose Quaternion From Axis and Angle",
        "infrequentlyUsed": true,
        "properties": {
            "angle": {
                "subtype": 3
            }
        },
        "subgroup": "Pose Composition & Decomposition"
    },
    "mmind::StepQuaternionCompositionFromTwoAxis": {
        "icon_name": "Compose Quaternion From Two Axis (Right-Hand)",
        "infrequentlyUsed": true,
        "subgroup": "Pose Composition & Decomposition"
    },
    "mmind::StepQuaternionDecompositionToThreeAxis": {
        "icon_name": "Decompose Quaternions to X- Y- Z- Axes",
        "infrequentlyUsed": true,
        "subgroup": "Pose Composition & Decomposition"
    },
    "mmind::StepQuaternionInversion": {
        "icon_name": "Inverse Quaternions",
        "infrequentlyUsed": true,
        "subgroup": "Inversion"
    },
    "mmind::StepReadBarCode": {
        "icon_name": "Read Bar Code",
        "infrequentlyUsed": true
    },
    "mmind::StepReadImage": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Image File Settings": [
                "isDepth",
                "colorImgPath",
                "colorImgExt"
            ],
            "Reading Settings": [
                "outputPathType",
                "outputAllAtOnce"
            ]
        },
        "icon_name": "Read Images",
        "infrequentlyUsed": true,
        "properties": {
            "colorImgExt": {
                "keyToolTip": "The file name extension.",
                "name": "Image File Format"
            },
            "colorImgPath": {
                "keyToolTip": "The image file path or a directory containing image files.",
                "name": "Image File Path",
                "stringFileFilter": "*.png *.jpg",
                "subtype": 2
            },
            "isDepth": {
                "keyToolTip": "Chekced if the loaded image is a depth image.",
                "name": "Is Depth Image"
            },
            "outputAllAtOnce": {
                "infrequentlyUsed": true,
                "keyToolTip": "Output all the pictures of the specified type in the folder at once.",
                "name": "Read All at Once"
            },
            "outputPathType": {
                "infrequentlyUsed": true,
                "keyToolTip": "Define the type of the output file path.",
                "valueToolTip": "AbsolutePath: The absolute path of the image.\nBasePath: The name of the image."
            }
        },
        "subgroup": "Read"
    },
    "mmind::StepReadModelAndGeoCenter": {
        "groupInfos": {
            "Cloud Orientation Calculation": [
                "pointOrientationCalcMode",
                "searchPtsSizeForCalcOrientation"
            ],
            "Model Settings": [
                "modelFile",
                "geometryCenterFile",
                "modelLabelFile",
                "modelSelection"
            ]
        },
        "properties": {
            "geometryCenterFile": {
                "keyToolTip": "The file format is JSON.",
                "name": "Geo Center Point File",
                "stringFileFilter": "*.json",
                "subtype": 2,
                "valueToolTip": "geometric center point file paths"
            },
            "modelFile": {
                "keyToolTip": "The file format is ply.",
                "name": "Model File",
                "stringFileFilter": "*.ply",
                "subtype": 2,
                "valueToolTip": "model point cloud file path"
            },
            "modelLabelFile": {
                "keyToolTip": "The file format is JSON.",
                "name": "Model Label File (Optional)",
                "stringFileFilter": "*.json",
                "subtype": 2,
                "valueToolTip": "label file path (optional)"
            },
            "modelSelection": {
                "keyToolTip": "Select a model in the model gallery.",
                "subtype": 3
            },
            "pointOrientationCalcMode": {
                "keyToolTip": "The methods for calculating the orientations of the points in the point cloud:\n• Origin: Use the normals of each point in the input cloud directly.\n• StandardMode: Recalculate the normals of each point in the input point cloud using CPU. It is recommended when there is no normal in the template model.\n• EdgeTangent: Calculate the tangent of the input edge point cloud. It is recommended when matching the edge point cloud of flat objects. \n  It can be used to distinguish the two sides of a flat object or different objects with outlines that are symmetrical to each other.\n• EdgeNormal: Calculate the normal of the input edge point cloud. It is recommended when matching the edge point cloud of flat objects.\n\nWhen using EdgeTangent or EdgeNormal, please ensure that each edge point cloud does not contain multiple objects (the point cloud of each object has been fairly segmented)."
            },
            "searchPtsSizeForCalcOrientation": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "The number of points used for calculating the orientation of points.",
                "minimum": 1,
                "name": "Number of Searching Points",
                "singleStep": 1
            }
        }
    },
    "mmind::StepReadModelAndGeoCenterV2": {
        "groupInfos": {
            "Model Settings": [
                "modelSelection",
                "modelFileName",
                "geoCenterFileName"
            ]
        },
        "properties": {
            "geoCenterFileName": {
                "keyToolTip": "The file format is JSON.",
                "name": "Geo Center Point File",
                "stringFileFilter": "*.json",
                "subtype": 2,
                "valueToolTip": "geometric center point file paths"
            },
            "modelFileName": {
                "keyToolTip": "The file format is ply.",
                "name": "Model File",
                "stringFileFilter": "*.ply",
                "subtype": 2,
                "valueToolTip": "model point cloud file path"
            },
            "modelSelection": {
                "infrequentlyUsed": false,
                "keyToolTip": "Select a model in the model gallery.",
                "notEditable": false,
                "required": false,
                "subtype": 3
            }
        }
    },
    "mmind::StepReadObjectSizes": {
        "groupInfos": {
            "Box Dimension Settings": [
                "boxSizeListJson"
            ],
            "Box Size Settings": [
                "xLen",
                "yLen",
                "zLen",
                "autoGenerateBoxSizes"
            ],
            "Read Settings": [
                "getSizeFromProperty"
            ]
        },
        "icon_name": "Read Object Dimensions",
        "keywords": "Read Object Sizes",
        "properties": {
            "autoGenerateBoxSizes": {
                "infrequentlyUsed": true
            },
            "boxSizeListJson": {
                "keyToolTip": "If the file content is [0.4,0.3] , the box length should be 0.4 and box width should be 0.3.",
                "name": "Box Dimension File Name",
                "stringFileFilter": "*.json",
                "subtype": 2,
                "valueToolTip": "box dimension file path"
            },
            "getSizeFromProperty": {
                "name": "Read Sizes from Properties"
            },
            "xLen": {
                "minimum": 0.0001,
                "name": "Length on X-axis",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "yLen": {
                "minimum": 0.0001,
                "name": "Length on Y-axis",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "zLen": {
                "minimum": 0.0001,
                "name": "Length on Z-axis",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            }
        },
        "subgroup": "Read"
    },
    "mmind::StepReadOpenProjectJson": {
        "properties": {
            "endIndex": {
                "decimals": 0,
                "singleStep": 1
            },
            "startIndex": {
                "decimals": 0,
                "singleStep": 1
            }
        }
    },
    "mmind::StepReadPointCloud": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Point Cloud File Setting": [
                "fileName"
            ]
        },
        "icon_name": "Read Point Cloud",
        "infrequentlyUsed": true,
        "properties": {
            "fileName": {
                "stringFileFilter": "*.ply",
                "subtype": 2,
                "valueToolTip": "The file contains point clouds information."
            }
        },
        "subgroup": "Read"
    },
    "mmind::StepReadPoses": {
        "icon_name": "Read Poses from File",
        "properties": {
            "poseVecFile": {
                "keyToolTip": "(1) It can be a relative path such as 'poses.json'. Step will try to read the file under current project directory during execution time.\n(2) Absolute file path is also supported.",
                "stringFileFilter": "*.json",
                "subtype": 2,
                "valueToolTip": "pose file path\n\nSuffix should be '.json'."
            }
        },
        "subgroup": "Read"
    },
    "mmind::StepReadQrCode": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "subgroup": "Others"
    },
    "mmind::StepReadRoiCenter": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "subgroup": "Read"
    },
    "mmind::StepReadSTL": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "properties": {
            "downSample": {
                "name": "Use Downsampling"
            },
            "leafSize": {
                "decimals": 4,
                "minimum": 0.0001,
                "name": "Leaf Size",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "ratioScale": {
                "minimum": 0.001,
                "name": "Scale Ratio"
            },
            "samplePointSize": {
                "minimum": 1,
                "name": "Number of Sampling Points"
            },
            "stlPath": {
                "name": "STL File Name",
                "stringFileFilter": "*.stl",
                "subtype": 2,
                "valueToolTip": "A STL file or a directory containing STL files."
            }
        },
        "subgroup": "Read"
    },
    "mmind::StepRecordCriterionPoseAndCalcTransformation": {
        "icon_name": "Record Criterion Pose and Calc Transformation",
        "properties": {
            "criterionCreated": {
                "keyToolTip": "Checked: Set the 2D pose input most recently before checking as the criterion pose,\n and calculate the 2D transformations from the poses input to the criterion pose\n during subsequent executions.\nUnchecked: Only record the 2D pose input each time, perform no calculation, \nand output a zero-value 2D transformation."
            }
        }
    },
    "mmind::StepRectTemplatesGenerator": {
        "groupInfos": {
            "Template Property": [
                "templateDiagonalQuantization"
            ]
        },
        "icon_name": "Generate Rectangular Edge Templates of Specified Sizes",
        "keywords": "Rectangle Templates Generator",
        "properties": {
            "templateDiagonalQuantization": {
                "infrequentlyUsed": true,
                "keyToolTip": "The length of the diagonal of rectangle template is divided by the number of segments after quantizing template diagonal to get the pixel number of edge line segment.",
                "minimum": 0,
                "name": "Number of Segments After Quantizing Template Diagonal",
                "singleStep": 1,
                "valueToolTip": "Reference value: 10-15"
            }
        },
        "subgroup": "Generate Template"
    },
    "mmind::StepRectifyPoseAccordingToTilt": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Reference Direction": [
                "refDirX",
                "refDirY",
                "refDirZ"
            ],
            "Reference Point": [
                "refPointX",
                "refPointY"
            ],
            "Tilt Translation Ratio": [
                "tranDisScaleTiltInward",
                "tranDisScaleTiltOutward"
            ]
        },
        "infrequentlyUsed": true,
        "keywords": "Rectify Pose By Tilt/Rectify Pose by Tilt",
        "properties": {
            "refDirX": {
                "keyToolTip": "The reference direction of the tilt.",
                "name": "X"
            },
            "refDirY": {
                "keyToolTip": "The reference direction of the tilt.",
                "name": "Y"
            },
            "refDirZ": {
                "keyToolTip": "The reference direction of the tilt.",
                "name": "Z"
            },
            "refPointX": {
                "keyToolTip": "The reference point of the tilt.",
                "name": "X",
                "valueToolTip": "If the included angle between the reference point in the local coordinate and the Z axis is between -90 degrees and 90 degrees, the inward tilt translation ratio will be used, otherwise  the outward one."
            },
            "refPointY": {
                "keyToolTip": "The reference point of the tilt.",
                "name": "Y",
                "valueToolTip": "If the included angle between the reference point in the local coordinate and the Z axis is between -90 degrees and 90 degrees, the inward tilt translation ratio will be used, otherwise  the outward one."
            },
            "tranDisScaleTiltInward": {
                "keyToolTip": "The scaling of the result.",
                "name": "Inward"
            },
            "tranDisScaleTiltOutward": {
                "keyToolTip": "The scaling of the result.",
                "name": "Outward"
            }
        },
        "subgroup": "Adjust Translation"
    },
    "mmind::StepRectifyPoseByObstacle": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "keywords": "Rectify Pose By Obstacle/Rectify Pose by obstacle"
    },
    "mmind::StepRectifyPoseByObstacleV2": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Additional Offset": [
                "x",
                "z",
                "y"
            ],
            "Nut Cloud Cluster Settings": [
                "clusterTolerance",
                "minClusterNumEuclideanCluster",
                "maxClusterNum"
            ]
        },
        "infrequentlyUsed": true,
        "keywords": "Rectify Pose By Obstacle V2/Rectify Pose by obstacle V2",
        "properties": {
            "clusterTolerance": {
                "infrequentlyUsed": true,
                "keyToolTip": "The spatial cluster tolerance as a measure in the L2 Euclidean space.\nThe greater the tolerance, the greater the range of detecting point cloud clusters."
            },
            "maxClusterNum": {
                "keyToolTip": "The maximum number of points that a cluster needs to contain in order to be considered valid.",
                "name": "Max Cluster Size"
            },
            "maxNutRadius": {
                "keyToolTip": "The radius of the nuts.",
                "valueToolTip": "It should be smaller than min end face radius."
            },
            "minClusterNumEuclideanCluster": {
                "keyToolTip": "The minimum number of points that a cluster needs to contain in order to be considered valid.",
                "name": "Min Cluster Size"
            },
            "minEndSurfaceRadius": {
                "keyToolTip": "The radius of the end face."
            },
            "suckerLength": {
                "keyToolTip": "The length of the sucker."
            },
            "x": {
                "keyToolTip": "The additional offset along moving direction."
            },
            "y": {
                "keyToolTip": "The additional offset along moving direction."
            },
            "z": {
                "keyToolTip": "The additional offset along moving direction."
            }
        },
        "subgroup": "Adjust Translation & Orientation"
    },
    "mmind::StepRectifyPoseByOffset": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Cylinder Length Settings": [
                "cylinderLength",
                "cylinderLengthThreRatio"
            ]
        },
        "icon_name": "Adjust Poses by Offsets",
        "infrequentlyUsed": true,
        "keywords": "Rectify Pose By Offset",
        "properties": {
            "additionalOfffset": {
                "keyToolTip": "The additional offset along moving direction."
            },
            "cylinderLength": {
                "minimum": 0,
                "name": "Threshold",
                "valueToolTip": "The length of the cylinder should be less than the product of the threshold coefficient and the threshold."
            },
            "cylinderLengthThreRatio": {
                "minimum": 0,
                "name": "Threshold Ratio",
                "valueToolTip": "The length of the cylinder should be less than the product of the threshold coefficient and the threshold."
            },
            "suckerCoverNextCylinderLengthRatio": {
                "minimum": 0,
                "name": "Cylinder Clouds Threshold Ratio",
                "valueToolTip": "If the percentage of the cylinder point cloud in the capture range is higher than the threshold ratio, the cylinder can be considered to be captureable."
            },
            "suckerLength": {
                "keyToolTip": "The length of sucker.",
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            }
        },
        "subgroup": "Adjust Translation"
    },
    "mmind::StepRectifyRingPose": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "properties": {
            "angleSplit": {
                "keyToolTip": "Take the inner ring point cloud every 360/angleSplit degrees.",
                "maximum": 360,
                "minimum": 1,
                "singleStep": 10,
                "valueToolTip": "The min 1, max 360."
            },
            "circleFitIterations": {
                "keyToolTip": "This method requires iterations to fit a better circle.",
                "minimum": 0,
                "valueToolTip": "The default value of 20 is more general."
            },
            "minContourLength": {
                "keyToolTip": "The minimum length of detected contours.",
                "minimum": 0,
                "suffix": "pixel",
                "valueToolTip": "The num of contour points."
            }
        },
        "subgroup": "Adjust Translation & Orientation"
    },
    "mmind::StepRectifyTrackPointsPoses": {
        "developingType": true,
        "groupInfos": {
            "Rotation Settings": [
                "rotAngleAroundTrackDirection",
                "moveDisAlongZAxis",
                "lessRotAroundZAxis"
            ]
        },
        "icon_name": "Adjust Poses to Obtain Acurate Trajectory",
        "keywords": "Rectify TrackPoints Poses",
        "properties": {
            "lessRotAroundZAxis": {
                "keyToolTip": "Selected to make track point poses have less rotation around Z axis.",
                "name": "Less Rotation Around Z Axis"
            },
            "moveDisAlongZAxis": {
                "keyToolTip": "The translation along Z axis after Rotation.",
                "name": "Z Translation After Rotation",
                "subtype": 2,
                "suffix": "m"
            },
            "rotAngleAroundTrackDirection": {
                "decimals": 4,
                "keyToolTip": "Rotate the pose around the trajectiry direction on XOY plane to reach correct trajectory direction.",
                "name": "Rotation Angle",
                "singleStep": 0.01,
                "subtype": 3,
                "suffix": "°"
            }
        },
        "subgroup": "Adjust Trajectory"
    },
    "mmind::StepRectifyTrajPoseBaseFlange": {
        "developingType": true,
        "icon_name": "Adjust Trajectory Circular Motion",
        "keywords": "Rectify Traj Pose Base Flange",
        "properties": {
            "clockwiseType": {
                "keyToolTip": "Following the current movement, the excution direction of the manipulator.",
                "name": "Execution Direction"
            },
            "isLastJointAngleIncreasingWhenClockwise": {
                "name": "Positive End Joint Increment When Move Clockwise",
                "valueToolTip": "If the end joint angle increment is positive when moving clockwise, select True, otherwise False."
            },
            "priorMoveLastJointAngle": {
                "keyToolTip": "Following the current movement, the angle increment of the last joint.",
                "name": "Angle increment"
            },
            "robotType": {
                "keyToolTip": "Set a robot type to read corresponding settings."
            }
        },
        "subgroup": "Adjust Trajectory"
    },
    "mmind::StepRectifyTranslationZ": {
        "groupInfos": {
            "Adjustment Settings": [
                "rectifyMethod",
                "referenceZAxis"
            ],
            "Calculation Settings": [
                "selectedRefZ"
            ],
            "Cloud Capturing Settings": [
                "localXoySearchRadius"
            ]
        },
        "icon_name": "Move Poses to Point Cloud Surfaces along Z-Axis",
        "keywords": "Rectify Translation Z",
        "properties": {
            "localXoySearchRadius": {
                "keyToolTip": "Projected to the coordinate system corresponding to the reference axis. If a point in the cloud is in the XOY plane circle with the pose as the center and this value as the radius, the point is regarded as a valid point.",
                "maximum": 1,
                "minimum": 0,
                "name": "Radius of XOY Plane",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "rectifyMethod": {
                "name": "Adjustment Setting",
                "valueToolTip": "MinMaxZ: Adjusted by the Max/Min distance between the poses and  the points in the cloud.\nCloudCenter: Adjusted by the distance between the  poses and the center of the point cloud."
            },
            "referenceZAxis": {
                "name": "Reference Z Axis",
                "valueToolTip": "LocalZAxis: Calculate the distance between the valid points and the pose along the Z axis of the pose coordinate system as a reference for offset.\nWorldZAxis: Calculate the distance between the valid points and the pose along the Z axis of the world coordinate system as a reference for offset."
            },
            "selectedRefZ": {
                "keyToolTip": "Selected reference Z value.",
                "name": "Selected Z Value",
                "valueToolTip": "MaxZ: In mode 'MinMaxZ', for each pose, the Max distance between the pose and the points in the cloud will be used.\nMinZ: In mode 'MinMaxZ', for each pose, the Min distance between the pose and the points in the cloud will be used."
            }
        },
        "subgroup": "Adjust Translation"
    },
    "mmind::StepRemoveCloud": {
        "deprecatedType": true,
        "keywords": "Remove Cloud/Subtract Points",
        "properties": {
            "searchRadius": {
                "keyToolTip": "Search radius when removing a point cloud.",
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            }
        },
        "subgroup": "Remove Points"
    },
    "mmind::StepRemoveCloudPoints": {
        "icon_name": "Remove Cloud Points from Point Cloud",
        "keywords": "Remove Cloud/Subtract Points/Remove Points from Point Cloud/Cloud Filter By Model And Pose",
        "properties": {
            "searchRadius": {
                "keyToolTip": "Search radius when removing a point cloud.",
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2
            }
        },
        "subgroup": "Remove Points"
    },
    "mmind::StepRemoveNoiseInMasks": {
        "icon_name": "Remove Noise in Masks",
        "infrequentlyUsed": true,
        "properties": {
            "areaThres": {
                "decimals": 0,
                "keyToolTip": "If found speckle has area less than this threshold, it will be considered as noise and removed from the original mask(s).",
                "minimum": 0,
                "singleStep": 1,
                "suffix": "pixel",
                "valueToolTip": "Usually can be set as value in range [50, 1000]; this value relates to camera resolution."
            }
        },
        "subgroup": "Add / Remove Areas in Masks"
    },
    "mmind::StepRemoveOverlappedPolygons": {
        "groupInfos": {
            "Inspection Criteria": [
                "reachedOutRatioMinThre",
                "reachedOutRatioMaxThre",
                "rectOverlapRatioThre"
            ],
            "Mask Settings": [
                "maskUsage"
            ],
            "Output Strategy": [
                "positionRestraint"
            ]
        },
        "icon_name": "Remove Overlapped Polygons",
        "properties": {
            "maskUsage": {
                "name": "Usage of Input Masks",
                "valueToolTip": "SingleMask: Apply one mask to all the polygons.\nCorrespondingMask: For each polygon, apply a different mask."
            },
            "reachedOutRatioMaxThre": {
                "infrequentlyUsed": true,
                "keyToolTip": "Translating the mask of the box along the positive and negative directions of the long and short axes by one-half length and one-half width, respectively, and calculating the ratio of the translated mask beyond the area of the highest layer mask to the mask area of the box, if greater than the threshold Think of the box on the highest level of the border.",
                "maximum": 1,
                "minimum": 0,
                "name": "Reached Out Ratio Max Thre (0 ~ 1.0)",
                "singleStep": 0.1
            },
            "reachedOutRatioMinThre": {
                "infrequentlyUsed": true,
                "keyToolTip": "Translating the mask of the box along the positive and negative directions of the long and short axes by one-half length and one-half width, respectively, and calculating the ratio of the translated mask beyond the area of the highest layer mask to the mask area of the box, if greater than the threshold Think of the box on the highest level of the border.",
                "maximum": 1,
                "minimum": 0,
                "name": "Reached Out Ratio Min Thre (0 ~ 1.0)",
                "singleStep": 0.1
            },
            "rectOverlapRatioThre": {
                "keyToolTip": "Remove one of two polygons if their overlapping ratio is larger than the threshold.",
                "maximum": 1,
                "minimum": 0,
                "name": "Max Overlap Ratio (0 ~ 1.0)",
                "singleStep": 0.01
            }
        },
        "subgroup": "Remove Polygons"
    },
    "mmind::StepRemoveOverlappingObjects": {
        "groupInfos": {
            "Advanced Calculation Settings": [
                "maskClosingKernelSize",
                "depthImgDilateKernelSize"
            ],
            "Algorithm Settings": [
                "algorithmType"
            ],
            "Cloud Resolution Settings": [
                "leafSize"
            ],
            "Expansion Settings": [
                "expandSizeRatioInX",
                "expandSizeRatioInY",
                "expandSizeRatioInZ"
            ],
            "Object Height Settings": [
                "objectHeightSetting",
                "specifiedHeight"
            ],
            "Threshold Settings": [
                "overlapRatioThreshold"
            ]
        },
        "icon_name": "Remove Overlapped Objects",
        "keywords": "Remove Overlapping Objects",
        "properties": {
            "algorithmType": {
                "keyToolTip": "Choose the algorithm type to remove overlapping objects.\nCheck the value tooltip for details.",
                "name": "Algorithm Type",
                "valueToolTip": "BoundingBoxOfObjectIn3DBased: This type uses the bounding of the object's cloud in 3D to judge the overlap. It is designed for objects without a 3D model such as a package box. ProjectionOfObjectIn2DBased: This type uses the 2D projection of the object's cloud to judge the overlap."
            },
            "depthImgDilateKernelSize": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "This value is the kernel size for dilate the depth image of objects.",
                "minimum": 1,
                "singleStep": 2
            },
            "expandSizeRatioInX": {
                "keyToolTip": "The bounding box will be expanded by this ratio along X-axis.",
                "minimum": 0,
                "name": "Expanding Ratio Along X-axis"
            },
            "expandSizeRatioInY": {
                "keyToolTip": "The bounding box will be expanded by this ratio along Y-axis.",
                "minimum": 0,
                "name": "Expanding Ratio Along Y-axis"
            },
            "expandSizeRatioInZ": {
                "keyToolTip": "The bounding box will be expanded by this ratio along Z-axis.",
                "minimum": 0,
                "name": "Expanding Ratio Along Z-axis"
            },
            "leafSize": {
                "keyToolTip": "The resolution of the the bounding box of the object.",
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "maskClosingKernelSize": {
                "decimals": 1,
                "infrequentlyUsed": true,
                "keyToolTip": "This value is kernel size for closing the image which is projected from 3D points to 2D plane.",
                "maximum": 999,
                "minimum": 3,
                "singleStep": 2
            },
            "objectHeightSetting": {
                "keyToolTip": "Set the calculation method of the object height.",
                "name": "Method to Calc Object Height",
                "valueToolTip": "UsingInputCloudHeigjt: The object height will be automatically calculated according to the input point cloud, which is suitable for non-planar objects.\nUsingSpecifiedHeight: The object height will be directly set to the specified height value, which is suitable for flat objects."
            },
            "overlapRatioThreshold": {
                "decimals": 2,
                "keyToolTip": "The threshold for judging if an object is overlapped by others.",
                "maximum": 1,
                "minimum": 0,
                "name": "Overlap Ratio Threshold (0 ~ 1.0)"
            },
            "specifiedHeight": {
                "keyToolTip": "The specified height value.",
                "maximum": 10,
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            }
        }
    },
    "mmind::StepRemoveOverlappingPoses": {
        "groupInfos": {
            "Threshold Settings": [
                "distThre"
            ]
        },
        "icon_name": "Remove All Overlapping Poses",
        "infrequentlyUsed": true,
        "keywords": "Remove Overlapping Poses/filter",
        "properties": {
            "distThre": {
                "keyToolTip": "Distance threshold to remove poses if pose centers are too close.",
                "minimum": 0,
                "name": "Minimum Acceptable Distance to Other Poses"
            }
        },
        "subgroup": "Collect / Remove"
    },
    "mmind::StepRemovePolygonsOutsideMask": {
        "icon_name": "Remove Polygons outside Mask",
        "keywords": "Remove Polygons Out of Masks",
        "properties": {
            "maskUsage": {
                "name": "Usage of Input Masks",
                "valueToolTip": "SingleMask: Apply one mask to all the polygons.\nCorrespondingMask: For each polygon, apply a different mask."
            },
            "overlapRatioThre": {
                "keyToolTip": "The ratio of the overlap area of the object mask and the input mask to the object mask, preserves the result when above this threshold.",
                "maximum": 1,
                "minimum": 0,
                "name": "Min Intersection Ratio (0 ~ 1.0)",
                "singleStep": 0.1
            }
        },
        "subgroup": "Remove Polygons"
    },
    "mmind::StepRemovePosesInsideCones": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "properties": {
            "bigRadius": {
                "subtype": 2,
                "suffix": "m"
            },
            "theta": {
                "maximum": 89,
                "minimum": 1,
                "name": "θ",
                "suffix": "°"
            },
            "zDirDiffThre": {
                "keyToolTip": "Pose A is not considered as beneath pose B if the angle between their Z axes is greater than this value.",
                "maximum": 180,
                "minimum": 0,
                "name": "Threshold for Angle between Z Axes",
                "suffix": "°"
            }
        },
        "subgroup": "Validate"
    },
    "mmind::StepReorder": {
        "icon_name": "Reorder by Index List",
        "keywords": "Sort/Given Indices",
        "subgroup": "Arrange by Index"
    },
    "mmind::StepRepeat": {
        "icon_name": "Repeat Data and Concatenate Copies",
        "subgroup": "Others"
    },
    "mmind::StepRepeatAccStats": {
        "groupInfos": {
            "Data for Making Statistics": [
                "predInputType",
                "displacementThreshold",
                "eulerAngleThreshold"
            ],
            "Statistics Saving": [
                "restart",
                "precision",
                "fileNamePrefix",
                "saveDirPath"
            ]
        },
        "icon_name": "Poses Repeatability Statistics",
        "keywords": "Poses Repeat Accuracy Statistics",
        "properties": {
            "displacementThreshold": {
                "keyToolTip": "The upper limit for the position coordinate deviations of input poses.\nIf the deviation of the current input from the last input is beyond \nthe threshold, this Step will raise an error message. For example, if the \nparameter is set to 0.1, the x coordinate of the last pose input is 1,\nand that of the current pose input is 0.7, this Step will raise an error message.",
                "maximum": 100,
                "minimum": 0,
                "name": "Threshold for Acceptable Position Coordinate Deviations [0~100]",
                "singleStep": 1,
                "suffix": "mm"
            },
            "eulerAngleThreshold": {
                "keyToolTip": "The upper limit for the Euler angle deviations of input poses.\nIf the deviation of the current input from the last input is beyond the threshold, this \nStep will raise an error message. For example, if the \nparameter is set to 5, the α value of Euler angles (α, β, γ) of the last pose input is 30,\nand that of the current pose input is 36, this Step will raise an error message.",
                "maximum": 5,
                "minimum": 0,
                "name": "Threshold for Acceptable Euler Angle Deviations [0~5]",
                "singleStep": 0.1,
                "subtype": 3
            },
            "fileNamePrefix": {
                "keyToolTip": "The prefix of the saved file."
            },
            "precision": {
                "keyToolTip": "Number of decimal places reserved for \nthe statistics data to save. Range: [0, 8]",
                "maximum": 8,
                "minimum": 0,
                "name": "Number of Decimal Places [0~8]",
                "singleStep": 1
            },
            "predInputType": {
                "name": "Input Data Type",
                "valueToolTip": "PoseListInput: Please input a list of poses or lists of poses.\nNumberListInput: Please input data of other types."
            },
            "restart": {
                "keyToolTip": "If set to True, a \"Restart\" mark will be\nadded to the output statistics, and after\nthis Step is successfully executed once,\nthis parameter will be reset to False."
            },
            "saveDirPath": {
                "keyToolTip": "Saving Directory Path.",
                "name": "Saving Directory Path",
                "stringSubtype": 1,
                "subtype": 1
            }
        },
        "subgroup": "Pose"
    },
    "mmind::StepReplaceElementInVector": {
        "developingType": true,
        "icon_name": "default"
    },
    "mmind::StepReverse": {
        "icon_name": "Reverse",
        "infrequentlyUsed": true,
        "subgroup": "Others"
    },
    "mmind::StepRotPoseAroundAxisAngle": {
        "groupInfos": {
            "Angle Settings": [
                "angle"
            ],
            "Axis Settings": [
                "axisType",
                "customizedDir"
            ],
            "Coordinate Settings": [
                "coordinateType"
            ]
        },
        "icon_name": "Rotate Poses around Axis by Angle",
        "properties": {
            "angle": {
                "decimals": 0,
                "subtype": 3
            },
            "customizedDir": {
                "name": "Customized Direction"
            },
            "ignoreZeroNormDirection": {
                "infrequentlyUsed": false
            }
        },
        "subgroup": "Pose Rotation"
    },
    "mmind::StepRotPoseToGoalDirection": {
        "groupInfos": {
            "Goal Direction Settings": [
                "coordinateType",
                "goalAxis",
                "customizedDir"
            ],
            "Rotation Settings": [
                "rotatedAxis",
                "fixedAxis"
            ],
            "Symmetry Settings": [
                "considerRotationalSymmetry",
                "symmetryAngle"
            ],
            "When Directions Came From Input": [
                "directionSourceType",
                "ignoreZeroNormDirection"
            ]
        },
        "icon_name": "Rotate Poses to Goal Direction",
        "properties": {
            "customizedDir": {
                "name": "Customized Direction"
            },
            "directionSourceType": {
                "name": "Data Type of Direction"
            },
            "symmetryAngle": {
                "decimals": 0,
                "keyToolTip": "The smallest non-zero angle for which the object can be rotated (around the fixed axis) to conincide with itself.",
                "maximum": 360,
                "minimum": 0,
                "name": "Symmetry Angle (0 ~ 360)",
                "subtype": 3
            }
        },
        "subgroup": "Pose Rotation"
    },
    "mmind::StepRotSetAxisToAlignDir": {
        "groupInfos": {
            "Axis Settings": [
                "fixedAxis",
                "setAxis"
            ],
            "Reference Direction Settings": [
                "x",
                "y",
                "z"
            ],
            "Reference Point Settings": [
                "useRelativeZ",
                "basePointX",
                "basePointY",
                "basePointZ",
                "relativeZValue"
            ],
            "Reference Poses Usage": [
                "mappingType",
                "alignToAxis"
            ]
        },
        "icon_name": "Rotate Axis to Minimize Included Angle to Reference Direction",
        "keywords": "Rot Set Axis To Align Dir",
        "properties": {
            "alignToAxis": {
                "infrequentlyUsed": false,
                "keyToolTip": "This axis will be the reference dir to be aligned to."
            },
            "basePointX": {
                "name": "X"
            },
            "basePointY": {
                "name": "Y"
            },
            "basePointZ": {
                "name": "Z"
            },
            "fixedAxis": {
                "keyToolTip": "The fixed axis"
            },
            "mappingType": {
                "keyToolTip": "Mapping method is related to how the rotation matrix is computed between the original poses and reference poses.",
                "valueToolTip": "FirstToAll: Align the determined axis of all original poses to the set axis of the first pose in custom input.\nOneToOne: Align determined axis of original poses one-by-one to the corresponding axis of the reference pose in custom input."
            },
            "relativeZValue": {
                "name": "Reletive Z"
            },
            "setAxis": {
                "keyToolTip": "The axis that will be rotated to be aligned to reference direction.",
                "name": "Rotated Axis"
            },
            "useBasePoint": {
                "keyToolTip": "Select only when using base point to calculate reference direction. \nNote: The direction constructed starts from the input pose and points to the reference point.",
                "name": "Use Reference Point",
                "valueToolTip": "True: Use the reference point and the original poses to construct a direction.\nFalse: Use the reference direction."
            },
            "useRelativeZ": {
                "keyToolTip": "Replace Z value of reference point: Z value of reference point = original pose Z value + relative value"
            }
        },
        "subgroup": "Adjust Orientation"
    },
    "mmind::StepRotateImgsByPoses": {
        "developingType": true,
        "icon_name": "Rotate Images By Provided Poses",
        "properties": {
            "referenceAngleIn2D": {
                "decimals": 4,
                "maximum": 180,
                "minimum": -180,
                "singleStep": 0.01,
                "subtype": 3,
                "suffix": "°"
            },
            "transLength": {
                "infrequentlyUsed": true,
                "minimum": 0,
                "subtype": 2,
                "suffix": "m"
            }
        },
        "subgroup": "Image Transform"
    },
    "mmind::StepRotatePosesByLeftMulQuat": {
    },
    "mmind::StepRotatePosesLocally": {
        "icon_name": "Rotate Poses Locally",
        "infrequentlyUsed": true,
        "properties": {
            "axisType": {
                "name": "Axis To Rotate Around"
            },
            "degree": {
                "subtype": 3
            }
        },
        "subgroup": "Pose Rotation"
    },
    "mmind::StepRotateToInputDirectionDynamicallyConsideringSymmetry": {
        "subgroup": "Pose Rotation"
    },
    "mmind::StepRotateToInputDirections": {
        "icon_name": "Rotate Poses to Directions Freely",
        "infrequentlyUsed": true,
        "subgroup": "Pose Rotation"
    },
    "mmind::StepRotateToInputDirectionsWithAngleStep": {
        "icon_name": "Rotate Poses to Directions With Symmetry Constraint",
        "infrequentlyUsed": true,
        "properties": {
            "symmetryAngle": {
                "decimals": 0,
                "maximum": 360,
                "minimum": 0,
                "name": "Symmetry Angle (0 ~ 360)",
                "singleStep": 1,
                "subtype": 3
            }
        },
        "subgroup": "Pose Rotation"
    },
    "mmind::StepRotateToPredefinedDirection": {
        "icon_name": "lab",
        "infrequentlyUsed": true,
        "properties": {
            "customizedDir": {
                "name": "Customized Direction"
            }
        },
        "subgroup": "Pose Rotation"
    },
    "mmind::StepRotateToPredefinedDirectionWithAngleStep": {
        "icon_name": "lab",
        "infrequentlyUsed": true,
        "properties": {
            "customizedDir": {
                "name": "Customized Direction"
            }
        },
        "subgroup": "Pose Rotation"
    },
    "mmind::StepSaveAsRoi": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "3D ROI Dimension Settings": [
                "halfXLen",
                "halfYLen",
                "halfZLen"
            ],
            "Save Settings": [
                "savePath"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "halfXLen": {
                "minimum": 0,
                "name": "Half Length on X-axis",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "halfYLen": {
                "minimum": 0,
                "name": "Half Length on Y-axis",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "halfZLen": {
                "minimum": 0,
                "name": "Half Length on Z-axis",
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "savePath": {
                "name": "3D ROI Output File",
                "stringFileFilter": "*.json",
                "subtype": 2
            }
        },
        "subgroup": "Save"
    },
    "mmind::StepSaveImage": {
        "groupInfos": {
            "Date Related Settings": [
                "createSubDirByDate",
                "saveExpiredDays",
                "autoDeleteExpiredFolders"
            ],
            "Directory Settings": [
                "saveDir",
                "targetName",
                "subFoldersJoined"
            ],
            "File Name Settings": [
                "saveColorImgAsPNG",
                "fileNamePrefix"
            ],
            "Image Index Settings": [
                "autoOverwriteExpiredImgs",
                "maxImgNum",
                "savingIndex",
                "customSavingIndex"
            ],
            "Save Contents Settings": [
                "saveCameraParas",
                "saveFlangePose",
                "notSaveIfUsingVirtualCam"
            ]
        },
        "icon_name": "Save Images",
        "keywords": "measure",
        "properties": {
            "autoDeleteExpiredFolders": {
                "keyToolTip": "When the number of subdirectories exceeds \"Max Subdirectories Num\",  old subdirectories will be automatically deleted to keep the original number.",
                "name": "Delete Expired Subdirectories"
            },
            "autoOverwriteExpiredImgs": {
                "infrequentlyUsed": false,
                "name": "Overwrite Images with Same Name"
            },
            "createSubDirByDate": {
                "keyToolTip": "if checked, a subdirectory will be created and named by the current date.",
                "name": "Create Subdirectories by Date"
            },
            "customSavingIndex": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "minimum": -1,
                "name": "Custom Start Index",
                "singleStep": 1
            },
            "fileNamePrefix": {
                "keyToolTip": "if set, will use the prefix; default is rgb_image_xxx for color image and depth_image_xxx for depth image",
                "name": "Custom Prefix of Image Files"
            },
            "maxImgNum": {
                "decimals": 0,
                "keyToolTip": "if image num exceeds max, will reset next image index to 0",
                "minimum": 1,
                "name": "Max Images' Number",
                "singleStep": 1
            },
            "notSaveIfUsingVirtualCam": {
                "infrequentlyUsed": false,
                "keyToolTip": "Input image will not be saved if the project is using a virtual camera.",
                "name": "Not Save If Using Virtual Camera"
            },
            "saveCameraParas": {
                "infrequentlyUsed": false,
                "keyState": true,
                "name": "Save Camera Parameters"
            },
            "saveColorImgAsPNG": {
                "infrequentlyUsed": true,
                "name": "Save Color Images in PNG Format"
            },
            "saveDir": {
                "keyToolTip": "Dir path to save image",
                "name": "Save Path",
                "subtype": 1,
                "valueToolTip": "directory path to save images\nExample: D:/data"
            },
            "saveExpiredDays": {
                "decimals": 0,
                "keyToolTip": "The data of the recent \"Max Subdirectories Num\" days will be saved.",
                "minimum": 1,
                "name": "Max Subdirectories' Number",
                "singleStep": 1,
                "suffix": "day"
            },
            "saveFlangePose": {
                "infrequentlyUsed": false,
                "keyToolTip": "true: save flange pose;\nfalse: don't save flange pose.",
                "valueToolTip": "EyeInHand:true;\nNot EyeInHand: false;"
            },
            "savingIndex": {
                "keyToolTip": "Input image is to be saved as a filename with index of this value.",
                "name": "Current Image Index",
                "valueToolTip": "The serial number of the next stored picture increases on this basis"
            },
            "subFoldersJoined": {
                "keyToolTip": "Sub folders joined by \";\" (no space). Image number is auto set by first sub folder.",
                "name": "Name of Subdirectories",
                "valueToolTip": "e.g.depth;color"
            },
            "targetName": {
                "infrequentlyUsed": true,
                "valueToolTip": "if target name is not empty, will create sub dir named as targetName"
            }
        },
        "subgroup": "Save"
    },
    "mmind::StepSaveResult": {
        "groupInfos": {
            "Directory Settings": [
                "saveDirPath"
            ],
            "File Name Settings": [
                "fileNamePrefix",
                "fileNameSupplement"
            ],
            "Point Cloud File Settings": [
                "pointCloudFileType"
            ],
            "Saving Order Settings": [
                "SaveMode"
            ]
        },
        "icon_name": "Save Results to File",
        "keywords": "measure",
        "properties": {
            "SaveMode": {
                "infrequentlyUsed": true,
                "valueToolTip": "OrderByDateTime：\nFinal File Name= “Save Path”+ “/” +“Year”+“Month”+ “/”+“Prefix”+“_”+“Time”+“Extension“\n\nOrderBySequence:\nFinal File Name= “Save Path”+ “/” +“Prefix”+“Index”+“Extension“\n\nOrderByIndexDir\nFinal File Name= “Save Path”+ “/” +“ Index of Input String Vector”+“/” +“Prefix”+“Input  Index”+“Extension“\n\nOrderByImageNameAndAffix\nFinal File Name= “Save Path”+ “/” +“Prefix” +“Input Name”+“File Name Supplement”+“Extension“"
            },
            "fileNamePrefix": {
                "subtype": 0
            },
            "fileNameSupplement": {
                "subtype": 0
            },
            "saveDirPath": {
                "name": "Save Path",
                "subtype": 1,
                "valueToolTip": "file storage path"
            }
        },
        "subgroup": "Save"
    },
    "mmind::StepSaveResultToXmlFile": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "subgroup": "Save"
    },
    "mmind::StepSaveStepProperties": {
        "icon_name": "Save Step Parameters to File",
        "subgroup": "Save"
    },
    "mmind::StepSaveTrajectoryPoints": {
        "groupInfos": {
            "Trajectory File Setting": [
                "saveFilePath"
            ]
        },
        "icon_name": "Save Trajectory Points",
        "infrequentlyUsed": true,
        "properties": {
            "saveFilePath": {
                "keyToolTip": "Path to save file.",
                "stringFileFilter": "*.json",
                "subtype": 2
            }
        },
        "subgroup": "Save"
    },
    "mmind::StepScaleROI": {
        "groupInfos": {
            "Color ROI Scaling": [
                "autoRoiScale",
                "roiScale"
            ],
            "Ideal Destination Resolution": [
                "sameAsRoiSettings",
                "width",
                "height"
            ],
            "Padding Color": [
                "isPadding",
                "r",
                "g",
                "b"
            ]
        },
        "icon_name": "Scale Image in 2D ROI",
        "keywords": "measure",
        "properties": {
            "autoRoiScale": {
                "name": "Auto Scale"
            },
            "b": {
                "decimals": 0,
                "maximum": 255,
                "minimum": 0,
                "name": "B (0 ~ 255)",
                "singleStep": 1
            },
            "g": {
                "decimals": 0,
                "maximum": 255,
                "minimum": 0,
                "name": "G (0 ~ 255)",
                "singleStep": 1
            },
            "height": {
                "minimum": 0,
                "suffix": "pixel"
            },
            "inputPortNum": {
                "decimals": 0,
                "keyToolTip": "Number of image input port.",
                "maximum": 8,
                "minimum": 1,
                "name": "Num of Input Ports (1 ~ 8)",
                "singleStep": 1
            },
            "isPadding": {
                "keyToolTip": "Checked to pad scaled image to the 'Dest resolution' with padding color. When input image has only one channel, padding value will be the average of (r, g, b).\nIf unchecked, the output image resolution may be slightly different from 'Dest resolution', as there is no stretching (unchanged aspect ratio) while scaling the image within ROI.",
                "name": "Padding"
            },
            "r": {
                "decimals": 0,
                "maximum": 255,
                "minimum": 0,
                "name": "R (0 ~ 255)",
                "singleStep": 1
            },
            "roiRectType": {
                "name": "Method to Update Color ROI",
                "valueToolTip": "Origin: Extract the Color ROI according to the settings.\nAdapativeModifiedRoiOriginP: Adjust the Color ROI with the bounding box of the image.\nBoundRect: Extract the region of the bounding rectangle of the input image."
            },
            "roiScale": {
                "minimum": 0,
                "name": "Customized Scale"
            },
            "roiSettings": {
                "name": "Color ROI Settings",
                "valueToolTip": "ROIByFile: Read Color ROI from the file.\nROIByParam: Set Color ROI by parameters."
            },
            "sameAsRoiSettings": {
                "name": "Same as Input Color ROI & Skip Scaling"
            },
            "width": {
                "minimum": 0,
                "suffix": "pixel"
            }
        },
        "subgroup": "ROI"
    },
    "mmind::StepScaleROIRecovery": {
        "icon_name": "Recover Scaled Images in 2D ROI",
        "keywords": "measure",
        "subgroup": "ROI"
    },
    "mmind::StepSegmentDepthInRoi": {
        "groupInfos": {
            "Segmentation Settings": [
                "objectsMinHeightDiff",
                "objectsMinArea"
            ]
        },
        "icon_name": "Segment Depth Image",
        "keywords": "measure",
        "properties": {
            "depthRoiPath": {
                "keyToolTip": "The file contains the Depth ROI.",
                "name": "Depth ROI File Name",
                "subtype": 4,
                "valueToolTip": "Set 2D ROI"
            },
            "objectsMinArea": {
                "decimals": 0,
                "keyToolTip": "Minimum number of pixels for an area to be considered as a valid segmented area.",
                "minimum": 0,
                "name": "Minimum Area for Segments",
                "suffix": "pixel"
            },
            "objectsMinHeightDiff": {
                "keyToolTip": "If the height difference between two neighboring pixels is smaller than this value, they belong to the same segment.",
                "minimum": 0,
                "name": "Maximum Value Difference Between Neighbouring Pixels",
                "storeUnit": 2,
                "subtype": 2,
                "suffix": "mm"
            }
        },
        "subgroup": "Segment Area"
    },
    "mmind::StepSetQuaternion": {
        "groupInfos": {
            "Quaternion": [
                "w",
                "x",
                "y",
                "z"
            ]
        },
        "icon_name": "Set Pose Quaternion",
        "infrequentlyUsed": true,
        "properties": {
            "w": {
                "decimals": 4,
                "maximum": 1,
                "minimum": -1,
                "singleStep": 0.01
            },
            "x": {
                "decimals": 4,
                "maximum": 1,
                "minimum": -1,
                "singleStep": 0.01
            },
            "y": {
                "decimals": 4,
                "maximum": 1,
                "minimum": -1,
                "singleStep": 0.01
            },
            "z": {
                "decimals": 4,
                "maximum": 1,
                "minimum": -1,
                "singleStep": 0.01
            }
        },
        "subgroup": "Adjust Orientation"
    },
    "mmind::StepSetTranslation": {
        "groupInfos": {
            "Reference Direction": [
                "x",
                "y",
                "z"
            ],
            "Strategy": [
                "translationStrategy"
            ]
        },
        "icon_name": "Set Pose Translation",
        "infrequentlyUsed": true,
        "properties": {
            "translationStrategy": {
                "keyToolTip": "The X, Y, Z coordinates of the input original poses will be reset according to the strategy set in the parameter."
            }
        },
        "subgroup": "Adjust Translation"
    },
    "mmind::StepShapeDetector": {
        "groupInfos": {
            "Candidates Filter ": [
                "minCoverageRatio",
                "minMeanDistError",
                "minMeanAngleError"
            ],
            "Cylinder Property": [
                "minRadius",
                "maxRadius",
                "ifOptimizeCylinderCoefficients"
            ],
            "Detection Property": [
                "detector",
                "normalDeviation",
                "epsilon",
                "clusterEpsilon",
                "cloudResolution",
                "candidateTopNum",
                "sortBySize",
                "successProbability"
            ],
            "Shape Type": [
                "plane",
                "cylinder",
                "sphere"
            ]
        },
        "icon_name": "Point Cloud Shape Detector",
        "properties": {
            "candidateTopNum": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "Number of output points for each input point cloud",
                "minimum": 0,
                "singleStep": 1
            },
            "cloudResolution": {
                "infrequentlyUsed": true,
                "keyToolTip": "Generally set to twice the minimum interval of clustering, for ensuring the algorithm effect and speed.",
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m",
                "valueToolTip": "In order to facilitate the construction of the shape model and subsequent evaluation of the results, the three-dimensional space of the point cloud will be evenly divided into many rectangular squares, and the point cloud quantization resolution is the size of the square."
            },
            "clusterEpsilon": {
                "infrequentlyUsed": false,
                "keyToolTip": "The absolute maximum tolerance Euclidean distance between a point and a shape.",
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "detector": {
                "infrequentlyUsed": true
            },
            "epsilon": {
                "keyToolTip": "Point cloud fluctuation error. The error is usually between 3~5 mm, depending on the quality of the point cloud.",
                "maximum": 1,
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "ifOptimizeCylinderCoefficients": {
                "keyToolTip": "If optimize the precision of cylinder center and axis"
            },
            "maxRadius": {
                "keyToolTip": "The detected cylinder's radius shoud smaller than this value.",
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "minCoverageRatio": {
                "keyToolTip": "Detect shapes with at least (_minCoverageRatio * cloudSize) points.",
                "maximum": 1,
                "minimum": 0,
                "name": "Min Coverage Ratio (0 ~ 1.0)"
            },
            "minMeanAngleError": {
                "decimals": 4,
                "infrequentlyUsed": true,
                "keyToolTip": "The average angle error between the actual point cloud of the object and the theoretical model of the detection calculation.",
                "maximum": 90,
                "minimum": 0,
                "name": "Min Mean Angle Error (0 ~ 90)",
                "singleStep": 0.1,
                "subtype": 3,
                "suffix": "°"
            },
            "minMeanDistError": {
                "infrequentlyUsed": true,
                "keyToolTip": "The average distance error between the actual point cloud of the object and the theoretical model of the detection calculation.",
                "maximum": 1,
                "minimum": 0,
                "name": "Min Mead Dist Error (0 ~ 1.0)",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "minRadius": {
                "keyToolTip": "The detected cylinder's radius shoud larger than this value.",
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            },
            "normalDeviation": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "keyToolTip": "Maximum normal angle deviation between surface_normal and point_normal",
                "maximum": 180,
                "minimum": 0,
                "singleStep": 10,
                "subtype": 3,
                "suffix": "°"
            },
            "sortBySize": {
                "infrequentlyUsed": true,
                "keyToolTip": "Whether to sort by point cloud points"
            },
            "sphere": {
                "infrequentlyUsed": true
            },
            "successProbability": {
                "infrequentlyUsed": true,
                "keyToolTip": "Ensure that there is sufficient success rate to detect the specified shape type",
                "maximum": 1,
                "minimum": 0,
                "name": "Sucess Probability (0 ~ 1.0)",
                "singleStep": 0.01
            }
        }
    },
    "mmind::StepShowCloud": {
        "groupInfos": {
            "Normal Vector Visualization Settings": [
                "showNormal",
                "normalDisplaySparsity"
            ],
            "Z Value Visualization Settings": [
                "visualizeZValue",
                "upperBound",
                "lowerBound"
            ]
        },
        "icon_name": "Show Point Clouds",
        "keywords": "show clouds/measure",
        "properties": {
            "lowerBound": {
                "keyToolTip": "the lower bound z value rendering with 0",
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "normalDisplaySparsity": {
                "keyToolTip": "The value filled in is the number of interval cloud points. The higher the value, the sparser the displayed normals.",
                "minimum": 1,
                "name": "Display Interval of Normals"
            },
            "showCurvature": {
                "infrequentlyUsed": true,
                "keyToolTip": "Display the curvatures in different colors (large, medium, small curvatures are in red, blue, green, respectively)."
            },
            "showNormal": {
                "keyToolTip": "Checked to display cloud normals.",
                "name": "Show Normals"
            },
            "upperBound": {
                "keyToolTip": "the upper bound z value rendering with 255",
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2,
                "suffix": "m"
            },
            "visualizeZValue": {
                "keyToolTip": "Checked the box to display the point clouds in different gray scales according to the Z value."
            }
        }
    },
    "mmind::StepSimpleArithmeticOpWithVector3d": {
        "icon_name": "Vector3D Arithmetic Operations",
        "infrequentlyUsed": true,
        "subgroup": "Vector3D Related"
    },
    "mmind::StepSmoothDepthMap": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Bilateral Filter": [
                "sigmaDepth",
                "sigmaSpace"
            ],
            "Conditional Mean Filter": [
                "threshold"
            ],
            "General Settings": [
                "nkernelSize"
            ],
            "High Gradient Filter": [
                "",
                "thresholdRemove"
            ],
            "Remove Sparse Filter": [
                "distancePixelRatio",
                "distanceThreshold",
                "numPixels"
            ],
            "Smoothing Method": [
                "smoothType"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "distancePixelRatio": {
                "keyToolTip": "This is the ratio between the depth (mm) and the pixel value."
            },
            "distanceThreshold": {
                "keyToolTip": "If the distance between the center pixel and its neighbor pixel is smaller than this threshold, a counter will be added to one. If the counter is larger than numPixels, this neighbor pixel will be remained. otherwise, it will be ignored."
            },
            "nkernelSize": {
                "keyToolTip": "The search kernel size.",
                "minimum": 0,
                "singleStep": 2
            },
            "numPixels": {
                "keyToolTip": "If the distance between the center pixel and its neighbor pixel is smaller than distanceThreshold, a counter will be added to one. If the counter is larger than this threshold, this neighbor pixel will be remained. otherwise, it will be ignored."
            },
            "sigmaDepth": {
                "keyToolTip": "A larger value of the parameter means that\nfarther depth within the pixel neighborhood will be mixed together, resulting in larger areas of semi-equal depth."
            },
            "sigmaSpace": {
                "keyToolTip": "A larger value of the parameter means that\nfarther pixels will influence each other as long as their depth are close enough."
            },
            "smoothType": {
                "keyToolTip": "Choose the method for smoothing the image."
            },
            "threshold": {
                "keyToolTip": "If depth value is threshold  pixels larger than orign pixel,the pixel will be ignored.",
                "minimum": 0,
                "singleStep": 1
            },
            "": {
                "keyToolTip": "If the gradient of a pixel is larger this thresholdRemove and the gradient of its neighbor pixel is larger than this threshold, this neighbor pixel's value are set to be zero."
            },
            "thresholdRemove": {
                "keyToolTip": "If the gradient of a pixel is larger this threshold and the gradient of its neighbor pixel is larger than thresholdIgnore, this neighbor pixel's value are set to be zero."
            }
        }
    },
    "mmind::StepSort2dPose": {
        "icon_name": "Sort 2D Poses",
        "infrequentlyUsed": true,
        "properties": {
            "isAscending": {
                "keyToolTip": "Checked the box to sort poses in ascending.",
                "name": "Ascending"
            },
            "sortMethod": {
                "keyToolTip": "Choose the method for sorting.",
                "name": "Sorting Strategy",
                "valueToolTip": "NoSort: No operation.\nSort_BY_X: Sort the poses according to the X value of pose translations.\nSort_BY_Y: Sort the poses according to the Y value of pose translations."
            }
        }
    },
    "mmind::StepSort3dPose": {
        "groupInfos": {
            "Reference Direction": [
                "dirX",
                "dirY",
                "dirZ"
            ],
            "Reference Poses": [
                "baseX",
                "baseY",
                "baseZ"
            ],
            "Sorting Strategy Settings": [
                "sortMethod",
                "isAscending"
            ]
        },
        "icon_name": "Sort 3D Poses",
        "properties": {
            "baseX": {
                "decimals": 2,
                "keyToolTip": "Users can sort poses by distance to this reference point (X, Y, Z).",
                "name": "X"
            },
            "baseY": {
                "decimals": 2,
                "keyToolTip": "Users can sort poses by distance to this reference point (X, Y, Z).",
                "name": "Y"
            },
            "baseZ": {
                "decimals": 2,
                "keyToolTip": "Users can sort poses by distance to this reference pose (X, Y, Z).",
                "name": "Z"
            },
            "dirX": {
                "decimals": 2,
                "keyToolTip": "Users can sort poses by the included angle between poses and this reference direction (X, Y, Z).\nNotice: The included angle is defined as the angle between poses' translation vector and reference direction.",
                "name": "X"
            },
            "dirY": {
                "decimals": 2,
                "keyToolTip": "Users can sort poses by the included angle between poses and this reference direction (X, Y, Z).\nNotice: The included angle is defined as the angle between poses' translation vector and reference direction.",
                "name": "Y"
            },
            "dirZ": {
                "decimals": 2,
                "keyToolTip": "Users can sort poses by the included angle between poses and this reference direction (X, Y, Z).\nNotice: The included angle is defined as the angle between poses' translation vector and reference direction.",
                "name": "Z"
            },
            "isAscending": {
                "keyToolTip": "If checked, sort poses' scores by ascending order.",
                "name": "Ascending"
            },
            "sortMethod": {
                "keyToolTip": "Choose the sorting criterion.",
                "valueToolTip": "NONE: No operation.\nSORT_BY_X: Sort the poses and the scores by the X value of the pose translation.\nSORT_BY_Y: Sort the poses and the scores by the Y value of the pose translation.\nSORT_BY_Z: Sort the poses and the scores by the Z value of the pose translation.\nSORT_BY_DIS2BasePt: Sort the poses and the scores by the distance between the reference pose and the input poses.\nSORT_BY_DIS2BasePtOnXYPlane: Sort the poses and the scores by the distance between the reference pose and the input poses on the XY plane.\nSORT_BY_CONFIDENCE: Sort the poses and the scores by the score criteria.\nSORT_BY_CUSTOM_DIR: Sort the poses and the scores by the pose translation along a customized direction.\nSORT_BY_DIAGONAL_LENGTH: Sort the poses and the scores by the diagonal length of the input dimensions."
            }
        }
    },
    "mmind::StepSortAndStratify": {
        "icon_name": "Sort and Stratify",
        "infrequentlyUsed": true,
        "properties": {
            "isAscending": {
                "name": "Ascending"
            },
            "layerInterval": {
                "decimals": 4,
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2
            }
        }
    },
    "mmind::StepSortClouds": {
        "deprecatedType": true,
        "groupInfos": {
            "Reference Point": [
                "baseX",
                "baseY",
                "baseZ"
            ],
            "Sorting Strategy Settings": [
                "isAscending"
            ]
        },
        "icon_name": "Sort Point Clouds",
        "keywords": "Sort Clouds",
        "properties": {
            "axisForSorting": {
                "keyToolTip": "Choose the axis which referece points are sorted by.",
                "name": "Sorting Strategy",
                "valueToolTip": "NONE: None.\nX: According to the X value of the representative point.\nY: According to the Y value of the representative point.\nZ: According to the Z value of the representative point.\nDIS2BasePt: According to the distance between the representative point and the reference point."
            },
            "baseX": {
                "name": "X"
            },
            "baseY": {
                "name": "Y"
            },
            "baseZ": {
                "name": "Z"
            },
            "isAscending": {
                "keyToolTip": "Checked if the ascending is desired.",
                "name": "Ascending"
            },
            "refPointForSorting": {
                "keyToolTip": "The point to represent the point cloud.",
                "name": "Representative Point",
                "valueToolTip": "CenterPoint: Take the center of the point clouds to represent the point cloud.\nBoundaryMinimun: Take the minimum values along x-axis, y-axis and z-axis to represent the point cloud.\nBoundaryMaximmun: Take the maximum values along x-axis, y-axis and z-axis to represent the point cloud."
            }
        }
    },
    "mmind::StepSortCriteriaIndex": {
        "icon_name": "Sort and Output Index List",
        "keywords": "Sort Criteria Index",
        "properties": {
            "isAscending": {
                "name": "Ascending",
                "valueToolTip": "If True is checked, the output will be the indices of the element in ascending order."
            }
        }
    },
    "mmind::StepSpecialReorder": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "keywords": "Special Reorder/Sort"
    },
    "mmind::StepStereoMatch": {
        "deprecatedType": true,
        "infrequentlyUsed": true
    },
    "mmind::StepStraightenRingShapedImageRegion": {
        "groupInfos": {
            "Ring-Shaped Region Settings": [
                "centerX",
                "centerY",
                "radiusScale",
                "startAngle",
                "angleSpan",
                "radius"
            ],
            "Scanning Direction": [
                "radialDirection",
                "Clockwise"
            ]
        },
        "icon_name": "Straighten Ring-Shaped Image Region",
        "properties": {
            "angleSpan": {
                "keyToolTip": "The end side of the ring-shaped region sector is determined by rotating by \nan angle of this parameter's value clockwise from the starting edge set by\n the parameter \"Starting Angle\".",
                "maximum": 720,
                "minimum": 0,
                "name": "Angle Range"
            },
            "interpolation": {
                "keyToolTip": "Bilinear: Bilinear interpolation. The accuracy is higher than nearest neighbor\n interpolation, and the speed is lower.\nNearest_Neighbor: Nearest neighbor interpolation. The accuracy is lower than\n bilinear interpolation, and the speed is higher.",
                "name": "Interpolation Method",
                "singleStep": 0
            },
            "positionAndOrientationCorrection": {
                "keyToolTip": "If this parameter is checked, the ROI set in the earlier execution will be converted to the\n position and orientation that fits the object in the image input in the current execution\n according to the input 2D transformation.",
                "name": "Position and Orientation Correction"
            },
            "radialDirection": {
                "name": "Radial Direction",
                "singleStep": 0
            },
            "radius": {
                "keyToolTip": "When the value of the parameter \"Radius Scaling Ratio\" is greater than 1,\n the parameter \"Radius\" is used as the inner diameter of the ring; otherwise,\n it is used as the outer diameter.",
                "minimum": 1
            },
            "radiusScale": {
                "keyToolTip": "This parameter sets the ratio of the inner/outer diameter of the ring\n to the value of the parameter \"Radius\".",
                "minimum": 0,
                "name": "Radius Scaling Ratio",
                "showSlider": false
            },
            "startAngle": {
                "keyToolTip": "The starting side of the ring-shaped region sector is determined by rotating\n by an angle of this parameter's value clockwise from the positive direction\n of the X axis.",
                "maximum": 360,
                "minimum": -360,
                "name": "Starting Angle",
                "showSlider": false
            }
        }
    },
    "mmind::StepTemplateMatching": {
        "groupInfos": {
            "Match Settings": [
                "paddingSize",
                "skipLowestLevel",
                "tileGrayScaleLowerThrehsold",
                "overlapRatioUpperThreshold",
                "maxNumberOfMatches",
                "matchingScorelowerThresold"
            ],
            "Refinement Settings": [
                "cannyLowThreshold",
                "cannyHighThreshold",
                "icpSceneDownsampleStep",
                "icpModelDownsampleStep",
                "searchRadius",
                "useNonRigidRefinement"
            ],
            "Template Settings": [
                "nmsKernelSize",
                "pathOfTemplateMask",
                "pathOfTemplateImage",
                "beginAngle",
                "endAngle",
                "angleStep",
                "beginScale",
                "endScale",
                "scaleStep",
                "pathOfTemplateFeatureFiles",
                "numberOfTemplateFeatures",
                "fastTemplateFeatureExtraction"
            ]
        },
        "icon_name": "Template Matching",
        "properties": {
            "angleStep": {
                "decimals": 1,
                "keyToolTip": "Please refer to the tooltip for the parameter \"Starting Angle\".",
                "maximum": 360,
                "minimum": 1,
                "name": "Angle Step",
                "singleStep": 0
            },
            "beginAngle": {
                "decimals": 1,
                "keyToolTip": "The starting angle and end angle specify the rotation range of the template in the image when matching. The angle step determines how many degrees every match attempt is made.",
                "maximum": 180,
                "minimum": -180,
                "name": "Starting Angle",
                "singleStep": 1
            },
            "beginScale": {
                "decimals": 2,
                "keyToolTip": "The starting scale and end scale specify the scaling range of the template in the image when matching. The scale step determines at what scaling change every matching attempt is made.",
                "maximum": 1.2,
                "minimum": 0.8,
                "name": "Starting Scale",
                "singleStep": 0.02
            },
            "cannyHighThreshold": {
                "infrequentlyUsed": true,
                "keyToolTip": "For extracting edge pixels in pose refinement. The higher this value, the fewer pixels may be considered edge pixels.",
                "maximum": 255,
                "minimum": 0,
                "name": "Canny Upper Threshold",
                "notEditable": false,
                "required": false
            },
            "cannyLowThreshold": {
                "infrequentlyUsed": true,
                "keyToolTip": "For extracting edge pixels in pose refinement. The lower this value, the more pixels may be considered edge pixels.",
                "maximum": 255,
                "minimum": 0,
                "name": "Canny Lower Threshold",
                "notEditable": false,
                "required": false,
                "singleStep": 0
            },
            "downsampleSteps": {
                "infrequentlyUsed": true,
                "keyToolTip": "This parameter sets the downsampling steps in the image pyramid. Please input an array of positive even numbers (such as [4;4;8]). The length of the array must be exclusively smaller than 5. The numbers must be smaller than or equal to 32.",
                "name": "Downsampling Steps",
                "notEditable": false,
                "required": false
            },
            "endAngle": {
                "decimals": 1,
                "keyToolTip": "Please refer to the tooltip for the parameter \"Starting Angle\".",
                "maximum": 180,
                "minimum": -180,
                "name": "End Angle",
                "singleStep": 1
            },
            "endScale": {
                "decimals": 2,
                "keyToolTip": "Please refer to the tooltip for the parameter \"Starting Scale\".",
                "maximum": 1.2,
                "minimum": 0.8,
                "name": "End Scale",
                "singleStep": 0.02
            },
            "fastTemplateFeatureExtraction": {
                "infrequentlyUsed": true,
                "keyToolTip": "Template feature extraction will be faster when this parameter is checked.",
                "name": "Fast Template Feature Extraction",
                "notEditable": false,
                "required": false
            },
            "gradientMagnitudeLowerThreshold": {
                "keyToolTip": "Object features need to be extracted before matching. Pixels with gradient magnitudes greater than this threshold will be considered feature pixels.",
                "maximum": 255,
                "minimum": 1,
                "name": "Gradient Magnitude Lower Threshold"
            },
            "icpModelDownsampleStep": {
                "infrequentlyUsed": true,
                "keyToolTip": "Used to speed up execution. The larger the value, the faster the pose refinement may be, but the lower the accuracy may be.",
                "maximum": 10,
                "minimum": 1,
                "name": "Template Downsampling Step",
                "notEditable": false,
                "required": false
            },
            "icpSceneDownsampleStep": {
                "infrequentlyUsed": true,
                "keyToolTip": "Please see the tooltip of the parameter \"Template Downsampling Step\".",
                "maximum": 10,
                "minimum": 1,
                "name": "Image Downsampling Step",
                "notEditable": false,
                "required": false,
                "singleStep": 1
            },
            "matchingScorelowerThresold": {
                "decimals": 1,
                "keyToolTip": "Matching results with scores lower than this threshold will be discarded, and the remaining results will be output after being filtered in the refinement process of this Step. \nNote that if this threshold is too high, no results may be output. \nWhen some objects are occluded, this threshold should be appropriately decreased.",
                "maximum": 100,
                "minimum": 1,
                "name": "Matching Score Lower Threshold",
                "singleStep": 0
            },
            "maxNumberOfMatches": {
                "keyToolTip": "When the actual number of matching results is greater than this value, the results at the end of the list will be discarded.",
                "maximum": 50,
                "minimum": 1,
                "name": "Upper Limit for Number of Matches",
                "singleStep": 0
            },
            "nmsKernelSize": {
                "infrequentlyUsed": true,
                "keyToolTip": "The larger the size, the fewer features will be extracted per unit area.",
                "maximum": 5,
                "minimum": 1,
                "name": "NMS Kernel Size",
                "notEditable": false,
                "required": false,
                "singleStep": 0
            },
            "numberOfTemplateFeatures": {
                "infrequentlyUsed": true,
                "keyToolTip": "This value indicates the expected number of feature pixels extracted from the template image. The actual number of feature pixels may not exactly be equal to this value.",
                "maximum": 4096,
                "minimum": 1,
                "name": "Number of Template Feature Pixels",
                "notEditable": false,
                "required": false
            },
            "overlapRatioUpperThreshold": {
                "decimals": 2,
                "keyToolTip": "If there is an overlap between two templates during matching, when the overlap ratio is greater than this value, the result with the higher matching score will be kept and the other result will be discarded.",
                "maximum": 1,
                "minimum": 0,
                "name": "Overlap Ratio Upper Threshold",
                "singleStep": 0.1
            },
            "paddingSize": {
                "infrequentlyUsed": true,
                "keyToolTip": "This value needs to be set when part of an object to be matched is outside the image. If the number of pixels outside the image of the matched template is higher than this threshold, it is considered that there is no match.",
                "maximum": 200,
                "minimum": 0,
                "name": "Padding Pixel Count Upper Threshold",
                "notEditable": false,
                "required": false,
                "singleStep": 0
            },
            "pathOfTemplateFeatureFiles": {
                "keyToolTip": "This file contains the coordinates of all the feature pixels.",
                "name": "Template Feature File Path",
                "subtype": 1
            },
            "pathOfTemplateImage": {
                "keyToolTip": "Please use Step \"Make Template\" to make the template image.",
                "name": "Template Image File Path",
                "subtype": 2
            },
            "pathOfTemplateMask": {
                "keyToolTip": "Template mask image has the same size as the template image, and its non-zero pixel region(s) represents the template mask.",
                "name": "Template Mask File Path",
                "subtype": 2
            },
            "scaleStep": {
                "decimals": 2,
                "keyToolTip": "Please refer to the tooltip for the parameter \"Starting Scale\".",
                "maximum": 0.4,
                "minimum": 0,
                "name": "Scale Step"
            },
            "searchRadius": {
                "decimals": 1,
                "keyToolTip": "The search radius is used to find the correspondences in pose refinement. When the matching results are not very good, please increase this value appropriately.",
                "maximum": 30,
                "minimum": 1,
                "name": "Search Radius",
                "singleStep": 1
            },
            "skipLowestLevel": {
                "infrequentlyUsed": true,
                "keyToolTip": "Ignore the bottom layer of the image pyramid in the algorithm. When checked, the matching speed can be improved.",
                "name": "Skip Lowest Level",
                "notEditable": false,
                "required": false
            },
            "templateFeaturesAlreadyExtracted": {
                "keyToolTip": "If template features have not been extracted, please run this Step without checking this parameter, and feature pixels will be extracted and the pixel coordinates will be stored at the specified path (\"Template Feature File Path\"). After that, please check the parameter. \nWhen template features need to be re-extracted, such as after changing some parameters or the template image, please uncheck this parameter.",
                "name": "Template Features Already Extracted"
            },
            "tileGrayScaleLowerThrehsold": {
                "decimals": 1,
                "infrequentlyUsed": true,
                "keyToolTip": "This parameter is for the optimization strategy. Matching will be performed in the regions where the gray scales are greater than this value.",
                "maximum": 50,
                "minimum": 0,
                "name": "Tile Gray Scale Lower Threshold",
                "notEditable": false,
                "required": false,
                "singleStep": 0.1
            },
            "useNonRigidRefinement": {
                "infrequentlyUsed": true,
                "keyToolTip": "When this value is checked, non-rigid pose refinement will be used. This function is used in scenarios with object deformation.",
                "name": "Apply Non-rigid Refinement",
                "notEditable": false,
                "required": false
            }
        }
    },
    "mmind::StepTest": {
        "developingType": true,
        "infrequentlyUsed": true,
        "properties": {
            "testVariantLine": {
                "subtype": 5
            },
            "testVariantLineF": {
                "subtype": 6
            },
            "testVariantPoint": {
                "subtype": 1
            },
            "testVariantRect": {
                "subtype": 3
            },
            "testVariantRectF": {
                "subtype": 4
            },
            "testVariantString": {
                "subtype": 7
            }
        },
        "subgroup": "Others"
    },
    "mmind::StepTrajMatching": {
        "deprecatedType": true,
        "developingType": true,
        "groupInfos": {
            "Affine": [
                "maxIterations",
                "tolerance",
                "validDistance"
            ],
            "Deform": [
                "beta",
                "lambda"
            ],
            "General Settings": [
                "modelDirName",
                "methodType"
            ]
        },
        "infrequentlyUsed": true,
        "properties": {
            "maxIterations": {
                "decimals": 1,
                "maximum": 1000,
                "minimum": 0,
                "singleStep": 10,
                "valueToolTip": "The maximum iterations for this transform"
            },
            "modelDirName": {
                "subtype": 1
            },
            "tolerance": {
                "maximum": 10,
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m",
                "valueToolTip": "The final tolerance"
            },
            "validDistance": {
                "minimum": 0,
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            }
        }
    },
    "mmind::StepTransPoseByDirectionAndDist": {
        "groupInfos": {
            "Coordinate Settings": [
                "coordinateType"
            ],
            "Direction Settings": [
                "axisType",
                "customizedDir",
                "ignoreZeroNormDirection"
            ],
            "Distance Settings": [
                "moveDistance"
            ]
        },
        "icon_name": "Translate Poses by Direction and Distance",
        "properties": {
            "customizedDir": {
                "name": "Customized Direction"
            },
            "ignoreZeroNormDirection": {
                "infrequentlyUsed": true
            },
            "moveDistance": {
                "decimals": 3,
                "singleStep": 0.001,
                "subtype": 2
            }
        },
        "subgroup": "Pose Translation"
    },
    "mmind::StepTransPosesAlongCustomDirectionByInputDists": {
        "icon_name": "Translate Poses Along Customized Direction by Distances",
        "infrequentlyUsed": true,
        "properties": {
            "customizedDir": {
                "name": "Customized Direction"
            },
            "moveDistance": {
                "singleStep": 0.001,
                "subtype": 2
            }
        },
        "subgroup": "Pose Translation"
    },
    "mmind::StepTransPosesByInputTransVec": {
        "icon_name": "Translate Poses by Vector3D",
        "infrequentlyUsed": true,
        "subgroup": "Pose Translation"
    },
    "mmind::StepTransPosesLocallyByDists": {
        "icon_name": "Translate Poses Locally by Distances",
        "infrequentlyUsed": true,
        "properties": {
            "moveDistance": {
                "singleStep": 0.001,
                "subtype": 2
            }
        },
        "subgroup": "Pose Translation"
    },
    "mmind::StepTransformImage": {
        "icon_name": "Transform Image"
    },
    "mmind::StepTransformPlaneCloudToAlignDirection": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "properties": {
            "useCloudCenter": {
                "keyToolTip": "Only use cloud center and transform"
            },
            "x": {
                "keyToolTip": "The value x of directionZ"
            },
            "y": {
                "keyToolTip": "The value y of directionZ"
            },
            "z": {
                "keyToolTip": "The value z of directionZ"
            }
        },
        "subgroup": "Reshape / Transform / Move"
    },
    "mmind::StepTrigger": {
        "icon_name": "Trigger",
        "infrequentlyUsed": true,
        "subgroup": "Trigger"
    },
    "mmind::StepTriggerControlByFlag": {
        "icon_name": "Trigger Control By Flag",
        "keywords": "measure",
        "properties": {
            "triggerType": {
                "keyState": false
            }
        },
        "subgroup": "Trigger"
    },
    "mmind::StepTwoDimensionalSortingOfPoses": {
        "properties": {
            "clusterRadius": {
                "decimals": 4,
                "minimum": 0,
                "singleStep": 0.01,
                "subtype": 2
            }
        }
    },
    "mmind::StepUnpack": {
        "icon_name": "Unpack",
        "keywords": "measure",
        "properties": {
            "outputSize": {
                "decimals": 0,
                "maximum": 15,
                "minimum": 1,
                "singleStep": 1
            }
        },
        "subgroup": "Change Data Dimension"
    },
    "mmind::StepUnpackAndMerge": {
        "icon_name": "Unpack and Merge",
        "keywords": "convert/map/list/vecter/measure",
        "subgroup": "Change Data Dimension"
    },
    "mmind::StepValueScale": {
        "deprecatedType": true,
        "icon_name": "Number Scaling",
        "keywords": "Value Scale",
        "properties": {
            "inputScaleUsage": {
                "valueToolTip": "Original: Use the input scale as the scale value.\nReciprocal: Use the reciprocal of the input scale as the scale value."
            },
            "scale": {
                "keyToolTip": "If the input scale value is empty, this value will be used."
            }
        }
    },
    "mmind::StepVariantsToLabels": {
        "icon_name": "From Variants to Labels",
        "keywords": "Variants To Labels",
        "properties": {
            "precision": {
                "keyToolTip": "The number of digits after the decimal point.",
                "maximum": 308,
                "minimum": 0
            }
        }
    },
    "mmind::StepVaryingNormalArea": {
        "deprecatedType": true,
        "developingType": true,
        "infrequentlyUsed": true,
        "properties": {
            "kernelSize": {
                "keyToolTip": "The kernel size used to calculate std around a pixel.",
                "maximum": 99,
                "minimum": 3,
                "singleStep": 2
            },
            "threshold": {
                "keyToolTip": "The threshold used to generate binary mask."
            }
        },
        "subgroup": "Image - Point Cloud"
    },
    "mmind::StepVector3dCrossVecotr3d": {
        "icon_name": "Calc Cross Product of Vector3D",
        "infrequentlyUsed": true,
        "subgroup": "Vector3D Related"
    },
    "mmind::StepVector3dDotWithVector3d": {
        "icon_name": "Calc Dot Product of Vector3D",
        "infrequentlyUsed": true,
        "subgroup": "Vector3D Related"
    },
    "mmind::StepVertexDetector": {
        "groupInfos": {
            "VisualizationSettings": [
                "drawEdgePoints",
                "drawRoi",
                "drawVertex",
                "drawBaseline"
            ]
        },
        "icon_name": "Detect Vertex (by Calipers)",
        "properties": {
            "drawBaseline": {
                "keyToolTip": "Baseline is the top side of the ROI."
            },
            "drawEdgePoints": {
                "keyState": false,
                "keyToolTip": "Object edge points are generated as follows: Edge detection frames arranged in parallel along the lateral direction of the ROI are generated within the manually selected ROI, and object edge points are detected through grayscale changes in the edge detection frames."
            }
        }
    },
    "mmind::StepVisualizeDepthInRange": {
        "developingType": true,
        "icon_name": "Visualize Depth in Range",
        "keywords": "measure",
        "properties": {
            "clippingMaximum": {
                "subtype": 2
            },
            "clippingMinimum": {
                "subtype": 2
            },
            "roi": {
                "name": "ROI"
            },
            "visualSettingType": {
                "name": "Visualization Setting Type"
            }
        }
    },
    "mmind::Threshold": {
        "properties": {
            "threImgType": {
                "infrequentlyUsed": true,
                "name": "Image Type"
            },
            "threOperationType": {
                "infrequentlyUsed": false,
                "valueToolTip": "The following operation is recommended:\nTHRESH_BINARY: Generate a mask image of the pixels whose intensity is higher than the threshold.\nTHRESH_BINARY_INV: Generate a mask image of the pixels whose intensity is lower than the threshold."
            },
            "threshold": {
                "decimals": 0,
                "maximum": 255,
                "minimum": 0,
                "name": "Threshold (0~255)",
                "singleStep": 1
            }
        }
    },
    "mmind::UniformSampler": {
        "groupInfos": {
            "Sampling Settings": [
                "leafSize"
            ]
        },
        "properties": {
            "leafSize": {
                "decimals": 6,
                "keyToolTip": "The greater this value is, the more sparse the reduced point cloud will be. \nThis value defines the leaf size used to create a 3D voxel grid. In each voxel, all points will be approximated with their centroid.",
                "maximum": 99,
                "minimum": 0,
                "name": "Sampling Interval",
                "singleStep": 0.001,
                "subtype": 2
            }
        }
    },
    "mmind::VirtualCamera": {
        "properties": {
            "dataPath": {
                "subtype": 1,
                "valueToolTip": "When the \"Stereo Mode\" is:\nActive Mode: Include the path of the depth image and color image file, or include the depth image, color image and flange pose (EyeInHand Mode) subfolder path.\nPassive Mode: Include the path of the left and right color image subfolders.\nActiveAssistedPassive Mode: Include the path of the left, right  color image and the depth image subfolders."
            },
            "filePathType": {
                "keyToolTip": "Image name as string",
                "name": "Image Name Type",
                "valueToolTip": "Complete Path: the absolute path to the file;\nFile Name: the full name of the file, including extension;\nBase Name: the base name consists of all characters in the file up to (but not including) the first '.' character.\n\nExample: \"D:/data/project.tar.gz\"\nComplete Path: \"D:/data/project.tar.gz\"\nFile Name: \"project.tar.gz\" \nBase Name: \"project\""
            },
            "needRectify": {
                "infrequentlyUsed": true
            },
            "playMode": {
                "valueToolTip": "Normal: load image ordered by file name, and end on last image;\nRepeatOne: load current image repeatedly;\nRepeatAll: load image ordered by file name repeatedly, and never end;\nShuffle: load image by random order."
            },
            "startImgIdx": {
                "decimals": 0,
                "infrequentlyUsed": true,
                "minimum": 0,
                "name": "Starting Image Index",
                "singleStep": 1
            }
        }
    },
    "mmind::VoxelGridSampler": {
        "groupInfos": {
            "Sampling Settings": [
                "leafSize"
            ]
        },
        "properties": {
            "leafSize": {
                "decimals": 6,
                "keyToolTip": "The greater this value is, the more sparse the reduced point cloud will be. \nThis value defines the leaf size used to create a 3D voxel grid. In each voxel, all points will be approximated with their centroid.",
                "maximum": 99,
                "minimum": 0,
                "name": "Sampling Interval",
                "singleStep": 0.001,
                "subtype": 2,
                "suffix": "m"
            }
        }
    }
}
